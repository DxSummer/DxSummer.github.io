{"title":"Step6 字符输入/输出和输入验证","date":"2020-06-07T09:52:44.000Z","date_formatted":{"ll":"2020年6月7日","L":"2020/06/07","MM-DD":"06-07"},"link":"posts/86602531","comments":true,"tags":["C语言基础"],"categories":["C语言"],"updated":"2020-06-08T04:05:33.638Z","content":"<p>本章介绍以下内容：</p>\n<ul><li>更详细地介<strong>绍输入、输出</strong>以及<strong>缓冲输入</strong>和<strong>无缓冲输入</strong>的区别</li>\n<li>如何通过键盘模拟文件结尾条件</li>\n<li>如何使用重定向把程序和文件相连接</li>\n<li>创建更友好的用户界面</li>\n</ul><p>在涉及计算机的话题时，我们经常会提到输入（<code>input</code>）和输出（<code>output</code>）。我们谈论输入和输出设备（如键盘、U盘、扫描仪和激光打印机），讲解如何处理输入数据和输出数据，讨论执行输入和输出任务的函数。本章主要介绍用于输入和输出的函数（简称I/O函数）。</p>\n<p>I/O函数（如<code>printf()</code>、<code>scanf()</code>、<code>getchar()</code>、<code>putchar()</code>等）负责把信息传送到程序中。前几章简单介绍过这些函数，本章将详细介绍它们的基本概念。同时，还会介绍如何设计与用户交互的界面。</p>\n<p>最初，<strong>输入/输出函数</strong>不是C定义的一部分，C把开发这些函数的任务留给编译器的实现者来完成。在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型。ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些我们曾经用过的。由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性。因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数。其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面。这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序。本章只着重讲解所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统。处理文件<strong>输入/输出</strong>的程序也可以使用这些函数。</p>\n<p>许多程序都有<strong>输入验证</strong>，即判断用户的输入是否与程序期望的输入匹配。本章将演示一些与输入验证相关的问题和解决方案。</p>\n<h2 id=\"单字符io：getchar和putchar\">单字符I/O：getchar()和putchar()<a href=\"#单字符io：getchar和putchar\" title=\"单字符I/O：getchar()和putchar()\"></a></h2><p>第 7 章中提到过，<code>getchar()</code>和 <code>putchar()</code>每次只处理一个字符。你可能认为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方法很适合计算机。而且，这是绝大多数文本（即，普通文字）处理程序所用的核心方法。为了帮助读者回忆这些函数的工作方式，请看程序清单8.1。该程序获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用 <code>while</code> 循环，当读到<code>#</code>字符时停止。</p>\n<p>程序清单8.1 echo.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* echo.c -- 重复输入 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>　ch;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>　((ch　=　getchar())　!=　<span class=\"string\">'#'</span>)</span><br><span class=\"line\">        <span class=\"built_in\">putchar</span>(ch);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>自从ANSI C标准发布以后，C就把<code>stdio.h</code>头文件与使用<code>getchar()</code>和<code>putchar()</code>相关联，这就是为什么程序中要包含这个头文件的原因（其实，<code>getchar()</code>和 <code>putchar()</code>都不是真正的函数，它们被定义为供预处理器使用的<strong>宏</strong>，我们在第16章中再详细讨论）。运行该程序后，与用户的交互如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello,　there.　I　would[enter]</span><br><span class=\"line\">Hello,　there.　I　would</span><br><span class=\"line\">like　a　#<span class=\"number\">3</span>　bag　of　potatoes.[enter]</span><br><span class=\"line\">like　a</span><br></pre></td></tr></table></figure><p>读者可能好奇，为何输入的字符能直接显示在屏幕上？如果用一个特殊字符（如，#）来结束输入，就无法在文本中使用这个字符，是否有更好的方法结束输入？要回答这些问题，首先要了解 C程序如何处理键盘输入，尤其是缓冲和标准输入文件的概念。</p>\n<h2 id=\"缓冲区\">缓冲区<a href=\"#缓冲区\" title=\"缓冲区\"></a></h2><p>如果在老式系统运行程序清单8.1，你输入文本时可能显示如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HHeelllloo,, tthheerree..II wwoouulldd[enter]</span><br><span class=\"line\">lliikkee aa #</span><br></pre></td></tr></table></figure><p>以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接）输入，即正在等待的程序可立即使用输入的字符。对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。图8.1比较了这两种输入。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/缓冲输入和无缓冲输入.png\" class=\"φcy\"></p>\n<p>为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。</p>\n<p>虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，<strong>缓冲输入</strong>和<strong>无缓冲输入</strong>都有用武之地。</p>\n<p>缓冲分为两类：<strong>完全缓冲I/O</strong>和<strong>行缓冲I/O</strong>。<strong>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区</strong>（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 <strong>512 字节</strong>和 <strong>4096字节</strong>。<strong>行缓冲I/O指的是在出现换行符时刷新缓冲区</strong>。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。</p>\n<p>那么，使用<strong>缓冲输入</strong>还是<strong>无缓冲输入</strong>？ANSI C和后续的C标准都规定输入是缓冲的，不过最初K&amp;R把这个决定权交给了编译器的编写者。读者可以运行echo.c程序观察输出的情况，了解所用的输出类型。</p>\n<p>ANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包括用于<mark><strong>回显无缓冲输入</strong>的<code>getche()</code>函数</mark>和<mark>用于<strong>无回显无缓冲输入</strong>的<code>getch()</code>函数</mark>（<strong>回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击键后对应的字符不显示</strong>）。UNIX系统使用另一种不同的方式控制缓冲。在UNIX系统中，可以使用<code>ioctl()</code>函数（该函数属于UNIX库，但是不属于C标准）<strong>指定待输入的类型</strong>，然后用<code>getchar()</code>执行相应的操作。在ANSI C中，用<code>setbuf()</code>和<code>setvbuf()</code>函数（详见第13章）控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。在这里要对使用无缓冲输入的朋友说声抱歉，本书假设所有的输入都是缓冲输入。</p>\n<h2 id=\"结束键盘输入\">结束键盘输入<a href=\"#结束键盘输入\" title=\"结束键盘输入\"></a></h2><p>在<code>echo.c</code>程序（程序清单8.1）中，只要输入的字符中不含<code>#</code>，那么程序在读到#时才会结束。但是， <code>#</code>也是一个普通的字符，有时不可避免要用到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序。C 的确提供了这样的字符，不过在此之前，先来了解一下C处理文件的方式。</p>\n<h3 id=\"文件、流和键盘输入\">文件、流和键盘输入<a href=\"#文件、流和键盘输入\" title=\"文件、流和键盘输入\"></a></h3><p>文件（file）是存储器中储存信息的区域。通常，文件都保存在某种永久存储器中（如，硬盘、U盘或DVD等）。毫无疑问，文件对于计算机系统相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译储存在名为 echo.c 文件中的程序时，编译器打开echo.c文件并读取其中的内容。当编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打开、读取和关闭文件，还要把数据写入文件。</p>\n<p>C 是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为<strong>底层 I/O</strong> （low-level I/O）。由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包（standard I/O package）来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。</p>\n<p>上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用<strong>单个换行符标记行末尾</strong>，而其他系统可能使用<strong>回车符</strong>和<strong>换行符</strong>的组合来表示行末尾。有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。</p>\n<p>如果使用标准 I/O 包，就不用考虑这些差异。因此，可以用 <code>if (ch ==&#39;\\n&#39;)</code>检查换行符。即使系统实际用的是回车符和换行符的组合来标记行末尾，I/O函数会在两种表示法之间相互转换。</p>\n<p>从概念上看，C程序处理的是流而不是直接处理文件。<strong>流（stream）是一个实际输入或输出映射的理想化数据流。</strong>这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。</p>\n<p>第13章将更详细地讨论文件。本章着重理解C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。<code>stdin</code>流表示键盘输入，<code>stdout</code>流表示屏幕输出。<code>getchar()</code>、<code>putchar()</code>、<code>printf()</code>和<code>scanf()</code>函数都是标准I/O包的成员，处理这两个流。</p>\n<p>以上讨论的内容说明，可以用处理文件的方式来处理键盘输入。例如，程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C 的输入函数内置了文件结尾检测器。既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入。下面我们从文件开始，学习如何结束文件。</p>\n<h3 id=\"文件结尾\">文件结尾<a href=\"#文件结尾\" title=\"文件结尾\"></a></h3><p>计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS和MS-DOS的文本文件曾经用过这种方法。如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记，不过现在有一些其他的选择，例如记录文件的大小。所以现代的文本文件不一定有嵌入的Ctrl+Z，但是如果有，该操作系统会将其视为一个文件结尾标记。图8.2演示了这种方法。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/带文件结尾标记的文件.png\" class=\"φcy\"></p>\n<p>操作系统使用的另一种方法是储存文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符，包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。</p>\n<p>无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义在stdio.h文件中：</p>\n<p>#define EOF (-1)</p>\n<p>为什么是-1？因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。无论哪种情况，-1都不对应任何字符，所以，该值可用于标记文件结尾。</p>\n<p>某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同。如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。</p>\n<p>那么，如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如果两值不同，就说明没有到达文件结尾。也就是说，可以使用下面这样的表达式：</p>\n<p>while ((ch = getchar()) != EOF)</p>\n<p>如果正在读取的是键盘输入不是文件会怎样？绝大部分系统（不是全部）都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程序清单8.1的程序，如程序清单8.2所示。</p>\n<p>程序清单8.2 echo_eof.c程序</p>\n<p>/* echo_eof.c – 重复输入，直到文件结尾 */</p>\n<p>#include　&lt;stdio.h&gt;</p>\n<p>int　main(void)</p>\n<p>{</p>\n<p>int　ch;</p>\n<p>while　((ch　=　getchar())　!=　EOF)</p>\n<p>putchar(ch);</p>\n<p>return　0;</p>\n<p>}</p>\n<p>注意下面几点。</p>\n<p>不用定义EOF，因为stdio.h中已经定义过了。</p>\n<p>不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值。</p>\n<p>变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数，但是EOF的值是-1。还好，getchar()函数实际返回值的类型是int，所以它可以读取EOF字符。如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式。</p>\n<p>由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据。</p>\n<p>ch是整数不会影响putchar()，该函数仍然会打印等价的字符。</p>\n<p>使用该程序进行键盘输入，要设法输入EOF字符。不能只输入字符EOF，也不能只输入-1（输入-1会传送两个字符：一个连字符和一个数字1）。正确的方法是，必须找出当前系统的要求。例如，在大多数UNIX和Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号。许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号，一些系统把任意位置的Ctrl+Z解释成文件结尾信号。</p>\n<p>下面是在UNIX系统下运行echo_eof.c程序的缓冲示例：</p>\n<p>She　walks　in　beauty,　like　the　night</p>\n<p>She　walks　in　beauty,　like　the　night</p>\n<p>Of　cloudless　climes　and　starry　skies…</p>\n<p>Of　cloudless　climes　and　starry　skies…</p>\n<p>Lord　Byron</p>\n<p>Lord　Byron</p>\n<p>[Ctrl+D]</p>\n<p>每次按下Enter键，系统便会处理缓冲区中储存的字符，并在下一行打印该输入行的副本。这个过程一直持续到以UNIX风格模拟文件结尾（按下Ctrl+D）。在PC中，要按下Ctrl+Z。</p>\n<p>我们暂停一会。既然echo_eof.c程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么。假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止。或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据，用echo_eof.c 来储存在文件中输入的内容。假设同时使用这两种方法：把输入从一个文件定向到echo_eof.c中，并把输出发送至另一个文件，然后便可以使用echo_eof.c来拷贝文件。这个小程序有查看文件内容、创建一个新文件、拷贝文件的潜力，没想到一个小程序竟然如此多才多艺！关键是要控制输入流和输出流，这是我们下一个要讨论的主题。</p>\n<p>注意 模拟EOF和图形界面</p>\n<p>模拟EOF的概念是在使用文本界面的命令行环境中产生的。在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号。但是在一些实际应用中，却不能很好地转换成图形界面（如Windows和Macintosh），这些用户界面包含更复杂的鼠标移动和按钮点击。程序要模拟EOF的行为依赖于编译器和项目类型。例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的设置。</p>\n<h2 id=\"重定向和文件\">重定向和文件<a href=\"#重定向和文件\" title=\"重定向和文件\"></a></h2><p>输入和输出涉及函数、数据和设备。例如，考虑 echo_eof.c，该程序使用输入函数 <code>getchar()</code>。输出设备（我们假设）是键盘，输入数据流由字符组成。假设你希望输入函数和数据类型不变，仅改变程序查找数据的位置。那么，程序如何知道去哪里查找输入？</p>\n<p>在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的<code>stdin</code>流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者（假设）是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。</p>\n<p>程序可以通过两种方式使用文件。第 1 种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。我们在第13章中再详细介绍这种方法。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把<code>stdin</code>流重新赋给文件。继续使用<code>getchar()</code>函数从输入流中获取数据，但它并不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，而且能让读者熟悉普通的文件处理技术。</p>\n<p>重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C环境中（包括UNIX、Linux和Windows命令提示模式）都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。在UNIX上运行苹果OS X，可以用UNIX命令行模式启动Terminal应用程序。接下来我们介绍UNIX、Linux和Windows的重定向。</p>\n<h3 id=\"unix、linux和dos重定向\">UNIX、Linux和DOS重定向<a href=\"#unix、linux和dos重定向\" title=\"UNIX、Linux和DOS重定向\"></a></h3><p>UNIX（运行命令行模式时）、Linux（ditto）和Window命令行提示（模仿旧式DOS命令行环境）都能重定向输入、输出。重定向输入让程序使用文件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕。</p>\n<ol><li>重定向输入</li>\n</ol><p>假设已经编译了echo_eof.c 程序，并把可执行版本放入一个名为echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。运行该程序，输入可执行文件名：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo_eof</span><br></pre></td></tr></table></figure><p>该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现在，假设你要用该程序处理名为<code>words</code>的文本文件。文本文件（text file）是内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是一篇散文或者C程序。内含机器语言指令的文件（如储存可执行程序的文件）不是文本文件。由于该程序的操作对象是字符，所以要使用文本文件。只需用下面的命令代替上面的命令即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo_eof &lt; words</span><br></pre></td></tr></table></figure><p><code>&lt;</code>符号是UNIX和DOS/Windows的重定向运算符。该运算符使<code>words</code>文件与<code>stdin</code>流相关联，把文件中的内容导入<code>echo_eof</code>程序。<code>echo_eof</code>程序本身并不知道（或不关心）输入的内容是来自文件还是键盘，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾。因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备。试试看！</p>\n<p>注意 重定向</p>\n<p>对于UNIX、Linux和Windows命令提示，<code>&lt;</code>两侧的空格是可选的。一些系统，如AmigaDOS（那些喜欢怀旧的人使用的系统），支持<strong>重定向</strong>，但是在<strong>重定向符号和文件名之间不允许有空格</strong>。</p>\n<p>下面是一个特殊的<code>words</code>文件的运行示例，<code>$</code>是UNIX和Linux的标准提示符。在Windows/DOS系统中见到的DOS提示可能是<code>A&gt;</code>或<code>C&gt;</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$　echo_eof　&lt;　words</span><br><span class=\"line\">The　world　is　too　much　with　us:　late　<span class=\"keyword\">and</span>　soon,</span><br><span class=\"line\">Getting　<span class=\"keyword\">and</span>　spending,　we　lay　waste　our　powers:</span><br><span class=\"line\">Little　we　see　in　Nature　that　is　ours;</span><br><span class=\"line\">We　have　given　our　hearts　away,　a　sordid　boon!</span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure><ol><li>重定向输出</li>\n</ol><p>现在假设要用echo_eof把键盘输入的内容发送到名为<code>mywords</code>的文件中。然后，输入以下命令并开始输入：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo_eof&gt;mywords</span><br></pre></td></tr></table></figure><p><code>\\&gt;</code>符号是第2个重定向运算符。它创建了一个名为<code>mywords</code>的新文件，然后把<code>echo_eof</code>的输出（即，你输入字符的副本）重定向至该文件中。重定向把<code>stdout</code>从显示设备（即，显示器）赋给<code>mywords</code>文件。如果已经有一个名为<code>mywords</code>的文件，通常会擦除该文件的内容，然后替换新的内容（但是，许多操作系统有保护现有文件的选项，使其成为只读文件）。所有出现在屏幕的字母都是你刚才输入的，其副本储存在文件中。在下一行的开始处按下<code>Ctrl+D</code>（UNIX）或<code>Ctrl+Z</code>（DOS）即可结束该程序。如果不知道输入什么内容，可参照下面的示例。这里，我们使用UNIX提示符<code>$</code>。记住在每行的末尾单击Enter键，这样才能把缓冲区的内容发送给程序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$　echo_eof　&gt;　mywords</span><br><span class=\"line\">You　should　have　no　problem　recalling　which　redirection</span><br><span class=\"line\"><span class=\"keyword\">operator</span>　does　what.　Just　remember　that　each　<span class=\"keyword\">operator</span>　points</span><br><span class=\"line\">in　the　direction　the　information　flows.　Think　of　it　as</span><br><span class=\"line\">a　funnel.</span><br><span class=\"line\">[Ctrl+D]</span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure><p>按下<code>Ctrl+D</code>或<code>Ctrl+Z</code>后，程序会结束，你的系统会提示返回。程序是否起作用了？UNIX的<code>ls</code>命令或Windows命令行提示模式的<code>dir</code>命令可以列出文件名，会显示<code>mywords</code>文件已存在。可以使用UNIX或Linux的<code>cat</code>或DOS的<code>type</code>命令检查文件中的内容，或者再次使用<code>echo_eof</code>，这次把文件重定向到程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$　echo_eof　&lt;　mywords</span><br><span class=\"line\">You　should　have　no　problem　recalling　which　redirection</span><br><span class=\"line\"><span class=\"keyword\">operator</span>　does　what.　Just　remember　that　each　<span class=\"keyword\">operator</span>　points</span><br><span class=\"line\">in　the　direction　the　information　flows.　Think　of　it　as　a</span><br><span class=\"line\">funnel.</span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure><ol><li>组合重定向</li>\n</ol><p>现在，假设你希望制作一份<code>mywords</code>文件的副本，并命名为<code>savewords</code>。只需输入以下命令即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo_eof &lt; mywords &gt; savewords</span><br></pre></td></tr></table></figure><p>下面的命令也起作用，因为命令与重定向运算符的顺序无关：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo_eof &gt; savewords &lt; mywords</span><br></pre></td></tr></table></figure><p>注意：在一条命令中，输入文件名和输出文件名不能相同。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo_eof &lt; mywords &gt; mywords....&lt;--错误</span><br></pre></td></tr></table></figure><p>原因是<code>&gt; mywords</code>在输入之前已导致原<code>mywords</code>的长度被截断为0。</p>\n<p>总之，在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符（<code>&lt;</code>和<code>&gt;</code>）时，要遵循以下原则。</p>\n<ol><li><p>重定向运算符连接一个<strong>可执行程序</strong>（包括标准操作系统命令）和<strong>一个数据文件</strong>，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。</p>\n</li>\n<li><p><strong>使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件</strong>。</p>\n</li>\n</ol><p>通常，文件名和运算符之间的空格不是必须的，除非是偶尔在UNIX shell、Linux shell或Windows命令行提示模式中使用的有特殊含义的字符。例如，我们用过的<code>echo_eof&lt;words</code>。</p>\n<p>以上介绍的都是正确的例子，下面来看一下错误的例子，<code>addup</code>和<code>count</code>是两个可执行程序，<code>fish</code>和<code>beets</code>是两个文本文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fish &gt; beets　　　　　　　　←违反第<span class=\"number\">1</span>条规则</span><br><span class=\"line\">addup &lt; count　　　　　　　 ←违反第<span class=\"number\">1</span>条规则</span><br><span class=\"line\">addup &lt; fish &lt; beets　　　　←违反第<span class=\"number\">2</span>条规则</span><br><span class=\"line\">count &gt; beets fish　　　　　←违反第<span class=\"number\">2</span>条规则</span><br></pre></td></tr></table></figure><p>UNIX、Linux或Windows/DOS 还有<code>&gt;&gt;</code>运算符，<strong>该运算符可以把数据添加到现有文件的末尾</strong>，而 <code>|</code> <strong>运算符能把一个文件的输出连接到另一个文件的输入</strong>。欲了解所有相关运算符的内容，请参阅 UNIX 的相关书籍，如UNIX Primer Plus，Third Edition（Wilson、Pierce和Wessler合著）。</p>\n<ol><li>注释</li>\n</ol><p>重定位让你能使用键盘输入程序文件。要完成这一任务，程序要测试文件的末尾。例如，第 7 章演示的统计单词程序（程序清单7.7），计算单词个数直至遇到第1个<code>|</code>字符。把ch的<code>char</code>类型改成<code>int</code>类型，把循环测试中的<code>|</code>替换成<code>EOF</code>，便可用该程序来计算文本文件中的单词量。</p>\n<p>重定向是一个命令行概念，因为我们要在命令行输入特殊的符号发出指令。如果不使用命令行环境，也可以使用重定向。首先，一些集成开发环境提供了菜单选项，让用户指定重定向。其次，对于 Windows系统，可以打开命令提示窗口，并在命令行运行可执行文件。<strong>Microsoft Visual Studio</strong>的默认设置是把可执行文件放在项目文件夹的子文件夹，称为<code>Debug</code>。文件名和项目名的基本名相同，文件名的扩展名为<code>.exe</code>。默认情况下，<code>Xcode</code>在给项目命名后才能命名可执行文件，并将其放在<code>Debug</code>文件夹中。在UNIX系统中，可以通过<code>Terminal</code>工具运行可执行文件。从使用上看，<code>Terminal</code>比命令行编译器（GCC或Clang）简单。</p>\n<p>如果用不了重定向，可以用程序直接打开文件。程序清单8.3演示了一个注释较少的示例。我们学到第13章时再详细讲解。待读取的文件应该与可执行文件位于同一目录。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">8.3</span> file_eof.c程序</span><br><span class=\"line\"><span class=\"comment\">// file_eof.c --打开一个文件并显示该文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;　　　　　　　// 为了使用exit()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　ch;</span><br><span class=\"line\">    FILE * fp;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> fname[<span class=\"number\">50</span>];　　　　　　　<span class=\"comment\">// 储存文件名</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　the　name　of　the　file:　\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,　fname);</span><br><span class=\"line\">    fp = fopen(fname, <span class=\"string\">\"r\"</span>);　　 <span class=\"comment\">// 打开待读取文件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fp == <span class=\"literal\">NULL</span>)　　　　　　　<span class=\"comment\">// 如果失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed　to　open　file.　Bye\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);　　　　　　　　　<span class=\"comment\">// 退出程序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// getc(fp)从打开的文件中获取一个字符</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>　((ch　=　getc(fp))　!=　EOF)</span><br><span class=\"line\">    \t<span class=\"built_in\">putchar</span>(ch);</span><br><span class=\"line\">    fclose(fp);　　　　　　　　　 <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>小结：如何重定向输入和输出</p>\n<p>绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序，或只在C编译器允许的情况下重定向C程序。假设prog是可执行程序名，file1和file2是文件名。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把输出重定向至文件：&gt;</span><br><span class=\"line\">prog &gt;file1</span><br><span class=\"line\">    </span><br><span class=\"line\">把输入重定向至文件：&lt;</span><br><span class=\"line\">prog &lt;file2</span><br><span class=\"line\">    </span><br><span class=\"line\">组合重定向：</span><br><span class=\"line\">prog　&lt;file2　&gt;file1</span><br><span class=\"line\">prog　&gt;file1　&lt;file2</span><br><span class=\"line\">    </span><br><span class=\"line\">这两种形式都是把file2作为输入、file1作为输出。</span><br></pre></td></tr></table></figure><p>留白：</p>\n<p>一些系统要求重定向运算符左侧有一个空格，右侧没有空格。而其他系统（如，UNIX）允许在重定位运算符两侧有空格或没有空格。</p>\n<h2 id=\"创建更友好的用户界面\">创建更友好的用户界面<a href=\"#创建更友好的用户界面\" title=\"创建更友好的用户界面\"></a></h2><p>大部分人偶尔会写一些中看不中用的程序。还好，C提供了大量工具让输入更顺畅，处理过程更顺利。不过，学习这些工具会导致新的问题。本节的目标是，指导读者解决这些问题并创建更友好的用户界面，让交互数据输入更方便，减少错误输入的影响。</p>\n<h3 id=\"使用缓冲输入\">使用缓冲输入<a href=\"#使用缓冲输入\" title=\"使用缓冲输入\"></a></h3><p>缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入。但是，在使用输入的字符时，它也会给程序员带来麻烦。前面示例中看到的问题是，缓冲输入要求用户按下Enter键发送输入。这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符。我们以一个猜谜程序为例。用户选择一个数字，程序猜用户选中的数字是多少。该程序使用的方法单调乏味，先不要在意算法，我们关注的重点在输入和输出。查看程序清单8.4，这是猜谜程序的最初版本，后面我们会改进。</p>\n<p>程序清单8.4 guess.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* guess.c -- 一个拖沓且错误的猜数字程序 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　guess　=　<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Pick　an　integer　from　1　to　100.　I　will　try　to　guess　\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"it.\\nRespond　with　a　y　if　my　guess　is　right　and　with\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nan　n　if　it　is　wrong.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Uh...is　your　number　%d?\\n\"</span>,　guess);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (getchar() != <span class=\"string\">'y'</span>)　　 <span class=\"comment\">/* 获取响应，与 y 做对比 */</span></span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Well,　then,　is　it　%d?\\n\"</span>,　++guess);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"I　knew　I　could　do　it!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是程序的运行示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pick　an　integer　from　<span class=\"number\">1</span>　to　<span class=\"number\">100.</span>　I　will　<span class=\"keyword\">try</span>　to　guess　it.</span><br><span class=\"line\">Respond　with　a　y　<span class=\"keyword\">if</span>　my　guess　is　right　<span class=\"keyword\">and</span>　with</span><br><span class=\"line\">an　n　<span class=\"keyword\">if</span>　it　is　wrong.</span><br><span class=\"line\">Uh...is　your　number　<span class=\"number\">1</span>?</span><br><span class=\"line\">n</span><br><span class=\"line\">Well,　then,　is　it　<span class=\"number\">2</span>?</span><br><span class=\"line\">Well,　then,　is　it　<span class=\"number\">3</span>?</span><br><span class=\"line\">n</span><br><span class=\"line\">Well,　then,　is　it　<span class=\"number\">4</span>?</span><br><span class=\"line\">Well,　then,　is　it　<span class=\"number\">5</span>?</span><br><span class=\"line\">y</span><br><span class=\"line\">I　knew　I　could　<span class=\"keyword\">do</span>　it!</span><br></pre></td></tr></table></figure><p>撇开这个程序糟糕的算法不谈，我们先选择一个数字。注意，每次输入 n 时，程序打印了两条消息。这是由于程序读取n作为用户否定了数字1，然后还读取了一个换行符作为用户否定了数字2。</p>\n<p>一种解决方案是，使用<code>while</code>循环丢弃输入行最后剩余的内容，包括换行符。这种方法的优点是，能把<code>no</code>和<code>no way</code>这样的响应视为简单的n。程序清单8.4的版本会把no当作两个响应。下面用循环修正</p>\n<p>char response;这个问题：</p>\n<p>while (getchar() != ‘y’)　 /* 获取响应，与 y 做对比*/</p>\n<p>{</p>\n<p>printf(“Well,　then,　is　it　%d?\\n”,　++guess);</p>\n<p>while　(getchar()　!=　‘\\n’)</p>\n<p>continue;　　　　 /* 跳过剩余的输入行 */</p>\n<p>}</p>\n<p>使用以上循环后，该程序的输出示例如下：</p>\n<p>Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.</p>\n<p>Respond　with　a　y　if　my　guess　is　right　and　with</p>\n<p>an　n　if　it　is　wrong.</p>\n<p>Uh…is　your　number　1?</p>\n<p>n</p>\n<p>Well,　then,　is　it　2?</p>\n<p>no</p>\n<p>Well,　then,　is　it　3?</p>\n<p>no　sir</p>\n<p>Well,　then,　is　it　4?</p>\n<p>forget　it</p>\n<p>Well,　then,　is　it　5?</p>\n<p>y</p>\n<p>I knew I could do it!</p>\n<p>这的确是解决了换行符的问题。但是，该程序还是会把f被视为n。我们用if语句筛选其他响应。首先，添加一个char类型的变量储存响应：</p>\n<p>修改后的循环如下：</p>\n<p>while ((response = getchar()) != ‘y’) /* 获取响应 */</p>\n<p>{</p>\n<p>if　(response　==　‘n’)</p>\n<p>printf(“Well,　then,　is　it　%d?\\n”,　++guess);</p>\n<p>else</p>\n<p>printf(“Sorry,　I　understand　only　y　or　n.\\n”);</p>\n<p>while　(getchar()　!=　‘\\n’)</p>\n<p>continue; /* 跳过剩余的输入行 */</p>\n<p>}</p>\n<p>现在，程序的运行示例如下：</p>\n<p>Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.</p>\n","next":{"title":"Step5 C控制语句：分支和跳转","link":"posts/3e5d0fae"},"plink":"https://dxsummer.gitee.io/posts/86602531/","toc":[{"id":"单字符io：getchar和putchar","title":"单字符I&#x2F;O：getchar()和putchar()","index":"1"},{"id":"缓冲区","title":"缓冲区","index":"2"},{"id":"结束键盘输入","title":"结束键盘输入","index":"3","children":[{"id":"文件、流和键盘输入","title":"文件、流和键盘输入","index":"3.1"},{"id":"文件结尾","title":"文件结尾","index":"3.2"}]},{"id":"重定向和文件","title":"重定向和文件","index":"4","children":[{"id":"unix、linux和dos重定向","title":"UNIX、Linux和DOS重定向","index":"4.1"}]},{"id":"创建更友好的用户界面","title":"创建更友好的用户界面","index":"5","children":[{"id":"使用缓冲输入","title":"使用缓冲输入","index":"5.1"}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/86602531/\" title=\"Step6 字符输入/输出和输入验证\">https://dxsummer.gitee.io/posts/86602531/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年6月7日","updated":"2020年6月8日"}}