{"title":"树和二叉树","date":"2020-11-07T12:20:23.000Z","date_formatted":{"ll":"2020年11月7日","L":"2020/11/07","MM-DD":"11-07"},"link":"posts/ec2e91f9","comments":true,"tags":["数据结构"],"categories":["数据结构"],"updated":"2020-11-19T10:05:21.610Z","content":"<h1 id=\"逻辑结构\">逻辑结构<a href=\"#逻辑结构\" title=\"逻辑结构\"></a></h1><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107202313.png\" style=\"zoom:67%;\" /><h1 id=\"树\">树<a href=\"#树\" title=\"树\"></a></h1><p>n（n≥0）个结点的有限集，它或为<strong>空树（n = 0）</strong>；或为<strong>非空树</strong>，对于非空树T：</p>\n<ol><li>有且<strong>仅有一个称之为根的结点</strong></li>\n<li>除根结点以外的其余结点可分为m（m＞0）个互不相交的有限集T1, T2, …, Tm, 其中每一个集合本身又是一棵树，并且称为根的<strong>子树</strong>（SubTree）</li>\n</ol><blockquote>\n<p>树是n个结点的有限集</p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107204231.png\" style=\"zoom: 67%;\" /><h2 id=\"基本术语\">基本术语<a href=\"#基本术语\" title=\"基本术语\"></a></h2><ul><li><p><strong>根</strong>：即根结点(没有前驱)</p>\n</li>\n<li><p><strong>叶子</strong>：即终端结点(没有后继)</p>\n</li>\n<li><p><strong><font color=\"red\">森林</font></strong>：指m棵不相交的树的集合(例如删除A后的子树个数)</p>\n</li>\n<li><p><strong><font color=\"red\">有序树</font></strong>：结点各子树从左至右有序，不能互换（<strong>左为第一</strong>）</p>\n</li>\n<li><p><strong>无序树</strong>：结点各子树可互换位置</p>\n</li>\n<li><p><strong><font color=\"red\">双亲</font></strong>：即上层的那个结点(<strong>直接前驱</strong>)</p>\n</li>\n<li><p><strong><font color=\"red\">孩子</font></strong>：即下层结点的子树的根(<strong>直接后继</strong>)</p>\n</li>\n<li><p><strong>兄弟</strong>：同一双亲下的同层结点（孩子之间互称兄弟）</p>\n</li>\n<li><p><strong>堂兄弟</strong>：即双亲位于同一层的结点（但并非同一双亲）</p>\n</li>\n<li><p><strong>祖先</strong>：即从根到该结点所经分支的所有结点</p>\n</li>\n<li><p><strong>子孙</strong>：即该结点下层子树中的任一结点</p>\n</li>\n<li><p><strong>结点</strong>：即树的数据元素</p>\n</li>\n<li><p><strong><font color=\"red\">结点的度</font></strong>：结点挂接的子树数</p>\n</li>\n<li><p><strong><font color=\"red\">结点的层次</font></strong>：从根到该结点的层数（根结点算第一层）</p>\n</li>\n<li><p><strong>终端结点</strong>：即度为0的结点，即叶子</p>\n</li>\n<li><p><strong>分支结点</strong>：即度不为0的结点（也称为内部结点）</p>\n</li>\n<li><p><strong><font color=\"red\">树的度</font></strong>：所有结点度中的最大值</p>\n</li>\n<li><p><strong><font color=\"red\">树的深度(或高度)</font></strong>：指所有结点中最大的层数</p>\n</li>\n</ul><h1 id=\"二叉树\">二叉树<a href=\"#二叉树\" title=\"二叉树\"></a></h1><p>n（n≥0）个结点所构成的集合，它或为空树（n = 0）；或为非空树，对于非空树T：</p>\n<ol><li>有且仅有一个称之为根的结点；</li>\n<li>除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。</li>\n</ol><h2 id=\"特点\">特点<a href=\"#特点\" title=\"特点\"></a></h2><ol><li>结点的度小于等于2</li>\n<li>有序树（子树有序，不能颠倒）</li>\n</ol><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107220242.png\" style=\"zoom:67%;\" /><h2 id=\"性质🍑\">性质🍑<a href=\"#性质🍑\" title=\"性质🍑\"></a></h2><p><mark>1. </mark>在二叉树的第 <strong>i</strong> 层上至多有2<sup>i-1</sup>个结点( i &gt;= 1 )</p>\n<p><mark>2. </mark>深度为 k 的二叉树至多有 2<sup>k</sup> - 1个结点( k &gt;= 1 )</p>\n<p><mark>3. </mark><font color=\"#729CBD\">对于任何一棵二叉树，<strong>终端结点数</strong>（叶子数）为 n<sub>0</sub> ，若度为2的结点数有n<sub>2</sub>个，则叶子数n<sub>0</sub>=n<sub>2</sub>+1</font></p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107221855.png\" style=\"zoom:67%;\" /><p><mark>4. </mark>具有n个结点的完全二叉树的深度必为[log<sub>2</sub>n]＋1 （<code>[x]</code>不大于<code>x</code>的最大整数，[5.7]=[5] ）</p>\n<p><mark>5. </mark> </p>\n<ul><li><p>对完全二叉树，若从上至下、从左至右编号，则编号为<code>i</code> 的结点，其左孩子编号必为<code>2i</code>，其右孩子编号必为<code>2i＋1</code>；</p>\n</li>\n<li><p>其双亲的编号必为<code>i/2</code>。</p>\n</li>\n</ul><h2 id=\"特殊形态的二叉树\">特殊形态的二叉树<a href=\"#特殊形态的二叉树\" title=\"特殊形态的二叉树\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107222147.png\" style=\"zoom:67%;\" /><ul><li>满二叉树是叶子一个也不少的树，而完全二叉树虽然前n-1层是满的，但最底层却允许在右边缺少连续若干个结点。<strong>满二叉树是完全二叉树的一个特例。</strong></li>\n</ul><h2 id=\"顺序存储\">顺序存储<a href=\"#顺序存储\" title=\"顺序存储\"></a></h2><p>按<strong>满二叉树</strong>的结点层次编号，依次存放二叉树中的数据元素。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107224115.png\" style=\"zoom:67%;\" /><h3 id=\"问题\">问题<a href=\"#问题\" title=\"问题\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107224215.png\" style=\"zoom: 50%;\" /><h2 id=\"链式存储\">链式存储<a href=\"#链式存储\" title=\"链式存储\"></a></h2><blockquote>\n<p>含有两个指针域的节点结构、三个指针域的结点结构</p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/html/20201116200410.png\" style=\"zoom:50%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiNode</span>&#123;</span></span><br><span class=\"line\">   TElemType   data;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">BiNode</span>   *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span> <span class=\"comment\">//左右孩子指针</span></span><br><span class=\"line\">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/html/20201116201425.png\" style=\"zoom:67%;\" /><blockquote>\n<p>eg</p>\n<p><mark>在n个结点的二叉链表中，有<code>n+1</code>个<strong>空指针域</strong></mark></p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/html/20201116201612.png\" style=\"zoom:67%;\" /><h1 id=\"遍历二叉树\">遍历二叉树<a href=\"#遍历二叉树\" title=\"遍历二叉树\"></a></h1><ul><li>指按某条搜索路线遍访每个结点且不重复（又称周游）。</li>\n<li>它是树结构<strong>插入、删除、修改、查找和排序</strong>运算的前提，是二叉树一切运算的基础和核心。</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201117174739.png\" style=\"zoom:50%;\" /><h2 id=\"先序遍历算法\">先序遍历算法<a href=\"#先序遍历算法\" title=\"先序遍历算法\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201117212150.png\" style=\"zoom: 50%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK; <span class=\"comment\">//空二叉树</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">     <span class=\"built_in\">cout</span>&lt;&lt;T-&gt;data; <span class=\"comment\">//访问根结点</span></span><br><span class=\"line\">     PreOrderTraverse(T-&gt;lchild); <span class=\"comment\">//递归遍历左子树</span></span><br><span class=\"line\">     PreOrderTraverse(T-&gt;rchild); <span class=\"comment\">//递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"中序遍历算法\">中序遍历算法<a href=\"#中序遍历算法\" title=\"中序遍历算法\"></a></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK; <span class=\"comment\">//空二叉树</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">     InOrderTraverse(T-&gt;lchild); <span class=\"comment\">//递归遍历左子树</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;T-&gt;data; <span class=\"comment\">//访问根结点</span></span><br><span class=\"line\">     InOrderTraverse(T-&gt;rchild); <span class=\"comment\">//递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"后序遍历算法\">后序遍历算法<a href=\"#后序遍历算法\" title=\"后序遍历算法\"></a></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">PostOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK; <span class=\"comment\">//空二叉树</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">     PostOrderTraverse(T-&gt;lchild); <span class=\"comment\">//递归遍历左子树</span></span><br><span class=\"line\">     PostOrderTraverse(T-&gt;rchild); <span class=\"comment\">//递归遍历右子树</span></span><br><span class=\"line\">     <span class=\"built_in\">cout</span>&lt;&lt;T-&gt;data; <span class=\"comment\">//访问根结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"计算二叉树结点总数\">计算二叉树结点总数<a href=\"#计算二叉树结点总数\" title=\"计算二叉树结点总数\"></a></h2><ol><li><p>如果是空树，则结点个数为0；</p>\n</li>\n<li><p>否则，结点个数为<strong>左子树的结点个数+右子树的结点个数再+1</strong>。</p>\n</li>\n</ol><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NodeCount</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span> ) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  \t\t\t    </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"计算二叉树叶子结点总数\">计算二叉树叶子结点总数<a href=\"#计算二叉树叶子结点总数\" title=\"计算二叉树叶子结点总数\"></a></h2><ol><li><p>如果是空树，则叶子结点个数为0；</p>\n</li>\n<li><p>否则，为<strong>左子树的叶子结点个数+右子树的叶子结点个数</strong>。</p>\n</li>\n</ol><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LeadCount</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) \t<span class=\"comment\">//如果是空树返回0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (T-&gt;lchild == <span class=\"literal\">NULL</span> &amp;&amp; T-&gt;rchild == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//如果是叶子结点返回1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> LeafCount(T-&gt;lchild) + LeafCount(T-&gt;rchild);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"计算二叉树深度\">计算二叉树深度<a href=\"#计算二叉树深度\" title=\"计算二叉树深度\"></a></h2><ol><li>如果是空树，则深度为0；</li>\n<li>否则，递归计算<strong>左子树的深度记为m</strong>，递归计算<strong>右子树的深度记为n</strong>，二叉树的深度则为<strong>m与n的较大者加1</strong>。 </li>\n</ol><h1 id=\"结论\">结论<a href=\"#结论\" title=\"结论\"></a></h1><ul><li>由二叉树的<strong>前序序列</strong>和<strong>中序序列</strong>，或由其<strong>后序序列</strong>和<strong>中序序列</strong>均能<strong>唯一地确定一棵二叉树</strong>，</li>\n<li>但由<strong>前序序列</strong>和<strong>后序序列</strong>却<strong>不一定能</strong>唯一地确定一棵二叉树。 </li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201117220605.png\" style=\"zoom:50%;\" /><h1 id=\"线索化二叉树\">线索化二叉树<a href=\"#线索化二叉树\" title=\"线索化二叉树\"></a></h1><ol><li>若结点有<strong>左子树</strong>，则<code>lchild</code>指向其<strong>左孩子</strong>；否则， <code>lchild</code>指向其<strong>直接前驱</strong>(即<strong>线索</strong>)；</li>\n<li>若结点有<strong>右子树</strong>，则<code>rchild</code>指向其<strong>右孩子</strong>；否则， <code>rchild</code>指向其<strong>直接后继</strong>(即<strong>线索</strong>) 。</li>\n</ol><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201117221216.png\" style=\"zoom:50%;\" /><p><code>LTag</code>  :若 <code>LTag=0</code>, <code>lchild</code>域指向<strong>左孩子</strong>；若 <code>LTag=1,</code> <code>lchild</code>域指向其<strong>前驱</strong>。<br><code>RTag</code>  :若 <code>RTag=0</code>, <code>rchild</code>域指向<strong>右孩子</strong>；若 <code>RTag=1</code>, <code>rchild</code>域指向其<strong>后继</strong>。 </p>\n<h2 id=\"先序线索二叉树\">先序线索二叉树<a href=\"#先序线索二叉树\" title=\"先序线索二叉树\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201119175212.png\" style=\"zoom:67%;\" /><h2 id=\"中序线索二叉树\">中序线索二叉树<a href=\"#中序线索二叉树\" title=\"中序线索二叉树\"></a></h2><h2 id=\"后序线索二叉树\">后序线索二叉树<a href=\"#后序线索二叉树\" title=\"后序线索二叉树\"></a></h2>","prev":{"title":"DIV+CSS布局","link":"posts/f02a39f0"},"next":{"title":"表格和表单","link":"posts/80afbc07"},"plink":"https://dxsummer.gitee.io/posts/ec2e91f9/","toc":[{"id":"逻辑结构","title":"逻辑结构","index":"1"},{"id":"树","title":"树","index":"2","children":[{"id":"基本术语","title":"基本术语","index":"2.1"}]},{"id":"二叉树","title":"二叉树","index":"3","children":[{"id":"特点","title":"特点","index":"3.1"},{"id":"性质🍑","title":"性质🍑","index":"3.2"},{"id":"特殊形态的二叉树","title":"特殊形态的二叉树","index":"3.3"},{"id":"顺序存储","title":"顺序存储","index":"3.4","children":[{"id":"问题","title":"问题","index":"3.4.1"}]},{"id":"链式存储","title":"链式存储","index":"3.5"}]},{"id":"遍历二叉树","title":"遍历二叉树","index":"4","children":[{"id":"先序遍历算法","title":"先序遍历算法","index":"4.1"},{"id":"中序遍历算法","title":"中序遍历算法","index":"4.2"},{"id":"后序遍历算法","title":"后序遍历算法","index":"4.3"},{"id":"计算二叉树结点总数","title":"计算二叉树结点总数","index":"4.4"},{"id":"计算二叉树叶子结点总数","title":"计算二叉树叶子结点总数","index":"4.5"},{"id":"计算二叉树深度","title":"计算二叉树深度","index":"4.6"}]},{"id":"结论","title":"结论","index":"5"},{"id":"线索化二叉树","title":"线索化二叉树","index":"6","children":[{"id":"先序线索二叉树","title":"先序线索二叉树","index":"6.1"},{"id":"中序线索二叉树","title":"中序线索二叉树","index":"6.2"},{"id":"后序线索二叉树","title":"后序线索二叉树","index":"6.3"}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/ec2e91f9/\" title=\"树和二叉树\">https://dxsummer.gitee.io/posts/ec2e91f9/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年11月7日","updated":"2020年11月19日"}}