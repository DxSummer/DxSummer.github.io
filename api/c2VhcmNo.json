[{"title":"Step7 函数","date":"2020-06-10T12:21:48.000Z","date_formatted":{"ll":"2020年6月10日","L":"2020/06/10","MM-DD":"06-10"},"updated":"2020-06-12T03:39:08.536Z","content":"本章介绍以下内容：\n关键字：return\n运算符：*（一元）、&amp;（一元）\n函数及其定义方式\n如何使用参数和返回值\n如何把指针变量用作函数参数\n函数类型\nANSI C原型\n递归\n如何组织程序？C的设计思想是，把函数用作构件块。我们已经用过C标准库的函数，如printf()、scanf()、getchar()、putchar()和 strlen()。现在要进一步学习如何创建自己的函数。前面章节中已大致介绍了相关过程，本章将巩固以前学过的知识并做进一步的拓展。\n复习函数首先，什么是函数？函数（function）是完成特定任务的独立程序代码单元。语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某些动作，如printf()把数据打印到屏幕上；一些函数找出一个值供程序使用，如strlen()把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。\n为什么要使用函数？首先，使用函数可以省去编写重复代码的苦差。如果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用putchar()一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。例如，假设要编写一个程序完成以下任务：\n读入一系列数字；\n分类这些数字；\n找出这些数字的平均值；\n打印一份柱状图。\n可以使用下面的程序：\n1234567891011#include　&lt;stdio.h&gt;#define　SIZE　50int main(void)&#123;    float list[SIZE];    readlist(list,SIZE);    sort(list,SIZE);    average(list,SIZE);    bargraph(list,SIZE);    returnb 0;&#125;当然，还要编写4个函数readlist()、sort()、average()和bargraph()的实现细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。\n许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响应的动作（输出）来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用printf()时，只需知道给该函数传入格式字符串或一些参数以及 printf()生成的输出，无需了解 printf()的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。\n如何了解函数？首先要知道如何正确地定义函数、如何调用函数和如何建立函数间的通信。我们从一个简单的程序示例开始，帮助读者理清这些内容，然后再详细讲解。\n创建并使用简单函数我们的第1个目标是创建一个在一行打印40个星号的函数，并在一个打印表头的程序中使用该函数。如程序清单9.1所示，该程序由main()和starbar()组成。\n程序清单9.1 lethead1.c程序\n1234567891011121314151617181920212223/* lethead1.c */#include　&lt;stdio.h&gt;#define NAME　\"GIGATHINK, INC.\"#define ADDRESS　\"101　Megabuck　Plaza\"#define PLACE　\"Megapolis,　CA　94904\"#define WIDTH　40void starbar(void);　/* 函数原型 */int main(void)&#123;    starbar();    printf(\"%s\\n\",NAME);    printf(\"%s\\n\",ADDRESS);    printf(\"%s\\n\",PLACE);    starbar();　　　/* 使用函数 */    return　0;&#125;void starbar(void)　/* 定义函数　 */&#123;    int　count;    for(count=1;count&lt;=WIDTH;count++)    putchar('*');    putchar('\\n');&#125;该程序的输出如下：\n12345****************************************GIGATHINK,　INC.101　Megabuck　PlazaMegapolis,　CA　94904****************************************分析程序该程序要注意以下几点。\n程序在3处使用了starbar标识符：函数原型（function prototype）告诉编译器函数starbar()的类型；函数调用（function call）表明在此处执行函数；函数定义（function definition）明确地指定了函数要做什么。\n函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。因此，在main()函数定义的前面出现了下面的ANSI C风格的函数原型：\n1void starbar(void);圆括号表明starbar是一个函数名。第1个void是函数类型，void类型表明函数没有返回值。第2个void（在圆括号中）表明该函数不带参数。分号表明这是在声明函数，不是定义函数。也就是说，这行声明了程序将使用一个名为starbar()、没有返回值、没有参数的函数，并告诉编译器在别处查找该函数的定义。对于不识别ANSI C风格原型的编译器，只需声明函数的类型，如下所示：\n1void starbar();注意，一些老版本的编译器甚至连void都识别不了。如果使用这种编译器，就要把没有返回值的函数声明为int类型。当然，最好还是换一个新的编译器。\n一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。对于starbar()函数而言，其签名是该函数没有返回值，没有参数。\n程序把 starbar()原型置于 main()的前面。当然，也可以放在 main()里面的声明变量处。放在哪个位置都可以。\n在main()中，执行到下面的语句时调用了starbar()函数：\n1starbar();这是调用void类型函数的一种形式。当计算机执行到starbar();语句时，会找到该函数的定义并执行其中的内容。执行完starbar()中的代码后，计算机返回主调函数（calling function）继续执行下一行（本例中，主调函数是main()），见图9.1（更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码）。\n\n程序中strarbar()和main()的定义形式相同。首先函数头包括函数类型、函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右花括号结束（见图9.2）。注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()，而不是调用函数或声明函数原型。\n\n程序把 starbar()和 main()放在一个文件中。当然，也可以把它们分别放在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数。如果把函数放在一个单独的文件中，要把#define 和#include 指令也放入该文件。我们稍后会讨论使用多个文件的情况。现在，先把所有的函数都放在一个文件中。main()的右花括号告诉编译器该函数结束的位置，后面的starbar()函数头告诉编译器starbar()是一个函数。\nstarbar()函数中的变量count是局部变量（local variable），意思是该变量只属于starbar()函数。可以在程序中的其他地方（包括main()中）使用count，这不会引起名称冲突，它们是同名的不同变量。\n如果把starbar()看作是一个黑盒，那么它的行为是打印一行星号。不用给该函数提供任何输入，因为调用它不需要其他信息。而且，它没有返回值，所以也不给 main()提供（或返回）任何信息。简而言之，starbar()不需要与主调函数通信。\n接下来介绍一个函数间需要通信的例子。\n函数参数在程序清单9.1的输出中，如果文字能居中，信头会更加美观。可以通过在打印文字之前打印一定数量的空格来实现，这和打印一定数量的星号（starbar()函数）类似，只不过现在要打印的是一定数量的空格。虽然这是两个任务，但是任务非常相似，与其分别为它们编写一个函数，不如写一个更通用的函数，可以在两种情况下使用。我们设计一个新的函数show_n_char()（显示一个字符n次）。唯一要改变的是使用内置的值来显示字符和重复的次数，show_n_char()将使用函数参数来传递这些值。\n我们来具体分析。假设可用的空间是40个字符宽。调用show_n_char(&#39;*&#39;, 40)应该正好打印一行40个星号，就像starbar()之前做的那样。第2行GIGATHINK, INT.的空格怎么处理？GIGATHINK, INT.是15个字符宽，所以第1个版本中，文字后面有25个空格。为了让文字居中，文字的左侧应该有12个空格，右侧有13个空格。因此，可以调用show_n_char(&#39;*&#39;, 12)。\nshow_n_char()与starbar()很相似，但是show_n_char()带有参数。从功能上看，前者不会添加换行符，而后者会，因为show_n_char()要把空格和文本打印成一行。程序清单9.2是修改后的版本。为强调参数的工作原理，程序使用了不同的参数形式。\n程序清单9.2 lethead2.c程序\n123456789101112131415161718192021222324252627282930313233/* lethead2.c */#include　&lt;stdio.h&gt;#include &lt;string.h&gt;　　　　　/* 为strlen()提供原型 */#define　NAME　\"GIGATHINK,　INC.\"#define　ADDRESS　\"101　Megabuck　Plaza\"#define　PLACE　\"Megapolis,　CA　94904\"#define　WIDTH　40#define　SPACE　'　'void show_n_char(char　ch,　int　num);int main(void)&#123;    int spaces;    show_n_char('*', WIDTH);　　　　　　　　/* 用符号常量作为参数 */    putchar('\\n');    show_n_char(SPACE, 12);　　　　　　　　 /* 用符号常量作为参数 */    printf(\"%s\\n\",　NAME);    spaces = (WIDTH - strlen(ADDRESS))/2; /* 计算要跳过多少个空格*/    show_n_char(SPACE, spaces);　　　　　　 /* 用一个变量作为参数*/    printf(\"%s\\n\",　ADDRESS);    show_n_char(SPACE,(WIDTH-strlen(PLACE))/2);    printf(\"%s\\n\", PLACE);　　　　　　　　　/* 用一个表达式作为参数　 */    show_n_char('*', WIDTH);    putchar('\\n');    return 0;&#125;/* show_n_char()函数的定义 */void show_n_char(char ch,int num)&#123;    int count;    for(count=1;count&lt;=num;count++)    putchar(ch);&#125;该函数的运行结果如下：\n12345**************************************\t\tGIGATHINK,　INC.\t  101　Megabuck　Plaza\t Megapolis,　CA　94904****************************************下面我们回顾一下如何编写一个带参数的函数，然后介绍这种函数的用法。\n定义带形式参数的函数函数定义从下面的ANSI C风格的函数头开始：\n1void show_n_char(char ch,int num)该行告知编译器show_n_char()使用两个参数ch和num，ch是char类型，num是int类型。这两个变量被称为形式参数（formal argument，但是最近的标准推荐使用formal parameter），简称形参。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。这意味着在其他函数中使用同名变量不会引起名称冲突。每次调用函数，就会给这些变量赋值。\n注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：\n12void dibs(int x, y, z)　　　　 /* 无效的函数头 */void dubs(int x, int y, int z) /* 有效的函数头 */ANSI C也接受ANSI C之前的形式，但是将其视为废弃不用的形式：\n123void show_n_char(ch,num)char ch;int num;这里，圆括号中只有参数名列表，而参数的类型在后面声明。注意，普通的局部变量在左花括号之后声明，而上面的变量在函数左花括号之前声明。如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所示：\n12void dibs(x,y,z)int x,y,z;　　　/* 有效 */当前的标准正逐渐淘汰 ANSI 之前的形式。读者应对此有所了解，以便能看懂以前编写的程序，但是自己编写程序时应使用现在的标准形式（C99和C11标准继续警告这些过时的用法即将被淘汰）。\n虽然show_n_char()接受来自main()的值，但是它没有返回值。因此，show_n_char()的类型是void。\n下面，我们来学习如何使用函数。\n声明带形式参数函数的原型在使用函数之前，要用ANSI C形式声明函数原型：\n1void show_n_char(char ch, int num);当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：\n1void show_n_char(char, int);在原型中使用变量名并没有实际创建变量，char仅代表了一个char类型的变量，以此类推。再次提醒读者注意，ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表：\n1void show_n_char();这种形式最终会从标准中剔除。即使没有被剔除，现在函数原型的设计也更有优势（稍后会介绍）。了解这种形式的写法是为了以后读得懂以前写的代码。\n调用带实际参数的函数在函数调用中，实际参数（actual argument，简称实参）提供了ch和num的值。考虑程序清单9.2中第1次调用show_n_char()：\n1show_n_char(SPACE,12);实际参数是空格字符和12。这两个值被赋给show_n_char()中相应的形式参数：变量ch和num。简而言之，形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。如上例所示，实际参数可以是常量、变量，或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参数。以程序清单 9.2 中最后一次调用show_n_char()为例：\n1show_n_char(SPACE,(WIDTH - strlen(PLACE))/2);构成该函数第2个实际参数的是一个很长的表达式，对该表达式求值为10。然后，10被赋给变量num。被调函数不知道也不关心传入的数值是来自常量、变量还是一般表达式。再次强调，实际参数是具体的值，该值要被赋给作为形式参数的变量（见图 9.3）。因为被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调函数中的原始数据。\n注意 实际参数和形式参数\n\n实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化为实际参数的求值结果。程序清单 9.2 中，&#39;*&#39;和WIDTH都是第1次调用show_n_char()时的实际参数，而SPACE和11是第2次调用show_n_char()时的实际参数。在函数定义中，ch和num都是该函数的形式参数。\n黑盒视角从黑盒的视角看 show_n_char()，待显示的字符和显示的次数是输入。执行后的结果是打印指定数量的字符。输入以参数的形式被传递给函数。这些信息清楚地表明了如何在 main()中使用该函数。而且，这也可以作为编写该函数的设计说明。\n黑盒方法的核心部分是：ch、num和count都是show_n_char()私有的局部变量。如果在main()中使用同名变量，那么它们相互独立，互不影响。也就是说，如果main()有一个count变量，那么改变它的值不会改变show_n_char()中的count，反之亦然。黑盒里发生了什么对主调函数是不可见的。\n使用return从函数中返回值前面介绍了如何把信息从主调函数传递给被调函数。反过来，函数的返回值可以把信息从被调函数传回主调函数。为进一步说明，我们将创建一个返回两个参数中较小值的函数。由于函数被设计用来处理int类型的值，所以被命名为imin()。另外，还要创建一个简单的main()，用于检查imin()是否正常工作。这种被设计用于测试函数的程序有时被称为驱动程序（driver），该驱动程序调用一个函数。如果函数成功通过了测试，就可以安装在一个更重要的程序中使用。程序清单9.3演示了这个驱动程序和返回最小值的函数。\n程序清单9.3 lesser.c程序\n1234567891011121314151617181920212223242526/* lesser.c -- 找出两个整数中较小的一个 */#include　&lt;stdio.h&gt;int imin(int,int);int main(void)&#123;    int evil1,evil2;    printf(\"Enter　a　pair　of　integers　(q　to　quit):\\n\");    while(scanf(\"%d　%d\",&amp;evil1,&amp;evil2)　==　2)    &#123;        printf(\"The　lesser　of　%d　and　%d　is　%d.\\n\",        evil1,evil2,imin(evil1,evil2));        printf(\"Enter　a　pair　of　integers　(q　to　quit):\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;int imin(int　n,　int　m)&#123;    int min;    if(n　&lt;　m)    \tmin　=　n;    else    \tmin　=　m;    return min;&#125;回忆一下，scanf()返回成功读数据的个数，所以如果输入不是两个整数会导致循环终止。下面是一个运行示例：\n123456789Enter　a　pair　of　integers　(q　to　quit):509　333The　lesser　of　509　and　333　is　333.Enter　a　pair　of　integers　(q　to　quit):-9393　6The　lesser　of　-9393　and　6　is　-9393.Enter　a　pair　of　integers　(q　to　quit):qBye.关键字return后面的表达式的值就是函数的返回值。在该例中，该函数返回的值就是变量min的值。因为min是int类型的变量，所以imin()函数的类型也是int。\n变量min属于imin()函数私有，但是return语句把min的值传回了主调函数。下面这条语句的作用是把min的值赋给lesser:\n1lesser = imin(n,m);是否能像写成下面这样：\n12imin(n,m);lesser = min;不能。因为主调函数甚至不知道min的存在。记住，imin()中的变量是imin()的局部变量。函数调用imin(evil1, evil2)只是把两个变量的值拷贝了一份。\n返回值不仅可以赋给变量，也可以被用作表达式的一部分。例如，可以这样：\n12answer = 2 * imin(z, zstar) + 25;printf(\"%d\\n\", imin(-32 + answer, LIMIT));返回值不一定是变量的值，也可以是任意表达式的值。例如，可以用以下的代码简化程序示例：\n12345/* 返回最小值的函数，第2个版本 */imin(int n,int m)&#123;return (n&lt;m)?n:m;&#125;条件表达式的值是n和m中的较小者，该值要被返回给主调函数。虽然这里不要求用圆括号把返回值括起来，但是如果想让程序条理更清楚或统一风格，可以把返回值放在圆括号内。\n如果函数返回值的类型与函数声明的类型不匹配会怎样？\n12345int what_if(int n)&#123;    double z=100.0/(double)n;    return z; // 会发生什么？&#125;实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：\n1result=what_if(64);虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int类型的值1。\n使用 return 语句的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。因此，可以这样编写imin()：\n123456789/*返回最小值的函数，第3个版本*/imin(int n,int m)&#123;    if(n　&lt;　m)    \treturn　n;    else    \treturn　m;&#125;许多C程序员都认为只在函数末尾使用一次return语句比较好，因为这样做更方便浏览程序的人理解函数的控制流。但是，在函数中使用多个return语句也没有错。无论如何，对用户而言，这3个版本的函数用起来都一样，因为所有的输入和输出都完全相同，不同的是函数内部的实现细节。下面的版本也没问题：\n12345678910/*返回最小值的函数，第4个版本*/imin(int　n,int　m)&#123;    if(n&lt;m)    \treturn　n;    else    \treturn　m;    printf(\"Professor　Fleppard　is　like　totally　a　fopdoodle.\\n\");&#125;return语句导致printf()语句永远不会被执行。如果Fleppard教授在自己的程序中使用这个版本的函数，可能永远不知道编写这个函数的学生对他的看法。\n另外，还可以这样使用return：\n1return;这条语句会导致终止函数，并把控制返回给主调函数。因为 return 后面没有任何表达式，所以没有返回值，只有在void函数中才会用到这种形式。\n函数类型声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为void类型。如果没有声明函数的类型，旧版本的C编译器会假定函数的类型是int。这一惯例源于C的早期，那时的函数绝大多数都是int类型。然而，C99标准不再支持int类型函数的这种假定设置。\n类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。例如，下面的函数头定义了一个带两个int类型参数的函数，但是其返回值是double类型。\n1double klink(int a, int b)要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第1次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在C库或其他文件中。因此，通常的做法是提前声明函数，把函数的信息告知编译器。例如，程序清单 9.3 中的main()函数包含以下几行代码：\n12345#include　&lt;stdio.h&gt;int imin(int,int);int main(void)&#123;    int evil1,evil2,lesser;第2行代码说明imin是一个函数名，有两个int类型的形参，且返回int类型的值。现在，编译器在程序中调用imin()函数时就知道应该如何处理。\n在程序清单9.3中，我们把函数的前置声明放在主调函数外面。当然，也可以放在主调函数里面。例如，重写lesser.c（程序清单9.3）的开头部分：\n12345#include　&lt;stdio.h&gt;int main(void)&#123;    int imin(int, int); /* 声明imin()函数的原型*/    int evil1,evil2,lesser;注意在这两种情况中，函数原型都声明在使用函数之前。\nANSI C标准库中，函数被分成多个系列，每一系列都有各自的头文件。这些头文件中除了其他内容，还包含了本系列所有函数的声明。例如，stdio.h 头文件包含了标准 I/O 库函数（如，printf()和scanf()）的声明。math.h头文件包含了各种数学函数的声明。例如，下面的声明：\n1double sqrt(double);告知编译器sqrt()函数有一个double类型的形参，而且返回double类型的值。不要混淆函数的声明和定义。函数声明告知编译器函数的类型，而函数定义则提供实际的代码。在程序中包含 math.h 头文件告知编译器：sqrt()返回double类型，但是sqrt()函数的代码在另一个库函数的文件中。\nANSI C函数原型在ANSI C标准之前，声明函数的方案有缺陷，因为只需要声明函数的类型，不用声明任何参数。下面我们看一下使用旧式的函数声明会导致什么问题。\n下面是ANSI之前的函数声明，告知编译器imin()返回int类型的值：\n1int imin();然而，以上函数声明并未给出imin()函数的参数个数和类型。因此，如果调用imin()时使用的参数个数不对或类型不匹配，编译器根本不会察觉出来。\n问题所在我们看看与imax()函数相关的一些示例，该函数与imin()函数关系密切。程序清单9.4演示了一个程序，用过去声明函数的方式声明了imax()函数，然后错误地使用该函数。\n12345678910111213141516程序清单9.4 misuse.c程序/* misuse.c -- 错误地使用函数 */#include　&lt;stdio.h&gt;int imax();　　 /* 旧式函数声明 */int　main(void)&#123;    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",3,　5,　imax(3));    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",3,　5,　imax(3.0,　5.0));    return 0;&#125;int imax(n,m)int n,m;&#123;\treturn (n&gt;m?n:m);&#125;第1次调用printf()时省略了imax()的一个参数，第2次调用printf()时用两个浮点参数而不是整数参数。尽管有些问题，但程序可以编译和运行。\n下面是使用Xcode 4.6运行的输出示例：\n12The maximum　of　3　and　5　is　1606416656.The　maximum　of　3　and　5　is　3886.使用gcc运行该程序，输出的值是1359379472和1359377160。这两个编译器都运行正常，之所以输出错误的结果，是因为它们运行的程序没有使用函数原型。\n到底是哪里出了问题？由于不同系统的内部机制不同，所以出现问题的具体情况也不同。下面介绍的是使用P C和VA X的情况。主调函数把它的参数储存在被称为栈（stack）的临时存储区，被调函数从栈中读取这些参数。对于该例，这两个过程并未相互协调。主调函数根据函数调用中的实际参数决定传递的类型，而被调函数根据它的形式参数读取值。因此，函数调用imax(3)把一个整数放在栈中。当imax()函数开始执行时，它从栈中读取两个整数。而实际上栈中只存放了一个待读取的整数，所以读取的第 2 个值是当时恰好在栈中的其他值。\n第2次使用imax()函数时，它传递的是float类型的值。这次把两个double类型的值放在栈中（回忆一下，当float类型被作为参数传递时会被升级为double类型）。在我们的系统中，两个double类型的值就是两个64位的值，所以128位的数据被放在栈中。当imax()从栈中读取两个int类型的值时，它从栈中读取前64位。在我们的系统中，每个int类型的变量占用32位。这些数据对应两个整数，其中较大的是3886。\nANSI的解决方案针对参数不匹配的问题，ANSI C标准要求在函数声明时还要声明变量的类型，即使用函数原型（function prototype）来声明函数的返回类型、参数的数量和每个参数的类型。未标明 imax()函数有两个 int 类型的参数，可以使用下面两种函数原型来声明：\n12int imax(int, int);int imax(int a, int b);第1种形式使用以逗号分隔的类型列表，第2种形式在类型后面添加了变量名。注意，这里的变量名是假名，不必与函数定义的形式参数名一致。\n有了这些信息，编译器可以检查函数调用是否与函数原型匹配。参数的数量是否正确？参数的类型是否匹配？以 imax()为例，如果两个参数都是数字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。例如，imax(3.0, 5.0)会被转换成imax(3, 5)。我们用函数原型替换程序清单9.4中的函数声明，如程序清单9.5所示。\n程序清单9.5 proto.c程序\n12345678910111213141516/* proto.c -- 使用函数原型 */#include　&lt;stdio.h&gt;int imax(int, int);　　　 /* 函数原型 */int main(void)&#123;    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",    3,　5,　imax(3));    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",    3,　5,　imax(3.0,　5.0));    return 0;&#125;int imax(int　n,　int　m)&#123;\treturn (n　&gt;　m　?　n　:　m);&#125;编译程序清单9.5时，我们的编译器给出调用的imax()函数参数太少的错误消息。\n如果是类型不匹配会怎样？为探索这个问题，我们用imax(3, 5)替换imax(3)，然后再次编译该程序。这次编译器没有给出任何错误信息，程序的输出如下：\n12The maximum of 3 and 5 is 5.The maximum of 3 and 5 is 5.如上文所述，第2次调用中的3.0和5.0被转换成3和5，以便函数能正确地处理输入。\n虽然没有错误消息，但是我们的编译器还是给出了警告：double转换成int可能会导致丢失数据。例如，下面的函数调用：\n1imax(3.9, 5.4)相当于:\n1imax(3, 5)错误和警告的区别是：错误导致无法编译，而警告仍然允许编译。一些编译器在进行类似的类型转换时不会通知用户，因为C标准中对此未作要求。不过，许多编译器都允许用户选择警告级别来控制编译器在描述警告时的详细程度。\n无参数和未指定参数假设有下面的函数原型：\n1void print_name();一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数。为了表明函数确实没有参数，应该在圆括号中使用void关键字：\n1void print_name(void);支持ANSI C的编译器解释为print_name()不接受任何参数。然后在调用该函数时，编译器会检查以确保没有使用参数。\n一些函数接受（如，printf()和scanf()）许多参数。例如对于printf()，第1个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C允许使用部分原型。例如，对于printf()可以使用下面的原型：\n1int printf(const char *, ...);这种原型表明，第1个参数是一个字符串（第11章中将详细介绍），可能还有其他未指定的参数。\nC库通过stdarg.h头文件提供了一个定义这类（形参数量不固定的）函数的标准方法。第16章中详细介绍相关内容。\n函数原型的优点函数原型是C语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或疏漏。如果编译器没有发现这些问题，就很难觉察出来。是否必须使用函数原型？不一定。你也可以使用旧式的函数声明（即不用声明任何形参），但是这样做的弊大于利。\n有一种方法可以省略函数原型却保留函数原型的优点。首先要明白，之所以使用函数原型，是为了让编译器在第1次执行到该函数之前就知道如何使用它。因此，把整个函数定义放在第1次调用该函数之前，也有相同的效果。此时，函数定义也相当于函数原型。对于较小的函数，这种用法很普遍：\n// 下面这行代码既是函数定义，也是函数原型\n12345678int　imax(int　a,　int　b)　&#123;　return　a　&gt;　b　?　a　:　b;　&#125;int　main()&#123;int　x,　z;...z　=　imax(x,　50);...&#125;递归C允许函数调用它自己，这种调用过程称为递归（recursion）。递归有时难以捉摸，有时却很方便实用。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。\n可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。\n演示递归我们通过一个程序示例，来学习什么是递归。程序清单 9.6 中的 main()函数调用 up_and_down()函数，这次调用称为“第1级递归”。然后up_and_down()调用自己，这次调用称为“第2级递归”。接着第2级递归调用第3级递归，以此类推。该程序示例共有4级递归。为了进一步深入研究递归时发生了什么，程序不仅显示了变量n的值，还显示了储存n的内存地址&amp;n（。本章稍后会详细讨论&amp;运算符，printf()函数使用%p转换说明打印地址，如果你的系统不支持这种格式，请使用%u或%lu代替%p）。\n程序清单9.6 recur.c程序\n12345678910111213141516/* recur.c -- 递归演示 */#include　&lt;stdio.h&gt;void up_and_down(int);int main(void)&#123;    up_and_down(1);    return 0;&#125;void up_and_down(int n)&#123;    printf(\"Level　%d:　n　location　%p\\n\",　n,　&amp;n);　//　#1    if(n　&lt;　4)    up_and_down(n　+　1);    printf(\"LEVEL　%d:　n　location　%p\\n\",　n,　&amp;n);　//　#2&#125;下面是在我们系统中的输出：\n12345678Level　1:　n　location　0x0012ff48Level　2:　n　location　0x0012ff3cLevel　3:　n　location　0x0012ff30Level　4:　n　location　0x0012ff24LEVEL　4:　n　location　0x0012ff24LEVEL　3:　n　location　0x0012ff30LEVEL　2:　n　location　0x0012ff3cLEVEL　1:　n　location　0x0012ff48我们来仔细分析程序中的递归是如何工作的。首先，main()调用了带参数1的up_and_down()函数，执行结果是up_and_down()中的形式参数n的值是1，所以打印语句#1打印Level 1。然后，由于n小于4，up_and_down()（第1级）调用实际参数为n + 1（或2）的up_and_down()（第2级）。于是第2级调用中的n的值是2，打印语句#1打印Level 2。与此类似，下面两次调用打印的分别是Level 3和Level 4。\n当执行到第4级时，n的值是4，所以if测试条件为假。up_and_down()函数不再调用自己。第4级调用接着执行打印语句#2，即打印LEVEL 4，因为n的值是4。此时，第4级调用结束，控制被传回它的主调函数（即第3级调用）。在第3级调用中，执行的最后一条语句是调用if语句中的第4级调用。被调函数（第4级调用）把控制返回在这个位置，因此，第3级调用继续执行后面的代码，打印语句#2打印LEVEL 3。然后第3级调用结束，控制被传回第2级调用，接着打印LEVEL 2，以此类推。\n注意，每级递归的变量 n 都属于本级递归私有。这从程序输出的地址值可以看出（当然，不同的系统表示的地址格式不同，这里关键要注意，Level 1和LEVEL 1的地址相同，Level 2和LEVEL 2的地址相同，等等）。\n如果觉得不好理解，可以假设有一条函数调用链——fun1()调用 fun2()、fun2()调用 fun3()、fun3()调用fun4()。当 fun4()结束时，控制传回fun3()；当fun3()结束时，控制传回 fun2()；当fun2()结束时，控制传回fun1()。递归的情况与此类似，只不过fun1()、fun2()、fun3()和fun4()都是相同的函数。\n递归的基本原理初次接触递归会觉得较难理解。为了帮助读者理解递归过程，下面以程序清单9.6为例讲解几个要点。\n第1，每级函数调用都有自己的变量。也就是说，第1级的n和第2级的n不同，所以程序创建了4个单独的变量，每个变量名都是n，但是它们的值各不相同。当程序最终返回 up_and_down()的第1 级调用时，最初的n仍然是它的初值1（见图9.4）。\n\n第2，每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级up_and_down()返回上一级的up_and_down()，不能跳级回到main()中的第1级调用。\n第3，递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，程序清单9.6中的打印语句#1位于递归调用之前，它按照递归的顺序：第1级、第2级、第3级和第4级，被执行了4次。\n第4，递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，打印语句#2位于递归调用之后，其执行的顺序是第4级、第3级、第2级、第1级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。\n第5，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。\n最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。例如，程序清单9.6中的up_and_down(n)调用up_and_down(n+1)。最终，实际参数等于4时，if的测试条件(n &lt; 4)为假。\n尾递归最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。\n下面要介绍的程序示例中，分别用循环和尾递归计算阶乘。一个正整数的阶乘（factorial）是从1到该整数的所有整数的乘积。例如，3的阶乘（写作3！）是1×2×3。另外，0！等于1，负数没有阶乘。程序清单9.7中，第1个函数使用for循环计算阶乘，第2个函数使用递归计算阶乘。\n程序清单9.7 factor.c程序\n1234567891011121314151617181920212223242526272829303132333435363738394041424344// factor.c -- 使用循环和递归计算阶乘#include　&lt;stdio.h&gt;long fact(int n);long rfact(int n);int main(void)&#123;    int num;    printf(\"This　program　calculates　factorials.\\n\");    printf(\"Enter　a　value　in　the　range　0-12　(q　to　quit):\\n\");    while　(scanf(\"%d\",　&amp;num)　==　1)    &#123;        if　(num　&lt;　0)        \tprintf(\"No　negative　numbers,　please.\\n\");        else　if　(num　&gt;　12)        \tprintf(\"Keep　input　under　13.\\n\");        else        &#123;            printf(\"loop:　%d　factorial　=　%ld\\n\",            num,　fact(num));            printf(\"recursion:　%d　factorial　=　%ld\\n\",            num,　rfact(num));        &#125;        printf(\"Enter　a　value　in　the　range　0-12　(q　to　quit):\\n\");        &#125;    printf(\"Bye.\\n\");    return　0;&#125;long fact(int n)　　 // 使用循环的函数&#123;    long ans;    for(ans=1;n&gt;1;n--)    \tans*=n;    return　ans;&#125;long rfact(int n)　　// 使用递归的函数&#123;    long　ans;    if　(n　&gt;　0)    \tans = n * rfact(n - 1);    else    \tans　=　1;    return ans;&#125;测试驱动程序把输入限制在0~12。因为12!已快接近5亿，而13!比62亿还大，已超过我们系统中long类型能表示的范围。要计算超过12的阶乘，必须使用能表示更大范围的类型，如double或long long。\n下面是该程序的运行示例：\n123456789101112This　program　calculates　factorials.Enter　a　value　in　the　range　0-12　(q　to　quit):5loop:　5　factorial　=　120recursion:　5　factorial　=　120Enter　a　value　in　the　range　0-12　(q　to　quit):10loop:　10　factorial　=　3628800recursion:　10　factorial　=　3628800Enter　a　value　in　the　range　0-12　(q　to　quit):qBye.使用循环的函数把ans初始化为1，然后把ans与从n~2的所有递减整数相乘。根据阶乘的公式，还应该乘以1，但是这并不会改变结果。\n现在考虑使用递归的函数。该函数的关键是n! = n×(n-1)!。可以这样做是因为(n-1)!是n-1~1的所有正整数的乘积。因此，n乘以n-1就得到n的阶乘。阶乘的这一特性很适合使用递归。如果调用函数rfact()，rfact(n)是 n*rfact(n-1)。因此，通过调用 rfact(n-1)来计算rfact(n)，如程序清单9.7中所示。当然，必须要在满足某条件时结束递归，可以在n等于0时把返回值设为1。\n程序清单9.7中使用递归的输出和使用循环的输出相同。注意，虽然rfact()的递归调用不是函数的最后一行，但是当n&gt;0时，它是该函数执行的最后一条语句，因此它也是尾递归。\n既然用递归和循环来计算都没问题，那么到底应该使用哪一个？一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢。那么，演示这个程序示例的目的是什么？因为尾递归是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环代替递归，因此读者还是要好好理解递归。\n递归和倒序计算递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）。我们要解决的问题是：编写一个函数，打印一个整数的二进制数。二进制表示法根据 2 的幂来表示数字。例如，十进制数 234 实际上是2×102+3×101+4×100，所以二进制数101实际上是1×22+0×21+1×20。二进制数由0和1表示。\n我们要设计一个以二进制形式表示整数的方法或算法（algorithm）。例如，如何用二进制表示十进制数5？在二进制中，奇数的末尾一定是1，偶数的末尾一定是0，所以通过5 % 2即可确定5的二进制数的最后一位是1还是0。一般而言，对于数字n，其二进制的最后一位是n % 2。因此，计算的第一位数字实际上是待输出二进制数的最后一位。这一规律提示我们，在递归函数的递归调用之前计算n % 2，在递归调用之后打印计算结果。这样，计算的第1个值正好是最后一个打印的值。\n要获得下一位数字，必须把原数除以 2。这种计算方法相当于在十进制下把小数点左移一位，如果计算结果是偶数，那么二进制的下一位数就是0；如果是奇数，就是1。例如，5/2得2（整数除法），2是偶数（2%2 得 0），所以下一位二进制数是 0。到目前为止，我们已经获得 01。继续重复这个过程。2/2得1，1%2得1，所以下一位二进制数是1。因此，我们得到5的等价二进制数是101。那么，程序应该何时停止计算？当与2相除的结果小于2时停止计算，因为只要结果大于或等于2，就说明还有二进制位。每次除以 2 就相当于去掉一位二进制，直到计算出最后一位为止（如果不好理解，可以拿十进制数来做类比：628%10得8，因此8就是该数最后一位；而628/10得62，而62%10得2，所以该数的下一位是2，以此类推）。程序清单9.8演示了上述算法。\n程序清单9.8 binary.c程序\n123456789101112131415161718192021222324252627/* binary.c -- 以二进制形式打印制整数 */#include　&lt;stdio.h&gt;void to_binary(unsigned long n);int main(void)&#123;    unsigned long number;    printf(\"Enter　an　integer　(q　to　quit):\\n\");    while(scanf(\"%lu\",&amp;number)　==　1)    &#123;        printf(\"Binary　equivalent:　\");        to_binary(number);        putchar('\\n');        printf(\"Enter　an　integer　(q　to　quit):\\n\");    &#125;    printf(\"Done.\\n\");    return　0;&#125;void to_binary(unsigned long n)　/* 递归函数 */&#123;    int r;    r=n%2;    if(n&gt;=2)    \tto_binary(n/2);    putchar(r==0?'0':'1');    return;&#125;在该程序中，如果r的值是0，to_binary()函数就显示字符’0’；如果r的值是1，to_binary()函数则显示字符’1’。条件表达式r == 0 ? &#39;0&#39; : &#39;1&#39;用于把数值转换成字符。\n下面是该程序的运行示例：\n123456789101112Enter　an　integer　(q　to　quit):9Binary　equivalent:　1001Enter　an　integer　(q　to　quit):255Binary　equivalent:　11111111Enter　an　integer　(q　to　quit):1024Binary　equivalent:　10000000000Enter　an　integer　(q　to　quit):qdone.不用递归，是否能实现这种用二进制形式表示整数的算法？当然可以。但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存在别处（例如，数组）。第 15 章中会介绍一个不用递归实现该算法的例子。\n递归的优缺点递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。我们用一个例子来说明递归的优缺点。\n斐波那契数列的定义如下：第1 个和第2 个数字都是1，而后续的每个数字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、8、13。斐波那契数列在数学界深受喜爱，甚至有专门研究它的刊物。不过，这不在本书的讨论范围之内。下面，我们要创建一个函数，接受正整数 n，返回相应的斐波那契数值。\n首先，来看递归。递归提供一个简单的定义。如果把函数命名为Fibonacci()，那么如果n是1或2， Fibonacci(n)应返回1；对于其他数值，则应返回Fibonacci(n-1)+Fibonacci(n-2)：\n1234567unsigned　long　Fibonacci(unsigned　n)&#123;    if　(n　&gt;　2)    return　Fibonacci(n-1)　+　Fibonacci(n-2);    else    return　1;&#125;这个递归函数只是重述了数学定义的递归。该函数使用了双递归（double recursion），即函数每一级递归都要调用本身两次。这暴露了一个问题。\n为了说明这个问题，假设调用 Fibonacci(40)。这是第1 级递归调用，将创建一个变量 n。然后在该函数中要调用Fibonacci()两次，在第2级递归中要分别创建两个变量n。这两次调用中的每次调用又会进行两次调用，因而在第3级递归中要创建4个名为n的变量。此时总共创建了7个变量。由于每级递归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！在第 5 章中介绍过一个计算小麦粒数的例子，按指数增长很快就会产生非常大的值。在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃。\n虽然这是个极端的例子，但是该例说明：在程序中使用递归要特别注意，尤其是效率优先的程序。\n所有的C函数皆平等\n程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。这点与Pascal和Modula-2中的过程不同，虽然过程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调用。\nmain()函数是否与其他函数不同？是的，main()的确有点特殊。当 main()与程序中的其他函数放在一起时，最开始执行的是main()函数中的第1条语句，但是这也是局限之处。main()也可以被自己或其他函数递归调用——尽管很少这样做。\n编译多源代码文件的程序使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明。\nUNIX假定在UNIX系统中安装了UNIX C编译器cc（最初的cc已经停用，但是许多UNIX系统都给cc命令起了一个别名用作其他编译器命令，典型的是gcc或clang）。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成一个名为a.out的可执行文件：\n1cc file1.c file2.c另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：\n1cc file1.c file2.oUNIX系统的make命令可自动管理多文件程序，但是这超出了本书的讨论范围。\n注意，OS X的Terminal工具可以打开UNIX命令行环境，但是必须先下载命令行编译器（GCC和Clang）。\nLinux假定Linux系统安装了GNU C编译器GCC。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成名为a.out的可执行文件：\n1gcc file1.c file2.c另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：\n1gcc file1.c file2.oDOS命令行编译器绝大多数DOS命令行编译器的工作原理和UNIX的cc命令类似，只不过使用不同的名称而已。其中一个区别是，对象文件的扩展名是.obj，而不是.o。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件。\nWindows和苹果的IDE编译器Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目的。项目（project）描述的是特定程序使用的资源。资源包括源代码文件。这种IDE中的编译器要创建项目来运行单文件程序。对于多文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文件都在项目列表中列出。许多IDE都不用在项目列表中列出头文件（即扩展名为.h的文件），因为项目只管理使用的源代码文件，源代码文件中的#include指令管理该文件中使用的头文件。但是，Xcode要在项目中添加头文件。\n使用头文件如果把main()放在第1个文件中，把函数定义放在第2个文件中，那么第1个文件仍然要使用函数原型。把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C 标准库就是这样做的，例如，把I/O函数原型放在stdio.h中，把数学函数原型放在math.h中。你也可以这样用自定义的函数文件。\n另外，程序中经常用C预处理器定义符号常量。这种定义只储存了那些包含#define指令的文件。如果把程序的一个函数放进一个独立的文件中，你也可以使用#define指令访问每个文件。最直接的方法是在每个文件中再次输入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果修改了#define 定义的值，就必须在每个文件中修改。更好的做法是，把#define 指令放进头文件，然后在每个源文件中使用#include指令包含该文件即可。\n总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。我们考虑一个例子：假设要管理 4 家酒店的客房服务，每家酒店的房价不同，但是每家酒店所有房间的房价相同。对于预订住宿多天的客户，第2天的房费是第1天的95%，第3天是第2天的95%，以此类推（暂不考虑这种策略的经济效益）。设计一个程序让用户指定酒店和入住天数，然后计算并显示总费用。同时，程序要实现一份菜单，允许用户反复输入数据，除非用户选择退出。\n程序清单9.9、程序清单9.10和程序清单9.11演示了如何编写这样的程序。第1个程序清单包含main()函数，提供整个程序的组织结构。第 2 个程序清单包含支持的函数，我们假设这些函数在独立的文件中。最后，程序清单9.11列出了一个头文件，包含了该程序所有源文件中使用的自定义符号常量和函数原型。前面介绍过，在UNIX和DOS环境中，#include &quot;hotels.h&quot;指令中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）。如果使用IDE，需要知道如何把头文件合并成一个项目。\n程序清单9.9 usehotel.c控制模块\n1234567891011121314151617181920212223242526272829303132/* usehotel.c -- 房间费率程序 *//* 与程序清单9.10一起编译　　 */#include　&lt;stdio.h&gt;#include \"hotel.h\" /* 定义符号常量，声明函数 */int main(void)&#123;    int nights;    double hotel_rate;    int code;    while((code　=　menu())　!=　QUIT)    &#123;        switch(code)        &#123;            case　1:　 hotel_rate　=　HOTEL1;            break;            case　2:　 hotel_rate　=　HOTEL2;            break;            case　3:　 hotel_rate　=　HOTEL3;            break;            case　4:　 hotel_rate　=　HOTEL4;            break;            default: hotel_rate　=　0.0;            printf(\"Oops!\\n\");            break;        &#125;        nights　=　getnights();        showprice(hotel_rate,　nights);    &#125;    printf(\"Thank　you　and　goodbye.\\n\");    return 0;&#125;程序清单9.10 hotel.c函数支持模块\n123456789101112131415161718192021222324252627282930313233343536373839404142/* hotel.c -- 酒店管理函数 */#include　&lt;stdio.h&gt;#include　\"hotel.h\"int menu(void)&#123;    int code,status;    printf(\"\\n%s%s\\n\",　STARS,　STARS);    printf(\"Enter　the　number　of　the　desired　hotel:\\n\");    printf(\"1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic\\n\");    printf(\"3)　Chertworthy　Plaza　　　　　4)　The　Stockton\\n\");    printf(\"5)　quit\\n\");    printf(\"%s%s\\n\",　STARS,　STARS);    while((status　=　scanf(\"%d\",&amp;code))　!=　1　||    (code　&lt;　1　||　code　&gt;　5))    &#123;        if　(status　!=　1)            scanf(\"%*s\");　// 处理非整数输入        printf(\"Enter　an　integer　from　1　to　5,　please.\\n\");    &#125;    return code;&#125;int getnights(void)&#123;    int nights;    printf(\"How　many　nights　are　needed?　\");    while(scanf(\"%d\",　&amp;nights)　!=　1)    &#123;        scanf(\"%*s\");　　　// 处理非整数输入        printf(\"Please　enter　an　integer,　such　as　2.\\n\");    &#125;    return　nights;&#125;void showprice(double rate,int nights)&#123;    int　n;    double　total　=　0.0;    double　factor　=　1.0;    for (n = 1; n &lt;= nights; n++, factor *= DISCOUNT)    \ttotal += rate * factor;    printf(\"The　total　cost　will　be　$%0.2f.\\n\",　total);&#125;程序清单9.11 hotel.h头文件\n12345678910111213141516/* hotel.h -- 符号常量和 hotel.c 中所有函数的原型 */#define　QUIT　　　　　5#define　HOTEL1　　180.00#define　HOTEL2　　225.00#define　HOTEL3　　255.00#define　HOTEL4　　355.00#define　DISCOUNT　 0.95#define STARS \"**********************************\"// 显示选择列表int menu(void);// 返回预订天数int getnights(void);// 根据费率、入住天数计算费用// 并显示结果void showprice(double rate,int nights);下面是这个多文件程序的运行示例：\n1234567891011121314151617181920212223242526******************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************3How　many　nights　are　needed?　1The　total　cost　will　be　$255.00.********************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************4How　many　nights　are　needed?　3The　total　cost　will　be　$1012.64.********************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************5Thank　you　and　goodbye.顺带一提，该程序中有几处编写得很巧妙。尤其是，menu()和getnights()函数通过测试scanf()的返回值来跳过非数值数据，而且调用 scanf(&quot;%*s&quot;)跳至下一个空白字符。注意，menu()函数中是如何检查非数值输入和超出范围的数据：\n1while((status=scanf(\"%d\",&amp;code))!= 1||(code&lt;1||code&gt;5))以上代码段利用了C语言的两个规则：从左往右对逻辑表达式求值；一旦求值结果为假，立即停止求值。在该例中，只有在scanf()成功读入一个整数值后，才会检查code的值。\n用不同的函数处理不同的任务时应检查数据的有效性。当然，首次编写menu()或getnights()函数时可以暂不添加这一功能，只写一个简单的scanf()即可。待基本版本运行正常后，再逐步改善各模块。\n查找地址：&amp;运算符指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的scanf()函数中就使用地址作为参数。概括地说，如果主调函数不使用return返回的值，则必须通过地址才能修改主调函数中的值。接下来，我们将介绍带地址参数的函数。首先介绍一元&amp;运算符的用法。\n一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。可以把地址看作是变量在内存中的位置。假设有下面的语句：\n1pooh = 24;假设pooh的存储地址是0B76（PC地址通常用十六进制形式表示）。那么，下面的语句：\n1printf(\"%d %p\\n\", pooh, &amp;pooh);将输出如下内容（%p是输出地址的转换说明）：\n124 0B76程序清单9.12中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。\n程序清单9.12 loccheck.c程序\n/* loccheck.c　– 查看变量被储存在何处　*/\n#include　&lt;stdio.h&gt;\nvoid mikado(int);　　　　　　　/* 函数原型 */\nint　main(void)\n{\nint pooh = 2, bah = 5; /* main()的局部变量 */\nprintf(“In　main(),　pooh　=　%d　and　&amp;pooh　=　%p\\n”,　pooh,　&amp;pooh);\nprintf(“In　main(),　bah　=　%d　and　&amp;bah　=　%p\\n”,　bah,　&amp;bah);\nmikado(pooh);\nreturn　0;\n}\nvoid mikado(int bah)　　　　　 /* 定义函数 */\n{\n","plink":"https://dxsummer.gitee.io/posts/71adb096/"},{"title":"Step6 字符输入/输出和输入验证","date":"2020-06-07T09:52:44.000Z","date_formatted":{"ll":"2020年6月7日","L":"2020/06/07","MM-DD":"06-07"},"updated":"2020-06-09T10:13:34.075Z","content":"本章介绍以下内容：\n更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别\n如何通过键盘模拟文件结尾条件\n如何使用重定向把程序和文件相连接\n创建更友好的用户界面\n在涉及计算机的话题时，我们经常会提到输入（input）和输出（output）。我们谈论输入和输出设备（如键盘、U盘、扫描仪和激光打印机），讲解如何处理输入数据和输出数据，讨论执行输入和输出任务的函数。本章主要介绍用于输入和输出的函数（简称I/O函数）。\nI/O函数（如printf()、scanf()、getchar()、putchar()等）负责把信息传送到程序中。前几章简单介绍过这些函数，本章将详细介绍它们的基本概念。同时，还会介绍如何设计与用户交互的界面。\n最初，输入/输出函数不是C定义的一部分，C把开发这些函数的任务留给编译器的实现者来完成。在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型。ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些我们曾经用过的。由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性。因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数。其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面。这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序。本章只着重讲解所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统。处理文件输入/输出的程序也可以使用这些函数。\n许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配。本章将演示一些与输入验证相关的问题和解决方案。\n单字符I/O：getchar()和putchar()第 7 章中提到过，getchar()和 putchar()每次只处理一个字符。你可能认为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方法很适合计算机。而且，这是绝大多数文本（即，普通文字）处理程序所用的核心方法。为了帮助读者回忆这些函数的工作方式，请看程序清单8.1。该程序获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用 while 循环，当读到#字符时停止。\n程序清单8.1 echo.c程序\n12345678910/* echo.c -- 重复输入 */#include　&lt;stdio.h&gt;int　main(void)&#123;    char　ch;    while　((ch　=　getchar())　!=　'#')        putchar(ch);    return　0;&#125;自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联，这就是为什么程序中要包含这个头文件的原因（其实，getchar()和 putchar()都不是真正的函数，它们被定义为供预处理器使用的宏，我们在第16章中再详细讨论）。运行该程序后，与用户的交互如下：\n1234Hello,　there.　I　would[enter]Hello,　there.　I　wouldlike　a　#3　bag　of　potatoes.[enter]like　a读者可能好奇，为何输入的字符能直接显示在屏幕上？如果用一个特殊字符（如，#）来结束输入，就无法在文本中使用这个字符，是否有更好的方法结束输入？要回答这些问题，首先要了解 C程序如何处理键盘输入，尤其是缓冲和标准输入文件的概念。\n缓冲区如果在老式系统运行程序清单8.1，你输入文本时可能显示如下：\n12HHeelllloo,, tthheerree..II wwoouulldd[enter]lliikkee aa #以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接）输入，即正在等待的程序可立即使用输入的字符。对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。图8.1比较了这两种输入。\n\n为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。\n虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。\n缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。\n那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输入是缓冲的，不过最初K&amp;R把这个决定权交给了编译器的编写者。读者可以运行echo.c程序观察输出的情况，了解所用的输出类型。\nANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数（回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击键后对应的字符不显示）。UNIX系统使用另一种不同的方式控制缓冲。在UNIX系统中，可以使用ioctl()函数（该函数属于UNIX库，但是不属于C标准）指定待输入的类型，然后用getchar()执行相应的操作。在ANSI C中，用setbuf()和setvbuf()函数（详见第13章）控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。在这里要对使用无缓冲输入的朋友说声抱歉，本书假设所有的输入都是缓冲输入。\n结束键盘输入在echo.c程序（程序清单8.1）中，只要输入的字符中不含#，那么程序在读到#时才会结束。但是， #也是一个普通的字符，有时不可避免要用到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序。C 的确提供了这样的字符，不过在此之前，先来了解一下C处理文件的方式。\n文件、流和键盘输入文件（file）是存储器中储存信息的区域。通常，文件都保存在某种永久存储器中（如，硬盘、U盘或DVD等）。毫无疑问，文件对于计算机系统相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译储存在名为 echo.c 文件中的程序时，编译器打开echo.c文件并读取其中的内容。当编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打开、读取和关闭文件，还要把数据写入文件。\nC 是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层 I/O （low-level I/O）。由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包（standard I/O package）来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。\n上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。\n如果使用标准 I/O 包，就不用考虑这些差异。因此，可以用 if (ch ==&#39;\\n&#39;)检查换行符。即使系统实际用的是回车符和换行符的组合来标记行末尾，I/O函数会在两种表示法之间相互转换。\n从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。\n第13章将更详细地讨论文件。本章着重理解C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、printf()和scanf()函数都是标准I/O包的成员，处理这两个流。\n以上讨论的内容说明，可以用处理文件的方式来处理键盘输入。例如，程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C 的输入函数内置了文件结尾检测器。既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入。下面我们从文件开始，学习如何结束文件。\n文件结尾计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS和MS-DOS的文本文件曾经用过这种方法。如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记，不过现在有一些其他的选择，例如记录文件的大小。所以现代的文本文件不一定有嵌入的Ctrl+Z，但是如果有，该操作系统会将其视为一个文件结尾标记。图8.2演示了这种方法。\n\n操作系统使用的另一种方法是储存文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符，包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。\n无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义在stdio.h文件中：\n1#define EOF (-1)为什么是-1？因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。无论哪种情况，-1都不对应任何字符，所以，该值可用于标记文件结尾。\n某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同。如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。\n那么，如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如果两值不同，就说明没有到达文件结尾。也就是说，可以使用下面这样的表达式：\n1while ((ch = getchar()) != EOF)如果正在读取的是键盘输入不是文件会怎样？绝大部分系统（不是全部）都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程序清单8.1的程序，如程序清单8.2所示。\n程序清单8.2 echo_eof.c程序\n12345678910/* echo_eof.c -- 重复输入，直到文件结尾 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　ch;    while　((ch　=　getchar())　!=　EOF)    putchar(ch);    return　0;&#125;注意下面几点。\n不用定义EOF，因为stdio.h中已经定义过了。\n不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值。\n变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数，但是EOF的值是-1。还好，getchar()函数实际返回值的类型是int，所以它可以读取EOF字符。如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式。\n由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据。\nch是整数不会影响putchar()，该函数仍然会打印等价的字符。\n使用该程序进行键盘输入，要设法输入EOF字符。不能只输入字符EOF，也不能只输入-1（输入-1会传送两个字符：一个连字符和一个数字1）。正确的方法是，必须找出当前系统的要求。例如，在大多数UNIX和Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号。许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号，一些系统把任意位置的Ctrl+Z解释成文件结尾信号。\n下面是在UNIX系统下运行echo_eof.c程序的缓冲示例：\n1234567She　walks　in　beauty,　like　the　nightShe　walks　in　beauty,　like　the　nightOf　cloudless　climes　and　starry　skies...Of　cloudless　climes　and　starry　skies...Lord　ByronLord　Byron[Ctrl+D]每次按下Enter键，系统便会处理缓冲区中储存的字符，并在下一行打印该输入行的副本。这个过程一直持续到以UNIX风格模拟文件结尾（按下Ctrl+D）。在PC中，要按下Ctrl+Z。\n我们暂停一会。既然echo_eof.c程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么。假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止。或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据，用echo_eof.c 来储存在文件中输入的内容。假设同时使用这两种方法：把输入从一个文件定向到echo_eof.c中，并把输出发送至另一个文件，然后便可以使用echo_eof.c来拷贝文件。这个小程序有查看文件内容、创建一个新文件、拷贝文件的潜力，没想到一个小程序竟然如此多才多艺！关键是要控制输入流和输出流，这是我们下一个要讨论的主题。\n注意 模拟EOF和图形界面\n模拟EOF的概念是在使用文本界面的命令行环境中产生的。在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号。但是在一些实际应用中，却不能很好地转换成图形界面（如Windows和Macintosh），这些用户界面包含更复杂的鼠标移动和按钮点击。程序要模拟EOF的行为依赖于编译器和项目类型。例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的设置。\n重定向和文件输入和输出涉及函数、数据和设备。例如，考虑 echo_eof.c，该程序使用输入函数 getchar()。输出设备（我们假设）是键盘，输入数据流由字符组成。假设你希望输入函数和数据类型不变，仅改变程序查找数据的位置。那么，程序如何知道去哪里查找输入？\n在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者（假设）是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。\n程序可以通过两种方式使用文件。第 1 种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。我们在第13章中再详细介绍这种方法。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文件。继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，而且能让读者熟悉普通的文件处理技术。\n重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C环境中（包括UNIX、Linux和Windows命令提示模式）都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。在UNIX上运行苹果OS X，可以用UNIX命令行模式启动Terminal应用程序。接下来我们介绍UNIX、Linux和Windows的重定向。\nUNIX、Linux和DOS重定向UNIX（运行命令行模式时）、Linux（ditto）和Window命令行提示（模仿旧式DOS命令行环境）都能重定向输入、输出。重定向输入让程序使用文件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕。\n重定向输入\n假设已经编译了echo_eof.c 程序，并把可执行版本放入一个名为echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。运行该程序，输入可执行文件名：\n1echo_eof该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现在，假设你要用该程序处理名为words的文本文件。文本文件（text file）是内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是一篇散文或者C程序。内含机器语言指令的文件（如储存可执行程序的文件）不是文本文件。由于该程序的操作对象是字符，所以要使用文本文件。只需用下面的命令代替上面的命令即可：\n1echo_eof &lt; words&lt;符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入echo_eof程序。echo_eof程序本身并不知道（或不关心）输入的内容是来自文件还是键盘，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾。因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备。试试看！\n注意 重定向\n对于UNIX、Linux和Windows命令提示，&lt;两侧的空格是可选的。一些系统，如AmigaDOS（那些喜欢怀旧的人使用的系统），支持重定向，但是在重定向符号和文件名之间不允许有空格。\n下面是一个特殊的words文件的运行示例，$是UNIX和Linux的标准提示符。在Windows/DOS系统中见到的DOS提示可能是A&gt;或C&gt;。\n123456$　echo_eof　&lt;　wordsThe　world　is　too　much　with　us:　late　and　soon,Getting　and　spending,　we　lay　waste　our　powers:Little　we　see　in　Nature　that　is　ours;We　have　given　our　hearts　away,　a　sordid　boon!$重定向输出\n现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。然后，输入以下命令并开始输入：\n1echo_eof&gt;mywords\\&gt;符号是第2个重定向运算符。它创建了一个名为mywords的新文件，然后把echo_eof的输出（即，你输入字符的副本）重定向至该文件中。重定向把stdout从显示设备（即，显示器）赋给mywords文件。如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容（但是，许多操作系统有保护现有文件的选项，使其成为只读文件）。所有出现在屏幕的字母都是你刚才输入的，其副本储存在文件中。在下一行的开始处按下Ctrl+D（UNIX）或Ctrl+Z（DOS）即可结束该程序。如果不知道输入什么内容，可参照下面的示例。这里，我们使用UNIX提示符$。记住在每行的末尾单击Enter键，这样才能把缓冲区的内容发送给程序。\n1234567$　echo_eof　&gt;　mywordsYou　should　have　no　problem　recalling　which　redirectionoperator　does　what.　Just　remember　that　each　operator　pointsin　the　direction　the　information　flows.　Think　of　it　asa　funnel.[Ctrl+D]$按下Ctrl+D或Ctrl+Z后，程序会结束，你的系统会提示返回。程序是否起作用了？UNIX的ls命令或Windows命令行提示模式的dir命令可以列出文件名，会显示mywords文件已存在。可以使用UNIX或Linux的cat或DOS的type命令检查文件中的内容，或者再次使用echo_eof，这次把文件重定向到程序：\n123456$　echo_eof　&lt;　mywordsYou　should　have　no　problem　recalling　which　redirectionoperator　does　what.　Just　remember　that　each　operator　pointsin　the　direction　the　information　flows.　Think　of　it　as　afunnel.$组合重定向\n现在，假设你希望制作一份mywords文件的副本，并命名为savewords。只需输入以下命令即可：\n1echo_eof &lt; mywords &gt; savewords下面的命令也起作用，因为命令与重定向运算符的顺序无关：\n1echo_eof &gt; savewords &lt; mywords注意：在一条命令中，输入文件名和输出文件名不能相同。\n1echo_eof &lt; mywords &gt; mywords....&lt;--错误原因是&gt; mywords在输入之前已导致原mywords的长度被截断为0。\n总之，在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符（&lt;和&gt;）时，要遵循以下原则。\n重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。\n\n使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件。\n\n通常，文件名和运算符之间的空格不是必须的，除非是偶尔在UNIX shell、Linux shell或Windows命令行提示模式中使用的有特殊含义的字符。例如，我们用过的echo_eof&lt;words。\n以上介绍的都是正确的例子，下面来看一下错误的例子，addup和count是两个可执行程序，fish和beets是两个文本文件：\n1234fish &gt; beets　　　　　　　　←违反第1条规则addup &lt; count　　　　　　　 ←违反第1条规则addup &lt; fish &lt; beets　　　　←违反第2条规则count &gt; beets fish　　　　　←违反第2条规则UNIX、Linux或Windows/DOS 还有&gt;&gt;运算符，该运算符可以把数据添加到现有文件的末尾，而 | 运算符能把一个文件的输出连接到另一个文件的输入。欲了解所有相关运算符的内容，请参阅 UNIX 的相关书籍，如UNIX Primer Plus，Third Edition（Wilson、Pierce和Wessler合著）。\n注释\n重定位让你能使用键盘输入程序文件。要完成这一任务，程序要测试文件的末尾。例如，第 7 章演示的统计单词程序（程序清单7.7），计算单词个数直至遇到第1个|字符。把ch的char类型改成int类型，把循环测试中的|替换成EOF，便可用该程序来计算文本文件中的单词量。\n重定向是一个命令行概念，因为我们要在命令行输入特殊的符号发出指令。如果不使用命令行环境，也可以使用重定向。首先，一些集成开发环境提供了菜单选项，让用户指定重定向。其次，对于 Windows系统，可以打开命令提示窗口，并在命令行运行可执行文件。Microsoft Visual Studio的默认设置是把可执行文件放在项目文件夹的子文件夹，称为Debug。文件名和项目名的基本名相同，文件名的扩展名为.exe。默认情况下，Xcode在给项目命名后才能命名可执行文件，并将其放在Debug文件夹中。在UNIX系统中，可以通过Terminal工具运行可执行文件。从使用上看，Terminal比命令行编译器（GCC或Clang）简单。\n如果用不了重定向，可以用程序直接打开文件。程序清单8.3演示了一个注释较少的示例。我们学到第13章时再详细讲解。待读取的文件应该与可执行文件位于同一目录。\n123456789101112131415161718192021222324程序清单8.3 file_eof.c程序// file_eof.c --打开一个文件并显示该文件#include　&lt;stdio.h&gt;#include &lt;stdlib.h&gt;　　　　　　　// 为了使用exit()int　main()&#123;    int　ch;    FILE * fp;    char fname[50];　　　　　　　// 储存文件名    printf(\"Enter　the　name　of　the　file:　\");    scanf(\"%s\",　fname);    fp = fopen(fname, \"r\");　　 // 打开待读取文件    if (fp == NULL)　　　　　　　// 如果失败    &#123;        printf(\"Failed　to　open　file.　Bye\\n\");        exit(1);　　　　　　　　　// 退出程序    &#125;    // getc(fp)从打开的文件中获取一个字符    while　((ch　=　getc(fp))　!=　EOF)    \tputchar(ch);    fclose(fp);　　　　　　　　　 // 关闭文件    return　0;&#125;小结：如何重定向输入和输出\n绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序，或只在C编译器允许的情况下重定向C程序。假设prog是可执行程序名，file1和file2是文件名。\n1234567891011把输出重定向至文件：&gt;prog &gt;file1    把输入重定向至文件：&lt;prog &lt;file2    组合重定向：prog　&lt;file2　&gt;file1prog　&gt;file1　&lt;file2    这两种形式都是把file2作为输入、file1作为输出。留白：\n一些系统要求重定向运算符左侧有一个空格，右侧没有空格。而其他系统（如，UNIX）允许在重定位运算符两侧有空格或没有空格。\n创建更友好的用户界面大部分人偶尔会写一些中看不中用的程序。还好，C提供了大量工具让输入更顺畅，处理过程更顺利。不过，学习这些工具会导致新的问题。本节的目标是，指导读者解决这些问题并创建更友好的用户界面，让交互数据输入更方便，减少错误输入的影响。\n使用缓冲输入缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入。但是，在使用输入的字符时，它也会给程序员带来麻烦。前面示例中看到的问题是，缓冲输入要求用户按下Enter键发送输入。这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符。我们以一个猜谜程序为例。用户选择一个数字，程序猜用户选中的数字是多少。该程序使用的方法单调乏味，先不要在意算法，我们关注的重点在输入和输出。查看程序清单8.4，这是猜谜程序的最初版本，后面我们会改进。\n程序清单8.4 guess.c程序\n123456789101112131415/* guess.c -- 一个拖沓且错误的猜数字程序 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　guess　=　1;    printf(\"Pick　an　integer　from　1　to　100.　I　will　try　to　guess　\");    printf(\"it.\\nRespond　with　a　y　if　my　guess　is　right　and　with\");    printf(\"\\nan　n　if　it　is　wrong.\\n\");    printf(\"Uh...is　your　number　%d?\\n\",　guess);    while (getchar() != 'y')　　 /* 获取响应，与 y 做对比 */    \tprintf(\"Well,　then,　is　it　%d?\\n\",　++guess);    printf(\"I　knew　I　could　do　it!\\n\");    return　0;&#125;下面是程序的运行示例：\n123456789101112Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?Well,　then,　is　it　3?nWell,　then,　is　it　4?Well,　then,　is　it　5?yI　knew　I　could　do　it!撇开这个程序糟糕的算法不谈，我们先选择一个数字。注意，每次输入 n 时，程序打印了两条消息。这是由于程序读取n作为用户否定了数字1，然后还读取了一个换行符作为用户否定了数字2。\n一种解决方案是，使用while循环丢弃输入行最后剩余的内容，包括换行符。这种方法的优点是，能把no和no way这样的响应视为简单的n。程序清单8.4的版本会把no当作两个响应。下面用循环修正char response;这个问题：\n123456while (getchar() != 'y')　 /* 获取响应，与 y 做对比*/&#123;    printf(\"Well,　then,　is　it　%d?\\n\",　++guess);    while　(getchar()　!=　'\\n')    \tcontinue;　　　　 /* 跳过剩余的输入行 */&#125;使用以上循环后，该程序的输出示例如下：\n1234567891011121314Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?noWell,　then,　is　it　3?no　sirWell,　then,　is　it　4?forget　itWell,　then,　is　it　5?yI knew I could do it!这的确是解决了换行符的问题。但是，该程序还是会把f被视为n。我们用if语句筛选其他响应。首先，添加一个char类型的变量储存响应：\n修改后的循环如下：\n123456789while ((response = getchar()) != 'y') /* 获取响应 */&#123;    if　(response　==　'n')    \tprintf(\"Well,　then,　is　it　%d?\\n\",　++guess);    else    \tprintf(\"Sorry,　I　understand　only　y　or　n.\\n\");    while　(getchar()　!=　'\\n')    \tcontinue; /* 跳过剩余的输入行 */&#125;现在，程序的运行示例如下：\n12345678910111213141516Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?noWell,　then,　is　it　3?no　sirWell,　then,　is　it　4?forget　itSorry,　I　understand　only　y　or　n.nWell,　then,　is　it　5?yI　knew　I　could　do　it!在编写交互式程序时，应该事先预料到用户可能会输入错误，然后设计程序处理用户的错误输入。在用户出错时通知用户再次输入。\n当然，无论你的提示写得多么清楚，总会有人误解，然后抱怨这个程序设计得多么糟糕。\n混合数值和字符输入假设程序要求用 getchar()处理字符输入，用 scanf()处理数值输入，这两个函数都能很好地完成任务，但是不能把它们混用。因为 getchar()读取每个字符，包括空格、制表符和换行符；而 scanf()在读取数字时则会跳过空格、制表符和换行符。\n我们通过程序清单8.5来解释这种情况导致的问题。该程序读入一个字符和两个数字，然后根据输入的两个数字指定的行数和列数打印该字符。\n程序清单8.5 showchar1.c程序\n1234567891011121314151617181920212223242526272829/* showchar1.c -- 有较大 I/O 问题的程序 */#include　&lt;stdio.h&gt;void display(char cr,int lines,int width);int main(void)&#123;    int ch;　　　　　　　　/* 待打印字符　 */    int rows, cols;　　　　/* 行数和列数 */    printf(\"Enter　a　character　and　two　integers:\\n\");    while((ch=getchar())!='\\n')    &#123;        scanf(\"%d　%d\",&amp;rows,&amp;cols);        display(ch,rows,cols);        printf(\"Enter　another　character　and　two　integers;\\n\");        printf(\"Enter　a　newline　to　quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void display(char cr,int lines,int width)&#123;    int row,col;    for(row=1;row&lt;=lines;row++)    &#123;        for(col=1;col&lt;=width;col++)        \tputchar(cr);        putchar('\\n');/* 结束一行并开始新的一行 */    &#125;&#125;注意，该程序以 int 类型读取字符（这样做可以检测 EOF），但是却以 char 类型把字符传递给display()函数。因为char比int小，一些编译器会给出类型转换的警告。可以忽略这些警告，或者用下面的强制类型转换消除警告：\n1display(char(ch), rows, cols);在该程序中，main()负责获取数据，display()函数负责打印数据。下面是该程序的一个运行示例，看看有什么问题：\n1234567Enter　a　character　and　two　integers:c　2　3ccccccEnter　another　character　and　two　integers;Enter　a　newline　to　quit.Bye.该程序开始时运行良好。你输入c 2 3，程序打印c字符2行3列。然后，程序提示输入第2组数据，还没等你输入数据程序就退出了！这是什么情况？又是换行符在捣乱，这次是输入行中紧跟在 3 后面的换行符。scanf()函数把这个换行符留在输入队列中。和 scanf()不同，getchar()不会跳过换行符，所以在进入下一轮迭代时，你还没来得及输入字符，它就读取了换行符，然后将其赋给ch。而ch是换行符正式终止循环的条件。\n要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格。另外，如果该程序不在getchar()测试时，而在scanf()阶段终止程序会更好。修改后的版本如程序清单8.6所示。\n程序清单8.6 showchar2.c程序\n1234567891011121314151617181920212223242526272829303132/* showchar2.c -- 按指定的行列打印字符 */#include　&lt;stdio.h&gt;void display(char cr,int lines,int width);int　main(void)&#123;    int ch;　　　　　　　　/* 待打印字符*/    int rows, cols;　　　　/* 行数和列数 */    printf(\"Enter　a　character　and　two　integers:\\n\");    while((ch=getchar())!='\\n')    &#123;        if(scanf(\"%d　%d\",&amp;rows,&amp;cols)!=2)        \tbreak;        display(ch,rows,cols);        while(getchar()!='\\n')        \tcontinue;        printf(\"Enter　another　character　and　two　integers;\\n\");        printf(\"Enter　a　newline　to　quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void display(char cr,int lines,int width)&#123;    int row,col;    for(row　=　1;　row　&lt;=　lines;　row++)    &#123;        for(col　=　1;　col　&lt;=　width;　col++)        putchar(cr);        putchar('\\n');　　/* 结束一行并开始新的一行 */    &#125;&#125;while循环实现了丢弃scanf()输入后面所有字符（包括换行符）的功能，为循环的下一轮读取做好了准备。该程序的运行示例如下：\n123456789101112Enter　a　character　and　two　integers:c　1　2ccEnter　another　character　and　two　integers;Enter　a　newline　to　quit.!　3　6!!!!!!!!!!!!!!!!!!Enter　another　character　and　two　integers;Enter　a　newline　to　quit.Bye.在if语句中使用一个break语句，可以在scanf()的返回值不等于2时终止程序，即如果一个或两个输入值不是整数或者遇到文件结尾就终止程序。\n输入验证在实际应用中，用户不一定会按照程序的指令行事。用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败。作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误，这样才能编写出能检测并处理这些问题的程序。\n例如，假设你编写了一个处理非负数整数的循环，但是用户很可能输入一个负数。你可以使用关系表达式来排除这种情况：\n1234567long　n;scanf(\"%ld\", &amp;n);　　　// 获取第1个值while (n &gt;= 0)　　　　　// 检测不在范围内的值&#123;    // 处理n    scanf(\"%ld\", &amp;n);　// 获取下一个值&#125;另一类潜在的陷阱是，用户可能输入错误类型的值，如字符 q。排除这种情况的一种方法是，检查scanf()的返回值。回忆一下，scanf()返回成功读取项的个数。因此，下面的表达式当且仅当用户输入一个整数时才为真：\n1scanf(\"%ld\",　&amp;n)　==　1结合上面的while循环，可改进为：\n12345long　n;while(scanf(\"%ld\",&amp;n)==1&amp;&amp;n&gt;=0)&#123;//处理n&#125;while循环条件可以描述为“当输入是一个整数且该整数为正时”。\n对于最后的例子，当用户输入错误类型的值时，程序结束。然而，也可以让程序友好些，提示用户再次输入正确类型的值。在这种情况下，要处理有问题的输入。如果scanf()没有成功读取，就会将其留在输入队列中。这里要明确，输入实际上是字符流。可以使用getchar()函数逐字符地读取输入，甚至可以把这些想法都结合在一个函数中，如下所示：\n12345678910111213long get_long(void)&#123;    long input;    char ch;    while(scanf(\"%ld\",&amp;input)!=1)    &#123;        while((ch=getchar())!='\\n')        \tputchar(ch); // 处理错误的输入        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;    return input;&#125;该函数要把一个int类型的值读入变量input中。如果读取失败，函数则进入外层while循环体。然后内层循环逐字符地读取错误的输入。注意，该函数丢弃该输入行的所有剩余内容。还有一个方法是，只丢弃下一个字符或单词，然后该函数提示用户再次输入。外层循环重复运行，直到用户成功输入整数，此时scanf()的返回值为1。\n在用户输入整数后，程序可以检查该值是否有效。考虑一个例子，要求用户输入一个上限和一个下限来定义值的范围。在该例中，你可能希望程序检查第1个值是否大于第2个值（通常假设第1个值是较小的那个值），除此之外还要检查这些值是否在允许的范围内。例如，当前的档案查找一般不会接受 1958 年以前和2014年以后的查询任务。这个限制可以在一个函数中实现。\n假设程序中包含了stdbool.h 头文件。如果当前系统不允许使用_Bool，把bool替换成int，把true 替换成 1，把 false 替换成 0 即可。注意，如果输入无效，该函数返回 true，所以函数名为bad_limits()：\n1234567891011121314151617181920bool bad_limits(long begin,long end,long low,long high)&#123;    bool not_good=false;    if (begin&gt;end)    &#123;        printf(\"%ld　isn't　smaller　than　%ld.\\n\",　begin,　end);        not_good=true;    &#125;    if(begin&lt;low||end&lt;low)    &#123;        printf(\"Values　must　be　%ld　or　greater.\\n\",　low);        not_good=true;    &#125;    if(begin&gt;high||end&gt;high)    &#123;        printf(\"Values　must　be　%ld　or　less.\\n\",　high);        not_good=true;    &#125;    return not_good;&#125;程序清单8.7使用了上面的两个函数为一个进行算术运算的函数提供整数，该函数计算特定范围内所有整数的平方和。程序限制了范围的上限是10000000，下限是-10000000。\n程序清单8.7 checking.c程序\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// checking.c -- 输入验证#include　&lt;stdio.h&gt;#include　&lt;stdbool.h&gt;// 验证输入是一个整数long get_long(void);// 验证范围的上下限是否有效bool bad_limits(long　begin,　long　end,long low,long high);// 计算a～b之间的整数平方和double sum_squares(long a,long b);int　main(void)&#123;    const long MIN=-10000000L;　　// 范围的下限    const long MAX=+10000000L;　　// 范围的上限    long start;　　　　　　　　　　　　// 用户指定的范围最小值    long stop;　　　　　　　　　　　　 // 用户指定的范围最大值    double　answer;    printf(\"This　program　computes　the　sum　of　the　squares　of　\"    \"integers　in　a　range.\\nThe　lower　bound　should　not　\"    \"be　less　than　-10000000　and\\nthe　upper　bound　\"    \"should　not　be　more　than　+10000000.\\nEnter　the　\"    \"limits　(enter　0　for　both　limits　to　quit):\\n\"    \"lower　limit:　\");    start=get_long();    printf(\"upper　limit:　\");    stop=get_long();    while(start!=0||stop!=0)    &#123;        if(bad_limits(start,stop,MIN,MAX))        \tprintf(\"Please　try　again.\\n\");        else        &#123;            answer=sum_squares(start,stop);            printf(\"The　sum　of　the　squares　of　the　integers　\");            printf(\"from　%ld　to　%ld　is　%g\\n\",            start,stop,answer);        &#125;        printf(\"Enter　the　limits　(enter　0　for　both　\"        \"limits　to　quit):\\n\");        printf(\"lower　limit:　\");        start=get_long();        printf(\"upper　limit:　\");        stop=get_long();\t&#125;\tprintf(\"Done.\\n\");\treturn　0;&#125;long get_long(void)&#123;    long input;    char ch;    while(scanf(\"%ld\",&amp;input)!=1)    &#123;        while((ch=getchar())!='\\n')        \tputchar(ch);　　　　　　 // 处理错误输入        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;\treturn input;&#125;double sum_squares(long a,long b)&#123;    double total=0;    long i;    for(i=a;i&lt;=b;i++)    \ttotal+=(double)i*(double) i;    return total;&#125;bool bad_limits(long begin,long end,long low,long high)&#123;    bool not_good=false;    if(begin&gt;end)    &#123;        printf(\"%ld　isn't　smaller　than　%ld.\\n\",　begin,　end);        not_good=true;    &#125;    if(begin&lt;low||end&lt;low)    &#123;        printf(\"Values　must　be　%ld　or　greater.\\n\",　low);        not_good=true;    &#125;    if(begin&gt;high||end&gt;high)    &#123;        printf(\"Values　must　be　%ld　or　less.\\n\",　high);        not_good=true;    &#125;    return not_good;&#125;下面是该程序的输出示例：\n1234567891011121314151617181920This　program　computes　the　sum　of　the　squares　of　integers　in　a　range.The　lower　bound　should　not　be　less　than　-10000000　andthe　upper　bound　should　not　be　more　than　+10000000.Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　lowlow　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　3upper　limit:　a　big　numbera　big　number　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　12The　sum　of　the　squares　of　the　integers　from　3　to　12　is　645Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　80upper　limit:　1080　isn't　smaller　than　10.Please　try　again.Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　0upper　limit:　0Done.分析程序虽然checking.c程序的核心计算部分（sum_squares()函数）很短，但是输入验证部分比以往程序示例要复杂。接下来分析其中的一些要素，先着重讨论程序的整体结构。\n程序遵循模块化的编程思想，使用独立函数（模块）来验证输入和管理显示。程序越大，使用模块化编程就越重要。\nmain()函数管理程序流，为其他函数委派任务。它使用 get_long()获取值、while 循环处理值、badlimits()函数检查值是否有效、sum_squres()函数处理实际的计算：\n1234567891011121314151617181920start=get_long();printf(\"upper　limit:　\");stop=get_long();while(start!=0||stop!=0)&#123;    if　(bad_limits(start,　stop,　MIN,　MAX))    \tprintf(\"Please　try　again.\\n\");    else    &#123;        answer　=　sum_squares(start,　stop);        printf(\"The　sum　of　the　squares　of　the　integers　\");        printf(\"from　%ld　to　%ld　is　%g\\n\",　start,　stop,　answer);    &#125;    printf(\"Enter　the　limits　(enter　0　for　both　\"    \"limits　to　quit):\\n\");    printf(\"lower　limit:　\");    start=get_long();    printf(\"upper　limit:　\");    stop=get_long();&#125;输入流和数字在编写处理错误输入的代码时（如程序清单8.7），应该很清楚C是如何处理输入的。考虑下面的输入：\n1is 28 12.4在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对 C程序而言，这是一个字节流。第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：\n12while ((ch=getchar())!='\\n')putchar(ch); // 处理错误的输入虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值。例如，考虑下面的输入：\n142如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。\n简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。使用转换说明（如%d或%f）限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。\n菜单浏览许多计算机程序都把菜单作为用户界面的一部分。菜单给用户提供方便的同时，却给程序员带来了一些麻烦。我们看看其中涉及了哪些问题。\n菜单给用户提供了一份响应程序的选项。假设有下面一个例子：\n123Enter　the　letter　of　your　choice:a.　advice　　　　　　　b.　bellc.　count　　　　　　　　q.　quit理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务。作为一名程序员，自然希望这一过程能顺利进行。因此，第1个目标是：当用户遵循指令时程序顺利运行；第2个目标是：当用户没有遵循指令时，程序也能顺利运行。显而易见，要实现第 2 个目标难度较大，因为很难预料用户在使用程序时的所有错误情况。\n现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标，而不是我们示例中的命令行模式。但是，两者的处理过程大致相同：给用户提供选项、检查并执行用户的响应、保护程序不受误操作的影响。除了界面不同，它们底层的程序结构也几乎相同。但是，使用图形界面更容易通过限制选项控制输入。\n任务我们来更具体地分析一个菜单程序需要执行哪些任务。它要获取用户的响应，根据响应选择要执行的动作。另外，程序应该提供返回菜单的选项。C 的 switch 语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签。使用while语句可以实现重复访问菜单的功能。因此，我们写出以下伪代码：\n1234获取选项当选项不是'q'时转至相应的选项并执行获取下一个选项使执行更顺利当你决定实现这个程序时，就要开始考虑如何让程序顺利运行（顺利运行指的是，处理正确输入和错误输入时都能顺利运行）。例如，你能做的是让“获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入switch。这表明需要为输入过程提供一个只返回正确响应的函数。结合while循环和switch语句，其程序结构如下：\n12345678910111213141516171819202122#include　&lt;stdio.h&gt;char　get_choice(void);void　count(void);int　main(void)&#123;    int choice;    while((choice　=　get_choice())　!=　'q')    &#123;        switch　(choice)        &#123;            case 'a':　printf(\"Buy　low,　sell　high.\\n\");            \tbreak;            case 'b': putchar('\\a'); /* ANSI */            \tbreak;            case 'c':　count();            \tbreak;            default:　 printf(\"Program　error!\\n\");            \tbreak;    \t&#125;    &#125;    return　0;&#125;定义get_choice()函数只能返回&#39;a&#39;、&#39;b&#39;、&#39;c&#39;和&#39;q&#39;。get_choice()的用法和getchar()相同，两个函数都是获取一个值，并与终止值（该例中是&#39;q&#39;）作比较。我们尽量简化实际的菜单选项，以便读者把注意力集中在程序结构上。稍后再讨论 count()函数。default 语句可以方便调试。如果get_choice()函数没能把返回值限制为菜单指定的几个选项值，default语句有助于发现问题所在。\nget_choice()函数\n下面的伪代码是设计这个函数的一种方案：\n显示选项\n获取用户的响应\n当响应不合适时\n提示用户再次输入\n获取用户的响应\n下面是一个简单而笨拙的实现：\n1234567891011121314char　get_choice(void)&#123;    int　ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　　b.　bell\\n\");    printf(\"c.　count　　　　　　　　 q.　quit\\n\");    ch=getchar();    while　((ch　&lt;　'a'　||　ch　&gt;　'c')　&amp;&amp;　ch　!=　'q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=getchar();    &#125;    return　ch;&#125;缓冲输入依旧带来些麻烦，程序把用户每次按下 Return 键产生的换行符视为错误响应。为了让程序的界面更流畅，该函数应该跳过这些换行符。\n这类问题有多种解决方案。一种是用名为get_first()的新函数替换getchar()函数，读取一行的第1个字符并丢弃剩余的字符。这种方法的优点是，把类似act这样的输入视为简单的a，而不是继续把act中的c作为选项c的一个有效的响应。我们重写输入函数如下：\n12345678910111213141516171819202122char get_choice(void)&#123;    int ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　　 b.　bell\\n\");    printf(\"c.　count　　　　　　　　　 q.　quit\\n\");    ch=get_first();    while((ch&lt;'a'||ch&gt;'c')&amp;&amp;ch!='q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=getfirst();    &#125;    return　ch;&#125;char get_first(void)&#123;    int ch;    ch=getchar();　 /* 读取下一个字符 */    while(getchar()!='\\n')    continue; /* 跳过该行剩下的内容 */    return　ch;&#125;混合字符和数值输入前面分析过混合字符和数值输入会产生一些问题，创建菜单也有这样的问题。例如，假设count()函数（选择c）的代码如下：\n12345678void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    scanf(\"%d\",&amp;n);    for(i=1;i&lt;=n;i++)    \tprintf(\"%d\\n\",i);&#125;如果输入3作为响应，scanf()会读取3并把换行符留在输入队列中。下次调用 get_choice()将导致get_first()返回这个换行符，从而导致我们不希望出现的行为。\n重写 get_first()，使其返回下一个非空白字符而不仅仅是下一个字符，即可修复这个问题。我们把这个任务留给读者作为练习。另一种方法是，在count()函数中清理换行符，如下所示：\n12345678910void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    n=get_int();    for(i=1;i&lt;=n;i++)    \tprintf(\"%d\\n\",i);    while(getchar()!='\\n')    \tcontinue;&#125;该函数借鉴了程序清单8.7中的get_long()函数，将其改为get_int()获取int类型的数据而不是long类型的数据。回忆一下，原来的get_long()函数如何检查有效输入和让用户重新输入。程序清单8.8演示了菜单程序的最终版本。\n程序清单8.8 menuette.c程序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* menuette.c -- 菜单程序 */#include　&lt;stdio.h&gt;char　get_choice(void);char　get_first(void);int　get_int(void);void　count(void);int　main(void)&#123;    int choice;    void count(void);    while((choice　=　get_choice())　!=　'q')    &#123;        switch(choice)        &#123;            case 'a':　printf(\"Buy　low,　sell　high.\\n\");            \tbreak;            case 'b':　putchar('\\a');　 /* ANSI */            \tbreak;            case 'c':　count();            \tbreak;            default:　　printf(\"Program　error!\\n\");            \tbreak;        &#125;    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    n=get_int();    for(i　=　1;　i　&lt;=　n;　i++)    \tprintf(\"%d\\n\",　i);    while(getchar()　!=　'\\n')    \tcontinue;&#125;char get_choice(void)&#123;    int ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　b.　bell\\n\");    printf(\"c.　count　　　　　　　　q.　quit\\n\");    ch=get_first();    while((ch　&lt;　'a'　||　ch　&gt;　'c')　&amp;&amp;　ch　!=　'q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=get_first();    &#125;    return ch;&#125;char get_first(void)&#123;    int　ch;    ch=getchar();    while　(getchar()　!=　'\\n')    continue;&#125;int get_int(void)&#123;    int input;    char ch;    while(scanf(\"%d\",　&amp;input)　!=　1)    &#123;        while　((ch　=　getchar())　!=　'\\n')        putchar(ch);　// 处理错误输出        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;    return input;&#125;下面是该程序的一个运行示例：\n123456789101112131415161718192021222324Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitaBuy　low,　sell　high.Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitcountCount　how　far?　Enter　an　integer:twotwo　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　512345Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitdPlease　respond　with　a,　b,　c,　or　q.q要写出一个自己十分满意的菜单界面并不容易。但是，在开发了一种可行的方案后，可以在其他情况下复用这个菜单界面。\n学完以上程序示例后，还要注意在处理较复杂的任务时，如何让函数把任务委派给另一个函数。这样让程序更模块化。\n关键概念C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个字符编码。scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值。许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出。\n程序通常接受特殊形式的输入。可以在设计程序时考虑用户在输入时可能犯的错误，在输入验证部分处理这些错误情况，让程序更强健更友好。\n对于一个小型程序，输入验证可能是代码中最复杂的部分。处理这类问题有多种方案。例如，如果用户输入错误类型的信息，可以终止程序，也可以给用户提供有限次或无限次机会重新输入。\n本章小结许多程序使用 getchar()逐字符读取输入。通常，系统使用行缓冲输入，即当用户按下 Enter 键后输入才被传送给程序。按下Enter键也传送了一个换行符，编程时要注意处理这个换行符。ANSI C把缓冲输入作为标准。\n通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同文件形式，是C语言的特性之一。getchar()和 scanf()函数也属于这一系列。当检测到文件结尾时，这两个函数都返回 EOF（被定义在stdio.h头文件中）。在不同系统中模拟文件结尾条件的方式稍有不同。在UNIX系统中，在一行开始处按下Ctrl+D可以模拟文件结尾条件；而在DOS系统中则使用Ctrl+Z。\n许多操作系统（包括UNIX和DOS）都有重定向的特性，因此可以用文件代替键盘和屏幕进行输入和输出。读到EOF即停止读取的程序可用于键盘输入和模拟文件结尾信号，或者用于重定向文件。\n混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程序中妥善处理。\n编写程序时，要认真设计用户界面。事先预料一些用户可能会犯的错误，然后设计程序妥善处理这些错误情况。\n","plink":"https://dxsummer.gitee.io/posts/86602531/"},{"title":"Step5 C控制语句：分支和跳转","date":"2020-06-06T02:30:50.000Z","date_formatted":{"ll":"2020年6月6日","L":"2020/06/06","MM-DD":"06-06"},"updated":"2020-06-08T01:44:18.717Z","content":"本章介绍以下内容：\n关键字：if、else、switch、continue、break、case、default、goto\n运算符：&amp;&amp;、||、?、:\n函数：getchar()、putchar()、ctype.h系列\n如何使用if和if else语句，如何嵌套它们\n在更复杂的测试表达式中用逻辑运算符组合关系表达式\nC的条件运算符\nswitch语句\nbreak、continue和goto语句\n使用C的字符I/O函数：getchar()和putchar()\nctype.h头文件提供的字符分析函数系列\n随着越来越熟悉C，可以尝试用C程序解决一些更复杂的问题。这时候，需要一些方法来控制和组织程序，为此C提供了一些工具。前面已经学过如何在程序中用循环重复执行任务。本章将介绍分支结构（如， if和switch），让程序根据测试条件执行相应的行为。另外，还将介绍C语言的逻辑运算符，使用逻辑运算符能在 while 或 if 的条件中测试更多关系。此外，本章还将介绍跳转语句，它将程序流转换到程序的其他部分。学完本章后，读者就可以设计按自己期望方式运行的程序。\nif语句我们从一个有if语句的简单示例开始学习，请看程序清单7.1。该程序读取一列数据，每个数据都表示每日的最低温度（℃），然后打印统计的总天数和最低温度在0℃以下的天数占总天数的百分比。程序中的循环通过scanf()读入温度值。while循环每迭代一次，就递增计数器增加天数，其中的if语句负责判断0℃以下的温度并单独统计相应的天数。\n程序清单7.1 colddays.c程序\n123456789101112131415161718192021222324// colddays.c -- 找出0℃以下的天数占总天数的百分比#include &lt;stdio.h&gt;int main(void)&#123;    const int FREEZING=0;    float temperature;    int cold_days=0;    int all_days=0;    printf(\"Enter the list of daily low temperatures.\\n\");    printf(\"Use Celsius, and enter q to quit.\\n\");    while(scanf(\"%f\",&amp;temperature)==1)    &#123;        all_days++;        if(temperature&lt;FREEZING)        cold_days++;    &#125;    if (all_days!=0)   \t\tprintf(\"%d days total: %.1f%% were below freezing.\\n\",  \t\tall_days,100.0*(float)cold_days/all_days);    if (all_days==0) \t   printf(\"No data entered!\\n\");    return 0;&#125;下面是该程序的输出示例：\n1234Enter the list of daily low temperatures.Use Celsius, and enter q to quit.12 5 -2.5 0 6 8 -3 -10 5 10 q10 days total: 30.0% were below freezing.while循环的测试条件利用scanf()的返回值来结束循环，因为scanf()在读到非数字字符时会返回0。temperature的类型是float而不是int，这样程序既可以接受-2.5这样的值，也可以接受8这样的值。\nwhile循环中的新语句如下：\n12if(temperature&lt;FREEZING)cold_days++;if 语句指示计算机，如果刚读取的值（remperature）小于 0，就把 cold_days 递增 1；如果temperature不小于0，就跳过cold_days++;语句，while循环继续读取下一个温度值。\n接着，该程序又使用了两次if语句控制程序的输出。如果有数据，就打印结果；如果没有数据，就打印一条消息（稍后将介绍一种更好的方法来处理这种情况）。\n为避免整数除法，该程序示例把计算后的百分比强制转换为 float类型。其实，也不必使用强制类型转换，因为在表达式100.0 * cold_days / all_days中，将首先对表达式100.0 * cold_days求值，由于C的自动转换类型规则，乘积会被强制转换成浮点数。但是，使用强制类型转换可以明确表达转换类型的意图，保护程序免受不同版本编译器的影响。if语句被称为分支语句（branching statement）或选择语句（selection statement），因为它相当于一个交叉点，程序要在两条分支中选择一条执行。if语句的通用形式如下：\n12if(expression)statement如果对expression求值为真（非0），则执行statement；否则，跳过statement。与while循环一样，statement可以是一条简单语句或复合语句。if语句的结构和while语句很相似，它们的主要区别是：如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次。\n通常，expression 是关系表达式，即比较两个量的大小（如，表达式 x &gt; y 或 c == 6）。如果expression为真（即x大于y，或c == 6），则执行statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式的值为0则为假。\nstatement部分可以是一条简单语句，如本例所示，或者是一条用花括号括起来的复合语句（或块）：\n1234567if (score &gt; big)    printf(\"Jackpot!\\n\");　// 简单语句if (joe &gt; ron)&#123;　　　　　　　　　　　　　 // 复合语句    joecash++;    printf(\"You lose, Ron.\\n\");&#125;注意，即使if语句由复合语句构成，整个if语句仍被视为一条语句。\nif else语句简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。C还提供了if else形式，可以在两条语句之间作选择。我们用if else形式修正程序清单7.1中的程序段。\n12345if (all_days != 0)\tprintf(\"%d days total: %.1f%% were below freezing.\\n\",\tall_days, 100.0 * (float) cold_days / all_days);if (all_days == 0)\tprintf(\"No data entered!\\n\");如果程序发现all_days不等于0，那么它应该知道另一种情况一定是all_days等于0。用if else形式只需测试一次。重写上面的程序段如下：\n12345if (all_days!= 0)    printf(\"%d days total: %.1f%% were below freezing.\\n\",    all_days, 100.0 * (float) cold_days / all_days);else    printf(\"No data entered!\\n\");如果if语句的测试表达式为真，就打印温度数据；如果为假，就打印警告消息。\n注意，if else语句的通用形式是：\n1234if ( expression )statement1elsestatement2如果expression为真（非0），则执行statement1；如果expression为假或0，则执行else后面的statement2。statement1和statement2可以是一条简单语句或复合语句。C并不要求一定要缩进，但这是标准风格。缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然。\n如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块。下面的代码结构违反了C语法，因为在if和else之间只允许有一条语句（简单语句或复合语句）：\n12345if (x &gt; 0)\tprintf(\"Incrementing x:\\n\");x++;else　　　// 将产生一个错误\tprintf(\"x &lt;= 0 \\n\");编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语句，它不是if语句的一部分。然后，编译器发现else并没有所属的if，这是错误的。上面的代码应该这样写：\n1234567if (x &gt; 0)&#123;    printf(\"Incrementing x:\\n\");    x++;&#125;else    printf(\"x &lt;= 0 \\n\");if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间选择。图7.1比较了这两种语句。\n\n另一个示例：介绍getchar()和putchar()到目前为止，学过的大多数程序示例都要求输入数值。接下来，我们看看输入字符的示例。相信读者已经熟悉了如何用 scanf()和 printf()根据%c 转换说明读写字符，我们马上要讲解的示例中要用到一对字符输入/输出函数：getchar()和putchar()。\ngetchar()函数不带任何参数，它从输入队列中返回下一个字符。例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：\n1ch = getchar();该语句与下面的语句效果相同：\n1scanf(\"%c\", &amp;ch);putchar()函数打印它的参数。例如，下面的语句把之前赋给ch的值作为字符打印出来：\n1putchar(ch);该语句与下面的语句效果相同：\n1printf(\"%c\", ch);由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁。而且，注意 getchar()和 putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在 stdio.h头文件中（而且，它们通常是预处理宏，而不是真正的函数，第16章会讨论类似函数的宏）。\n接下来，我们编写一个程序来说明这两个函数是如何工作的。该程序把一行输入重新打印出来，但是每个非空格都被替换成原字符在ASCII序列中的下一个字符，空格不变。这一过程可描述为“如果字符是空白，原样打印；否则，打印原字符在ASCII序列中的下一个字符”。\nC代码看上去和上面的描述很相似，请看程序清单7.2。\n1234567891011121314151617181920程序清单7.2 cypher1.c程序// cypher1.c -- 更改输入，空格不变#include &lt;stdio.h&gt;#define SPACE ' '　　　　　　　 // SPACE表示单引号-空格-单引号int main(void)&#123;    char ch;    ch = getchar();　　　　　　 // 读取一个字符    while (ch != '\\n')　　　　 // 当一行未结束时    &#123;        if (ch == SPACE)　　　 // 留下空格     \t   putchar(ch);　　　 // 该字符不变        else     \t   putchar(ch + 1);　 // 改变其他字符        ch = getchar();　　　　// 获取下一个字符    &#125;    putchar(ch);　　　　　　　　// 打印换行符    return 0;&#125;（如果编译器警告因转换可能导致数据丢失，不用担心。第8章在讲到EOF时再解释。）\n下面是该程序的输入示例：\n12CALL ME HAL.DBMM NF IBM/把程序清单7.1中的循环和该例中的循环作比较。前者使用scanf()返回的状态值判断是否结束循环，而后者使用输入项的值来判断是否结束循环。这使得两程序所用的循环结构略有不同：程序清单7.1中在循环前面有一条“读取语句”，程序清单7.2中在每次迭代的末尾有一条“读取语句”。不过，C的语法比较灵活，读者也可以模仿程序清单7.1，把读取和测试合并成一个表达式。也就是说，可以把这种形式的循环：\n123456ch = getchar();　　　 /* 读取一个字符 */while (ch != '\\n')　　/* 当一行未结束时 */&#123;    ...　　　　　　　/* 处理字符 */    ch = getchar();　 /* 获取下一个字符 */&#125;替换成下面形式的循环：\n1234while ((ch = getchar()) != '\\n')&#123;\t...　　　　　　　/* 处理字符 */&#125;关键的一行代码是：\n1while ((ch = getchar()) != '\\n')这体现了C特有的编程风格——把两个行为合并成一个表达式。C对代码的格式要求宽松，这样写让其中的每个行为更加清晰：\n123while ((ch = getchar())　　　　　　 // 给ch赋一个值!= '\\n')　 // 把ch和\\n作比较以上执行的行为是赋值给ch和把ch的值与换行符作比较。表达式ch = getchar()两侧的圆括号使之成为!=运算符的左侧运算对象。要对该表达式求值，必须先调用getchar()函数，然后把该函数的返回值赋给 ch。因为赋值表达式的值是赋值运算符左侧运算对象的值，所以 ch = getchar()的值就是 ch 的新值，因此，读取ch的值后，测试条件相当于是ch != &#39;\\n&#39;（即，ch不是换行符）。\n这种独特的写法在C编程中很常见，应该多熟悉它。还要记住合理使用圆括号组合子表达式。上面例子中的圆括号都必不可少。假设省略ch = getchar()两侧的圆括号：\n1while (ch = getchar() != '\\n')!=运算符的优先级比=高，所以先对表达式getchar() != &#39;\\n&#39;求值。由于这是关系表达式，所以其值不是1就是0（真或假）。然后，把该值赋给ch。省略圆括号意味着赋给ch的值是0或1，而不是 getchar()的返回值。这不是我们的初衷。\n下面的语句：\n1putchar(ch + 1); /* 改变其他字符 */再次演示了字符实际上是作为整数储存的。为方便计算，表达式ch + 1中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参数的putchar()，该函数只根据最后一个字节确定显示哪个字符。\nctype.h系列的字符函数注意到程序清单7.2的输出中，最后输入的点号（.）被转换成斜杠（/），这是因为斜杠字符对应的ASCII码比点号的 ASCII 码多 1。如果程序只转换字母，保留所有的非字母字符（不只是空格）会更好。本章稍后讨论的逻辑运算符可用来测试字符是否不是空格、不是逗号等，但是列出所有的可能性太繁琐。C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值（真）；否则，返回0（假）。例如，如果isalpha()函数的参数是一个字母，则返回一个非零值。程序清单7.3在程序清单7.2的基础上使用了这个函数，还使用了刚才精简后的循环。\n123456789101112131415161718程序清单7.3 cypher2.c程序// cypher2.c -- 替换输入的字母，非字母字符保持不变#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;　　　　　　　// 包含isalpha()的函数原型int main(void)&#123;    char ch;    while ((ch = getchar()) != '\\n')    &#123;        if (isalpha(ch))　　　 // 如果是一个字符，\t\t\tputchar(ch + 1);　 // 显示该字符的下一个字符        else　　　　　　　　　　// 否则，\t\t\tputchar(ch);　　　 // 原样显示    &#125;    putchar(ch);　　　　　　　 // 显示换行符    return 0;&#125;下面是该程序的一个输出示例，注意大小写字母都被替换了，除了空格和标点符号：\n12Look! It's a programmer!Mppl! Ju't b qsphsbnnfs!表7.1和表7.2列出了ctype.h头文件中的一些函数。有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具（例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为123,45）。注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值。也就是说，下面的语句不改变ch的值：\n1tolower(ch); // 不影响ch的值这样做才会改变ch的值：\n1ch = tolower(ch); // 把ch转换成小写字母\nctype.h头文件中的字符测试函数\n\n\n\nctype.h头文件中的字符映射函数\n\n\n多重选择else if现实生活中我们经常有多种选择。在程序中也可以用else if扩展if else结构模拟这种情况。来看一个特殊的例子。电力公司通常根据客户的总用电量来决定电费。下面是某电力公司的电费清单，单位是千瓦时（kWh）：\n1234首 360kWh:　　　　 $0.13230/kWh续 108kWh:　　　　 $0.15040/kWh续 252kWh:　　　　 $0.30025/kWh超过 720kWh:　　　 $0.34025/kWh如果对用电管理感兴趣，可以编写一个计算电费的程序。程序清单7.4是完成这一任务的第1步。\n程序清单7.4 electric.c程序\n123456789101112131415161718192021222324252627282930313233// electric.c -- 计算电费#include &lt;stdio.h&gt;#define RATE1　 0.13230　　　　　　　// 首次使用 360 kwh 的费率#define RATE2　 0.15040　　　　　　　// 接着再使用 108 kwh 的费率#define RATE3　 0.30025　　　　　　　// 接着再使用 252 kwh 的费率#define RATE4　 0.34025　　　　　　　// 使用超过 720kwh 的费率#define BREAK1　360.0　　　　　　　　// 费率的第1个分界点#define BREAK2　468.0　　　　　　　　// 费率的第2个分界点#define BREAK3　720.0　　　　　　　　// 费率的第3个分界点#define BASE1　(RATE1 * BREAK1)// 使用360kwh的费用#define BASE2 (BASE1 + (RATE2 * (BREAK2 - BREAK1)))// 使用468kwh的费用#define BASE3　(BASE1 + BASE2 + (RATE3 *(BREAK3 - BREAK2)))// 使用720kwh的费用int main(void)&#123;    double kwh;　　　　　　　　　　 // 使用的千瓦时    double bill;　　　　　　　　　　// 电费    printf(\"Please enter the kwh used.\\n\");    scanf(\"%lf\", &amp;kwh);　　　　　　 // %lf对应double类型    if (kwh &lt;= BREAK1)\t\tbill = RATE1 * kwh;    else if (kwh &lt;= BREAK2)　　　　 // 360～468 kwh\t\tbill = BASE1 + (RATE2 * (kwh - BREAK1));    else if (kwh &lt;= BREAK3)　　　　 // 468～720 kwh\t\tbill = BASE2 + (RATE3 * (kwh - BREAK2));    else　　　　　　　　　　　　　　// 超过 720 kwh\t\tbill = BASE3 + (RATE4 * (kwh - BREAK3));    printf(\"The charge for %.1f kwh is $%1.2f.\\n\", kwh, bill);    return 0;&#125;该程序的输出示例如下：\n123Please enter the kwh used.580The charge for 580.0 kwh is $97.50.程序清单 7.4 用符号常量表示不同的费率和费率分界点，以便把常量统一放在一处。这样，电力公司在更改费率以及费率分界点时，更新数据非常方便。BASE1和BASE2根据费率和费率分界点来表示。一旦费率或分界点发生了变化，它们也会自动更新。预处理器是不进行计算的。程序中出现BASE1的地方都会被替换成 0.13230*360.0。不用担心，编译器会对该表达式求值得到一个数值（47.628），以便最终的程序代码使用的是47.628而不是一个计算式。\n程序流简单明了。该程序根据kwh的值在3个公式之间选择一个。特别要注意的是，如果kwh大于或等于360，程序只会到达第1个else。因此，else if(kwh&lt;=BREAK2)这行相当于要求kwh在360～482之间，如程序注释所示。类似地，只有当kwh的值超过720时，才会执行最后的else。最后，注意BASE1、BASE2和BASE3分别代表360、468和720千瓦时的总费用。因此，当电量超过这些值时，只需要加上额外的费用即可。\n实际上，else if 是已学过的 if else 语句的变式。例如，该程序的核心部分只不过是下面代码的另一种写法：\n12345678910if (kwh &lt;= BREAK1)\tbill=RATE1*kwh;else\tif (kwh &lt;= BREAK2)　　　　 // 360～468 kwh\t\tbill = BASE1 + (RATE2 * (kwh - BREAK1));\telse\t\tif (kwh &lt;= BREAK3)　　 // 468～720 kwh\t\t\tbill = BASE2 + (RATE3 * (kwh - BREAK2));\t\telse　　　　　　　　　　// 超过720 kwh\t\t\tbill = BASE3 + (RATE4 * (kwh - BREAK3));也就是说，该程序由一个if else语句组成，else部分包含另一个if else语句，该if else语句的else部分又包含另一个if else语句。第2个if else语句嵌套在第 1个if else语句中，第3个if else语句嵌套在第2个if else语句中。回忆一下，整个if else语句被视为一条语句，因此不必把嵌套的if else语句用花括号括起来。当然，花括号可以更清楚地表明这种特殊格式的含义。\n这两种形式完全等价。唯一不同的是使用空格和换行的位置不同，不过编译器会忽略这些。尽管如此，第1种形式还是好些，因为这种形式更清楚地显示了有4种选择。在浏览程序时，这种形式让读者更容易看清楚各项选择。在需要时要缩进嵌套的部分，例如，必须测试两个单独的量时。本例中，仅在夏季对用电量超过720kWh的用户加收10%的电费，就属于这种情况。\n可以把多个else if语句连成一串使用，如下所示（当然，要在编译器的限制范围内）：\n12345678910if (score &lt; 1000)\tbonus = 0;else if (score &lt; 1500)\tbonus = 1;else if (score &lt; 2000)\tbonus = 2;else if (score &lt; 2500)\tbonus = 4;else\tbonus = 6;（这可能是一个游戏程序的一部分，bonus表示下一局游戏获得的光子炸弹或补给。）\n对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌。\nelse与if配对如果程序中有许多if和else，编译器如何知道哪个if对应哪个else？例如，考虑下面的程序段：\n12345if (number &gt; 6)\tif (number &lt; 12)\t\tprintf(\"You're close!\\n\");\telse\t\tprintf(\"Sorry, you lose a turn!\\n\");何时打印Sorry, you lose a turn!？当number小于或等于6时，还是number大于12时？换言之，else与第1个if还是第2个if匹配？答案是，else与第2个if匹配。也就是说，输入的数字和匹配的响应如下：\n1234数字　　　 响应5　　　　 None10　　　　You’re close!15　　　　Sorry, you lose a turn!规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来（见图7.2）。\n\n第1个例子的缩进使得else看上去与第1个if相匹配，但是记住，编译器是忽略缩进的。如果希望else与第1个if匹配，应该这样写：\n1234567if (number &gt; 6)&#123;    if (number &lt; 12)    printf(\"You're close!\\n\");&#125;else\tprintf(\"Sorry, you lose a turn!\\n\");这样改动后，响应如下：\n1234数字　　　 响应5　　　　 Sorry, you lose a turn!10　　　　You’re close!15　　　　None多层嵌套的if语句前面介绍的if...else if...else序列是嵌套if的一种形式，从一系列选项中选择一个执行。有时，选择一个特定选项后又引出其他选择，这种情况可以使用另一种嵌套 if。例如，程序可以使用 if else选择男女，if else的每个分支里又包含另一个if else来区分不同收入的群体。\n我们把这种形式的嵌套if应用在下面的程序中。给定一个整数，显示所有能整除它的约数。如果没有约数，则报告该数是一个素数。\n在编写程序的代码之前要先规划好。首先，要总体设计一下程序。为方便起见，程序应该使用一个循环让用户能连续输入待测试的数。这样，测试一个新的数字时不必每次都要重新运行程序。下面是我们为这种循环开发的一个模型（伪代码）：\n1234提示用户输入数字当scanf()返回值为1分析该数并报告结果提示用户继续输入回忆一下在测试条件中使用scanf()，把读取数字和判断测试条件确定是否结束循环合并在一起。\n下一步，设计如何找出约数。也许最直接的方法是：\n123for (div = 2; div &lt; num; div++)if (num % div == 0)printf(\"%d is divisible by %d\\n\", num, div);该循环检查2～num之间的所有数字，测试它们是否能被num整除。但是，这个方法有点浪费时间。我们可以改进一下。例如，考虑如果144%2得0，说明2是144的约数；如果144除以2得72，那么72也是144的一个约数。所以，num % div测试成功可以获得两个约数。为了弄清其中的原理，我们分析一下循环中得到的成对约数：2和72、2和48、4和36、6和24、8和18、9和16、12和12、16和9、18和8，等等。在得到12和12这对约数后，又开始得到已找到的相同约数（次序相反）。因此，不用循环到143，在达到12以后就可以停止循环。这大大地节省了循环时间！\n分析后发现，必须测试的数只要到num的平方根就可以了，不用到num。对于9这样的数字，不会节约很多时间，但是对于10000这样的数，使用哪一种方法求约数差别很大。不过，我们不用在程序中计算平方根，可以这样编写测试条件：\n123for (div = 2; (div * div) &lt;= num; div++)\tif (num % div == 0)\t\tprintf(\"%d is divisible by %d and %d.\\n\",num, div, num / div);如果num是144，当div = 12时停止循环。如果num是145，当div = 13时停止循环。\n不使用平方根而用这样的测试条件，有两个原因。其一，整数乘法比求平方根快。其二，我们还没有正式介绍平方根函数。\n还要解决两个问题才能准备编程。第1个问题，如果待测试的数是一个完全平方数怎么办？报告144可以被12和12整除显得有点傻。可以使用嵌套if语句测试div是否等于num /div。如果是，程序只打印一个约数：\n12345678910for (div = 2; (div * div) &lt;= num; div++)&#123;    if (num % div == 0)    &#123;        if (div * div != num)        \tprintf(\"%d is divisible by %d and %d.\\n\",num, div, num / div);        else        \tprintf(\"%d is divisible by %d.\\n\", num, div);    &#125;&#125;注意\n从技术角度看，if else语句作为一条单独的语句，不必使用花括号。外层if也是一条单独的语句，也不必使用花括号。但是，当语句太长时，使用花括号能提高代码的可读性，而且还可防止今后在if循环中添加其他语句时忘记加花括号。\n第2个问题，如何知道一个数字是素数？如果num是素数，程序流不会进入if语句。要解决这个问题，可以在外层循环把一个变量设置为某个值（如，1），然后在if语句中把该变量重新设置为0。循环完成后，检查该变量是否是1，如果是，说明没有进入if语句，那么该数就是素数。这样的变量通常称为标记（flag）。\n一直以来，C都习惯用int作为标记的类型，其实新增的_Bool类型更合适。另外，如果在程序中包含了stdbool.h头文件，便可用bool代替_Bool类型，用true和false分别代替1和0。\n程序清单7.5体现了以上分析的思路。为扩大该程序的应用范围，程序用long类型而不是int类型（如果系统不支持_Bool类型，可以把isPrime的类型改为int，并用1和0分别替换程序中的true和false）。\n程序清单7.5 divisors.c程序\n12345678910111213141516171819202122232425262728293031323334// divisors.c -- 使用嵌套if语句显示一个数的约数#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int main(void)&#123;    unsigned long num;　　　　 // 待测试的数    unsigned long div;　　　　 // 可能的约数    bool isPrime;　　　　　　　// 素数标记    printf(\"Please enter an integer for analysis; \");    printf(\"Enter q to quit.\\n\");    while (scanf(\"%lu\", &amp;num) == 1)    &#123;    \tfor (div = 2, isPrime = true; (div * div) &lt;= num; div++)        &#123;            if (num % div == 0)            &#123;                if ((div * div) != num)                    printf(\"%lu is divisible by %lu and %lu.\\n\",                    num, div, num / div);                else                    printf(\"%lu is divisible by %lu.\\n\",                    num, div);                isPrime = false;　 // 该数不是素数            &#125;    \t&#125;        if (isPrime)            printf(\"%lu is prime.\\n\", num);        printf(\"Please enter another integer for analysis; \");        printf(\"Enter q to quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return 0;&#125;注意，该程序在for循环的测试表达式中使用了逗号运算符，这样每次输入新值时都可以把isPrime设置为true。\n下面是该程序的一个输出示例：\n123456789101112131415161718Please enter an integer for analysis; Enter q to quit.123456789123456789 is divisible by 3 and 41152263.123456789 is divisible by 9 and 13717421.123456789 is divisible by 3607 and 34227.123456789 is divisible by 3803 and 32463.123456789 is divisible by 10821 and 11409.Please enter another integer for analysis; Enter q to quit.149149 is prime.Please enter another integer for analysis; Enter q to quit.20132013 is divisible by 3 and 671.2013 is divisible by 11 and 183.2013 is divisible by 33 and 61.Please enter another integer for analysis; Enter q to quit.qBye.该程序会把1认为是素数，其实它不是。下一节将要介绍的逻辑运算符可以排除这种特殊的情况。\n小结：用if语句进行选择\n关键字：if、else\n一般注解：\n下面各形式中，statement可以是一条简单语句或复合语句。表达式为真说明其值是非零值。\n形式1：\n123if (expression)statement如果expression为真，则执行statement部分。形式2：\n12345if (expression)statement1elsestatement2如果expression为真，执行statement1部分；否则，执行statement2部分。形式3：\n123456if (expression1)statement1else if (expression2)statement2elsestatement3如果expression1为真，执行statement1部分；如果expression2为真，执行statement2部分；否则，执行statement3部分。\n示例：\n123456789if (legs == 4)\tprintf(\"It might be a horse.\\n\");else if (legs &gt; 4)\tprintf(\"It is not a horse.\\n\");else　　 /* 如果legs &lt; 4 */&#123;\tlegs++;\tprintf(\"Now it has one more leg.\\n\");&#125;逻辑运算符读者已经很熟悉了，if 语句和 while 语句通常使用关系表达式作为测试条件。有时，把多个关系表达式组合起来会很有用。例如，要编写一个程序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。这种情况下可以使用逻辑运算符，并使用句点（.）标识句子的末尾。程序清单7.6用一个简短的程序进行演示。\n程序清单7.6 chcount.c程序\n12345678910111213141516// chcount.c　-- 使用逻辑与运算符#include &lt;stdio.h&gt;#define PERIOD '.'int main(void)&#123;    char ch;    int charcount = 0;    while((ch = getchar()) != PERIOD)    &#123;        if (ch != '\"' &amp;&amp; ch != '\\'')        \tcharcount++;    &#125;    printf(\"There are %d non-quote characters.\\n\", charcount);    return 0;&#125;下面是该程序的一个输出示例：\n12I didn't read the \"I'm a Programming Fool\" best seller.There are 50 non-quote characters.程序首先读入一个字符，并检查它是否是一个句点，因为句点标志一个句子的结束。接下来，if语句的测试条件中使用了逻辑与运算符&amp;&amp;。该 if 语句翻译成文字是“如果待测试的字符不是双引号，并且它也不是单引号，那么charcount递增1”。\n逻辑运算符两侧的条件必须都为真，整个表达式才为真。逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号。\nC有3种逻辑运算符，见表7.3。\n\n假设exp1和exp2是两个简单的关系表达式（如car &gt; rat或debt == 1000），那么：\n当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真；\n如果exp1或exp2为真，则exp1 || exp2为真；\n如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假。\n下面是一些具体的例子：\n5 &gt; 2 &amp;&amp; 4 &gt; 7为假，因为只有一个子表达式为真；\n5 &gt; 2 || 4 &gt; 7为真，因为有一个子表达式为真；\n!(4 &gt; 7)为真，因为4不大于7。\n顺带一提，最后一个表达式与下面的表达式等价：\n14 &lt;= 7如果不熟悉逻辑运算符或者觉得很别扭，请记住：(练习&amp;&amp;时间)== 完美。\n备选拼写：iso646.h头文件C 是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符的拼写，它们被定义在ios646.h头文件中。如果在程序中包含该头文件，便可用and代替&amp;&amp;、or代替||、not代替!。例如，可以把下面的代码：\n12if (ch != '\"' &amp;&amp; ch != '\\'')charcount++;改写为：\n12if (ch != '\"' and ch != '\\'')charcount++;表7.4列出了逻辑运算符对应的拼写，很容易记。读者也许很好奇，为何C不直接使用and、or和not？因为C一直坚持尽量保持较少的关键字。参考资料V“新增C99和C11的标准ANSI C库”列出了一些运算符的备选拼写，有些我们还没见过。\n优先级\n算数运算符&gt;关系运算符&gt;赋值运算符\n\n!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。因此，表达式a&gt;b &amp;&amp; b&gt;c || b&gt;d相当于((a&gt;b) &amp;&amp; (b&gt;c)) || (b&gt;d)。\n也就是说，b介于a和c之间，或者b大于d。\n尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号的第 2 种写法。这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚。\n求值顺序除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值。例如，下面的语句，可能先对表达式5 + 3求值，也可能先对表达式9 + 6求值：\n1apples = (5 + 3) * (9 + 6);C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计。但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值。正是由于有这些规定，才能写出这样结构的代码：\n1while((c = getchar()) != ' ' &amp;&amp; c != '\\n')如上代码所示，读取字符直至遇到第1 个空格或换行符。第1 个子表达式把读取的值赋给c，后面的子表达式会用到c的值。如果没有求值循序的保证，编译器可能在给c赋值之前先对后面的表达式求值。\n这里还有一个例子：\n12if (number != 0 &amp;&amp; 12/number == 2)\tprintf(\"The number is 5 or 6.\\n\");如果number的值是0，那么第1个子表达式为假，且不再对关系表达式求值。这样避免了把0作为除数。许多语言都没有这种特性，知道number为0后，仍继续检查后面的条件。\n最后，考虑这个例子：\n1while ( x++ &lt; 10 &amp;&amp; x + y &lt; 20)实际上，&amp;&amp;是一个序列点，这保证了在对&amp;&amp;右侧的表达式求值之前，已经递增了x。\n小结：逻辑运算符和表达式\n逻辑运算符：\n逻辑运算符的运算对象通常是关系表达式。!运算符只需要一个运算对象，其他两个逻辑运算符都需要两个运算对象，左侧一个，右侧一个。\n\n逻辑表达式：\n当且仅当expression1和expression2都为真，expression1 &amp;&amp; expression2才为真。如果 expression1 或 expression2 为真，expression1 || expression2 为真。如果expression为假，!expression则为真，反之亦然。\n求值顺序：\n逻辑表达式的求值顺序是从左往右。一旦发现有使整个表达式为假的因素，立即停止求值。\n示例：\n1236 &gt; 2 &amp;&amp; 3 == 3　　　　 真!(6 &gt; 2 &amp;&amp; 3 == 3)　　　假x != 0 &amp;&amp; (20 / x) &lt; 5 只有当x不等于0时，才会对第2个表达式求值范围&amp;&amp;运算符可用于测试范围。例如，要测试score是否在90～100的范围内，可以这样写：\n12if (range &gt;= 90 &amp;&amp; range &lt;= 100)\tprintf(\"Good show!\\n\");千万不要模仿数学上的写法：\n12if (90 &lt;= range &lt;= 100)　　// 千万不要这样写！\tprintf(\"Good show!\\n\");这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕获这样的问题（虽然可能会给出警告）。由于&lt;=运算符的求值顺序是从左往右，所以编译器把测试表达式解释为：\n1(90 &lt;= range) &lt;= 100子表达式90 &lt;= range的值要么是1（为真），要么是0（为假）。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，在范围测试中要使用&amp;&amp;。\n许多代码都用范围测试来确定一个字符是否是小写字母。例如，假设ch是char类型的变量：\n12if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')printf(\"That's a lowercase character.\\n\");该方法仅对于像ASCII这样的字符编码有效，这些编码中相邻字母与相邻数字一一对应。但是，对于像EBCDIC这样的代码就没用了。相应的可移植方法是，用ctype.h系列中的islower()函数（参见表7.1）：\n12if (islower(ch))printf(\"That's a lowercase character.\\n\");无论使用哪种特定的字符编码，islower()函数都能正常运行（不过，一些早期的编译器没有ctype.h系列）。\n一个统计单词的程序现在，我们可以编写一个统计单词数量的程序（即，该程序读取并报告单词的数量）。该程序还可以计算字符数和行数。先来看看编写这样的程序要涉及那些内容。\n首先，该程序要逐个字符读取输入，知道何时停止读取。然后，该程序能识别并计算这些内容：字符、行数和单词。据此我们编写的伪代码如下：\n1234567891011读取一个字符当有更多输入时递增字符计数如果读完一行，递增行数计数如果读完一个单词，递增单词计数读取下一个字符前面有一个输入循环的模型：while ((ch = getchar()) != STOP)&#123;...&#125;这里，STOP表示能标识输入末尾的某个值。以前我们用过换行符和句点标记输入的末尾，但是对于一个通用的统计单词程序，它们都不合适。我们暂时选用一个文本中不常用的字符（如，|）作为输入的末尾标记。第8章中会介绍更好的方法，以便程序既能处理文本文件，又能处理键盘输入。\n现在，我们考虑循环体。因为该程序使用getchar()进行输入，所以每次迭代都要通过递增计数器来计数。为了统计行数，程序要能检查换行字符。如果输入的字符是一个换行符，该程序应该递增行数计数器。这里要注意 STOP 字符位于一行的中间的情况。是否递增行数计数？我们可以作为特殊行计数，即没有换行符的一行字符。可以通过记录之前读取的字符识别这种情况，即如果读取时发现 STOP 字符的上一个字符不是换行符，那么这行就是特殊行。\n最棘手的部分是识别单词。首先，必须定义什么是该程序识别的单词。我们用一个相对简单的方法，把一个单词定义为一个不含空白（即，没有空格、制表符或换行符）的字符序列。因此，“glymxck”和“r2d2”都算是一个单词。程序读取的第 1 个非空白字符即是一个单词的开始，当读到空白字符时结束。判断非空白字符最直接的测试表达式是：\n1c != ' ' &amp;&amp; c != '\\n' &amp;&amp; c != '\\t' /* 如果c不是空白字符，该表达式为真*/检测空白字符最直接的测试表达式是：\n1c == ' ' || c == '\\n' || c == '\\t' /*如果c是空白字符，该表达式为真*/然而，使用ctype.h头文件中的函数isspace()更简单，如果该函数的参数是空白字符，则返回真。所以，如果c是空白字符，isspace(c)为真；如果c不是空白字符，!isspace(c)为真。\n要查找一个单词里是否有某个字符，可以在程序读入单词的首字符时把一个标记（名为 inword）设置为1。也可以在此时递增单词计数。然后，只要inword为1（或true），后续的非空白字符都不记为单词的开始。下一个空白字符，必须重置标记为0（或false），然后程序就准备好读取下一个单词。我们把以上分析写成伪代码：\n1234如果c不是空白字符，且inword为假设置inword为真，并给单词计数如果c是空白字符，且inword为真设置inword为假这种方法在读到每个单词的开头时把inword设置为1（真），在读到每个单词的末尾时把inword设置为0（假）。只有在标记从0设置为1时，递增单词计数。如果能使用_Bool类型，可以在程序中包含stdbool.h头文件，把inword的类型设置为bool，其值用true和false表示。如果编译器不支持这种用法，就把inword的类型设置为int，其值用1和0表示。\n如果使用布尔类型的变量，通常习惯把变量自身作为测试条件。如下所示：\n12用if (inword)代替if (inword == true)用if (!inword)代替if (inword == false)可以这样做的原因是，如果 inword为true，则表达式 inword == true为true；如果 inword为false，则表达式inword == true为false。所以，还不如直接用inword作为测试条件。类似地，!inword的值与表达式inword == false的值相同（非真即false，非假即true）。\n程序清单7.7把上述思路（识别行、识别不完整的行和识别单词）翻译了成C代码。\n程序清单7.7 wordcnt.c程序\n1234567891011121314151617181920212223242526272829303132333435363738// wordcnt.c -- 统计字符数、单词数、行数#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;　　　　 // 为isspace()函数提供原型#include &lt;stdbool.h&gt;　　　 // 为bool、true、false提供定义#define STOP '|'int main(void)&#123;    char c;　　　　　　　　// 读入字符    char prev;　　　　　　 // 读入的前一个字符    long n_chars = 0L;// 字符数    int n_lines = 0;　　　 // 行数    int n_words = 0;　　　 // 单词数    int p_lines = 0;　　　 // 不完整的行数    bool inword = false;　 // 如果c在单词中，inword 等于 true    printf(\"Enter text to be analyzed (| to terminate):\\n\");    prev = '\\n';　　　　　 // 用于识别完整的行    while ((c = getchar()) != STOP)    &#123;        n_chars++;　　　　 // 统计字符        if (c == '\\n')        \tn_lines++;　　 // 统计行        if (!isspace(c) &amp;&amp; !inword)        &#123;            inword = true;// 开始一个新的单词            n_words++;　　 // 统计单词    \t&#125;        if (isspace(c) &amp;&amp; inword)\t\t\tinword = false;　　// 打到单词的末尾        prev = c;　　　　　// 保存字符的值    &#125;    if (prev != '\\n')\t\tp_lines = 1;    printf(\"characters = %ld, words = %d, lines = %d, \",    n_chars, n_words, n_lines);    printf(\"partial lines = %d\\n\", p_lines);    return 0;&#125;下面是运行该程序后的一个输出示例：\n123456Enter text to be analyzed (| to terminate):Reason is apowerful servant butan inadequate master.|characters = 55, words = 9, lines = 3, partial lines = 0该程序使用逻辑运算符把伪代码翻译成C代码。例如，把下面的伪代码：\n如果c不是空白字符，且inword为假\n翻译成如下C代码：\n1if (!isspace(c) &amp;&amp;!inword)再次提醒读者注意，!inword 与 inword == false 等价。上面的整个测试条件比单独判断每个空白字符的可读性高：\n1if (c != ' ' &amp;&amp; c != '\\n' &amp;&amp; c != '\\t' &amp;&amp; !inword)上面的两种形式都表示“如果c不是空白字符，且如果c不在单词里”。如果两个条件都满足，则一定是一个新单词的开头，所以要递增n_words。如果位于单词中，满足第1个条件，但是inword为true，就不递增 n_word。当读到下一个空白字符时，inword 被再次设置为 false。检查代码，查看一下如果单词之间有多个空格时，程序是否能正常运行。第 8 章讲解了如何修正这个问题，让该程序能统计文件中的单词量。\n条件运算符：?:C提供条件表达式（conditional expression）作为表达if else语句的一种便捷方式，该表达式使用?:条件运算符。该运算符分为两部分，需要 3 个运算对象。回忆一下，带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符。以此类推，带 3 个运算对象的运算符称为三元运算符。条件运算符是C语言中唯一的三元运算符。下面的代码得到一个数的绝对值：\n1x = (y &lt; 0) ? -y : y;在=和;之间的内容就是条件表达式，该语句的意思是“如果y小于0，那么x = -y;否则，x = y”。用if else可以这样表达：\n1234if (y &lt; 0)\tx = -y;else\tx = y;条件表达式的通用形式如下：\n1expression1 ? expression2 : expression3如果 expression1 为真（非 0），那么整个条件表达式的值与 expression2 的值相同；如果expression1为假（0），那么整个条件表达式的值与expression3的值相同。\n需要把两个值中的一个赋给变量时，就可以用条件表达式。典型的例子是，把两个值中的最大值赋给变量：\n1max = (a &gt; b) ? a : b;如果a大于b，那么将max设置为a；否则，设置为b。\n通常，条件运算符完成的任务用 if else 语句也可以完成。但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码。\n我们来看程序清单7.8中的油漆程序，该程序计算刷给定平方英尺的面积需要多少罐油漆。基本算法很简单：用平方英尺数除以每罐油漆能刷的面积。但是，商店只卖整罐油漆，不会拆分来卖，所以如果计算结果是1.7罐，就需要两罐。因此，该程序计算得到带小数的结果时应该进1。条件运算符常用于处理这种情况，而且还要根据单复数分别打印can和cans。\n程序清单7.8 paint.c程序\n12345678910111213141516171819/* paint.c -- 使用条件运算符 */#include &lt;stdio.h&gt;#define COVERAGE 350　　　// 每罐油漆可刷的面积（单位：平方英尺）int main(void)&#123;    int sq_feet;    int cans;    printf(\"Enter number of square feet to be painted:\\n\");    while (scanf(\"%d\", &amp;sq_feet) == 1)    &#123;        cans = sq_feet / COVERAGE;        cans += ((sq_feet % COVERAGE == 0)) ? 0 : 1;        printf(\"You need %d %s of paint.\\n\", cans,        cans == 1 ? \"can\" : \"cans\");        printf(\"Enter next value (q to quit):\\n\");    &#125;    return 0;&#125;下面是该程序的运行示例：\n12345678Enter number of square feet to be painted:349You need 1 can of paint.Enter next value (q to quit):351You need 2 cans of paint.Enter next value (q to quit):q该程序使用的变量都是int类型，除法的计算结果（sq_feet / COVERAGE）会被截断。也就是说， 351/350得1。所以，cans被截断成整数部分。如果sq_feet % COVERAGE得0，说明sq_feet被COVERAGE整除，cans的值不变；否则，肯定有余数，就要给cans加1。这由下面的语句完成：\n1cans += ((sq_feet % COVERAGE == 0)) ? 0 : 1;该语句把+=右侧表达式的值加上cans，再赋给cans。右侧表达式是一个条件表达式，根据sq_feet是否能被COVERAGE整除，其值为0或1。\nprintf()函数中的参数也是一个条件表达式：\n1cans == 1 ? \"can\" : \"cans\");如果cans的值是1，则打印can；否则，打印cans。这也说明了条件运算符的第2个和第3个运算对象可以是字符串。\n小结：条件运算符\n条件运算符：?:\n一般注解：\n条件运算符需要3个运算对象，每个运算对象都是一个表达式。其通用形式如下：\n1expression1 ? expression2 : expression3如果expression1为真，整个条件表达式的值是expression2的值；否则，是expression3的值。\n示例：\n123(5 &gt; 3) ? 1 : 2 值为1(3 &gt; 5) ? 1 : 2 值为2(a &gt; b) ? a : b 如果a &gt;b，则取较大的值循环辅助：continue和break一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句。continue 和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环。\ncontinue语句3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。程序清单7.9中的简短程序演示了如何使用continue。\n程序清单7.9 skippart.c程序\n123456789101112131415161718192021222324252627282930313233343536/* skippart.c -- 使用continue跳过部分循环 */#include &lt;stdio.h&gt;int main(void)&#123;    const float MIN = 0.0f;    const float MAX = 100.0f;    float score;    float total = 0.0f;    int n = 0;    float min = MAX;    float max = MIN;    printf(\"Enter the first score (q to quit): \");    while (scanf(\"%f\", &amp;score) == 1)    &#123;        if (score &lt; MIN || score &gt; MAX)        &#123;            printf(\"%0.1f is an invalid value.Try again: \",score);            continue;　 // 跳转至while循环的测试条件    \t&#125;        printf(\"Accepting %0.1f:\\n\", score);        min = (score &lt; min) ? score : min;        max = (score &gt; max) ? score : max;        total += score;        n++;        printf(\"Enter next score (q to quit): \");    &#125;    if (n &gt; 0)    &#123;        printf(\"Average of %d scores is %0.1f.\\n\", n, total / n);        printf(\"Low = %0.1f, high = %0.1f\\n\", min, max);    &#125;    else\t\tprintf(\"No valid scores were entered.\\n\");    return 0;&#125;在程序清单7.9中，while循环读取输入，直至用户输入非数值数据。循环中的if语句筛选出无效的分数。假设输入 188，程序会报告：188 is an invalid value。在本例中，continue 语句让程序跳过处理有效输入部分的代码。程序开始下一轮循环，准备读取下一个输入值。\n注意，有两种方法可以避免使用continue，一是省略continue，把剩余部分放在一个else块中：\n123456if (score &lt; 0 || score &gt; 100)\t/* printf()语句 */else&#123;\t/* 语句*/&#125;另一种方法是，用以下格式来代替：\n1234if (score &gt;= 0 &amp;&amp; score &lt;= 100)&#123;/* 语句 */&#125;这种情况下，使用continue的好处是减少主语句组中的一级缩进。当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性。\ncontinue还可用作占位符。例如，下面的循环读取并丢弃输入的数据，直至读到行末尾：\n12while (getchar() != '\\n');当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便。问题是，一般很难注意到一个单独的分号。如果使用continue，可读性会更高：\n12while (getchar() != '\\n')continue;如果用了continue没有简化代码反而让代码更复杂，就不要使用continue。例如，考虑下面的程序段：\n123456while ((ch = getchar() ) != '\\n')&#123;    if (ch == '\\t')\t\tcontinue;    putchar(ch);&#125;该循环跳过制表符，并在读到换行符时退出循环。以上代码这样表示更简洁：\n123while ((ch = getchar()) != '\\n')if (ch != '\\t')putchar(ch);通常，在这种情况下，把if的测试条件的关系反过来便可避免使用continue。\n以上介绍了continue语句让程序跳过循环体的余下部分。那么，从何处开始继续循环？对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值。考虑下面的循环：\n123456789count = 0;while (count &lt; 10)&#123;    ch = getchar();    if (ch == '\\n')\t\tcontinue;    putchar(ch);    count++;&#125;该循环读取10个字符（除换行符外，因为当ch是换行符时，程序会跳过count++;语句）并重新显示它们，其中不包括换行符。执行continue后，下一个被求值的表达式是循环测试条件。\n对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。例如，考虑下面的循环：\n1234567for (count = 0; count &lt; 10; count++)&#123;    ch = getchar();    if (ch == '\\n')\t\tcontinue;    putchar(ch);&#125;该例中，执行完continue后，首先递增count，然后将递增后的值和10作比较。因此，该循环与上面while循环的例子稍有不同。while循环的例子中，除了换行符，其余字符都显示；而本例中，换行符也计算在内，所以读取的10个字符中包含换行符。\nbreak语句程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。把程序清单7.9中的continue替换成break，在输入188时，不是跳至执行下一轮循环，而是导致退出当前循环。图7.3比较了break和continue。如果break语句位于嵌套循环内，它只会影响包含它的当前循环。\n\nbreak还可用于因其他原因退出循环的情况。程序清单7.10用一个循环计算矩形的面积。如果用户输入非数字作为矩形的长或宽，则终止循环。\n程序清单7.10 break.c程序\n1234567891011121314151617181920/* break.c -- 使用 break 退出循环 */#include &lt;stdio.h&gt;int main(void)&#123;    float length, width;    printf(\"Enter the length of the rectangle:\\n\");    while (scanf(\"%f\", &amp;length) == 1)    &#123;        printf(\"Length = %0.2f:\\n\", length);        printf(\"Enter its width:\\n\");        if (scanf(\"%f\", &amp;width) != 1)        \tbreak;        printf(\"Width = %0.2f:\\n\", width);        printf(\"Area = %0.2f:\\n\", length * width);        printf(\"Enter the length of the rectangle:\\n\");    &#125;    printf(\"Done.\\n\");    return 0;&#125;可以这样控制循环：\n1while (scanf(\"%f %f\", &amp;length, &amp;width) == 2)但是，用break可以方便显示用户输入的值。\n和continue一样，如果用了break代码反而更复杂，就不要使用break。例如，考虑下面的循环：\n123456while ((ch = getchar()) != '\\n')&#123;    if (ch == '\\t')        break;    putchar(ch);&#125;如果把两个测试条件放在一起，逻辑就更清晰了：\n12while ((ch = getchar() ) != '\\n' &amp;&amp; ch != '\\t')\tputchar(ch);break语句对于稍后讨论的switch语句而言至关重要。\n在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过。嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break：\n1234567891011121314151617int p, q;scanf(\"%d\", &amp;p);while (p &gt; 0)&#123;    printf(\"%d\\n\", p);    scanf(\"%d\", &amp;q);    while (q &gt; 0)    &#123;        printf(\"%d\\n\", p*q);        if (q &gt; 100)\t\t\tbreak; // 跳出内层循环        scanf(\"%d\", &amp;q);    &#125;    if (q &gt; 100)  \t  break; // 跳出外层循环    scanf(\"%d\", &amp;p);&#125;多重选择：switch和break使用条件运算符和 if else 语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else  if...else来完成。但是，大多数情况下使用switch语句更方便。程序清单7.11演示了如何使用switch语句。该程序读入一个字母，然后打印出与该字母开头的动物名。\n程序清单7.11 animals.c程序\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* animals.c -- 使用switch语句 */#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main(void)&#123;    char ch;    printf(\"Give me a letter of the alphabet, and I will give \");    printf(\"an animal name\\nbeginning with that letter.\\n\");    printf(\"Please type in a letter; type # to end my act.\\n\");    while ((ch = getchar()) != '#')    &#123;        if ('\\n' == ch)        \tcontinue;        if (islower(ch))　　/* 只接受小写字母*/            switch (ch)            &#123;                case 'a':                \tprintf(\"argali, a wild sheep of Asia\\n\");                \tbreak;                case 'b':                \tprintf(\"babirusa, a wild pig of Malay\\n\");                \tbreak;                case 'c':                \tprintf(\"coati, racoonlike mammal\\n\");                \tbreak;                case 'd':                \tprintf(\"desman, aquatic, molelike critter\\n\");               \t\tbreak;                case 'e':                \tprintf(\"echidna, the spiny anteater\\n\");                \tbreak;                case 'f':                \tprintf(\"fisher, brownish marten\\n\");                \tbreak;                default:                \tprintf(\"That's a stumper!\\n\");            &#125;　　　　　　　　/* switch结束　　　　*/        else        \tprintf(\"I recognize only lowercase letters.\\n\");        while (getchar() != '\\n')        \tcontinue;　　 /* 跳过输入行的剩余部分　*/        printf(\"Please type another letter or a #.\\n\");    &#125;　　　　　　　　　 /* while循环结束　　　*/    printf(\"Bye!\\n\");    return 0;&#125;篇幅有限，我们只编到f，后面的字母以此类推。在进一步解释该程序之前，先看看输出示例：\n1234567891011121314151617Give me a letter of the alphabet, and I will give an animal namebeginning with that letter.Please type in a letter; type # to end my act.a [enter]argali, a wild sheep of AsiaPlease type another letter or a #.dab [enter]desman, aquatic, molelike critterPlease type another letter or a #.r [enter]That's a stumper!Please type another letter or a #.Q [enter]I recognize only lowercase letters.Please type another letter or a #.# [enter]Bye!该程序的两个主要特点是：使用了switch语句和它对输出的处理。我们先分析switch的工作原理。\nswitch语句要对紧跟在关键字 switch 后圆括号中的表达式求值。在程序清单 7.11 中，该表达式是刚输入给 ch的值。然后程序扫描标签（这里指，case &#39;a&#39; :、case &#39;b&#39; :等）列表，直到发现一个匹配的值为止。然后程序跳转至那一行。如果没有匹配的标签怎么办？如果有default :标签行，就跳转至该行；否则，程序继续执行在switch后面的语句。\nbreak语句在其中起什么作用？它让程序离开switch语句，跳至switch语句后面的下一条语句（见图7.4）。如果没有break语句，就会从匹配标签开始执行到switch末尾。例如，如果删除该程序中的所有break语句，运行程序后输入d，其交互的输出结果如下：\n\n1234567891011Give me a letter of the alphabet, and I will give an animal namebeginning with that letter.Please type in a letter; type # to end my act.d [enter]desman, aquatic, molelike critterechidna, the spiny anteaterfisher, a brownish martenThat's a stumper!Please type another letter or a #.\\# [enter]Bye!如上所示，执行了从case &#39;d&#39;:到switch语句末尾的所有语句。\n顺带一提，break语句可用于循环和switch语句中，但是continue只能用于循环中。尽管如此，如果switch语句在一个循环中，continue便可作为switch语句的一部分。这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分。\n如果读者熟悉Pascal，会发现switch语句和Pascal的case语句类似。它们最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句中使用break语句。另外，C语言的case一般都指定一个值，不能使用一个范围。\nswitch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。不能用变量作为case标签。switch的构造如下：\n123456789switch ( 整型表达式)&#123;    case 常量1:    \t语句　　　&lt;--可选    case 常量2:    \t语句　　　&lt;--可选    default :　　 &lt;--可选    \t语句　　　&lt;--可选&#125;只读每行的首字符animals.c（程序清单7.11）的另一个独特之处是它读取输入的方式。运行程序时读者可能注意到了，当输入dab时，只处理了第1个字符。这种丢弃一行中其他字符的行为，经常出现在响应单字符的交互程序中。可以用下面的代码实现这样的行为：\n12while (getchar() != '\\n')\tcontinue;　　　　/* 跳过输入行的其余部分 */循环从输入中读取字符，包括按下Enter键产生的换行符。注意，函数的返回值并没有赋给ch，以上代码所做的只是读取并丢弃字符。由于最后丢弃的字符是换行符，所以下一个被读取的字符是下一行的首字母。在外层的while循环中，getchar()读取首字母并赋给ch。\n假设用户一开始就按下Enter键，那么程序读到的首个字符就是换行符。下面的代码处理这种情况：\n12if (ch == '\\n')\tcontinue;多重标签如程序清单7.12所示，可以在switch语句中使用多重case标签。\n123456789101112131415161718192021222324252627282930313233343536程序清单7.12 vowels.c程序// vowels.c -- 使用多重标签#include &lt;stdio.h&gt;int main(void)&#123;    char ch;    int a_ct, e_ct, i_ct, o_ct, u_ct;    a_ct = e_ct = i_ct = o_ct = u_ct = 0;    printf(\"Enter some text; enter # to quit.\\n\");    while ((ch = getchar()) != '#')    &#123;        switch (ch)        &#123;            case 'a':            case 'A':　a_ct++;            \tbreak;            case 'e':            case 'E':　e_ct++;            \tbreak;            case 'i':            case 'I':　i_ct++;            \tbreak;            case 'o':            case 'O':　o_ct++;            \tbreak;            case 'u':            case 'U':　u_ct++;            \tbreak;            default:　 break;        &#125;　　　　　　　　　// switch结束    &#125;　　　　　　　　　　　 // while循环结束    printf(\"number of vowels:　 A　 E　 I　 O　 U\\n\");    printf(\"%4d %4d %4d %4d %4d\\n\",a_ct, e_ct, i_ct, o_ct, u_ct);    return 0;&#125;假设如果ch是字母i，switch语句会定位到标签为case &#39;i&#39; :的位置。由于该标签没有关联break语句，所以程序流直接执行下一条语句，即i_ct++;。如果 ch是字母I，程序流会直接定位到case &#39;I&#39; :。本质上，两个标签都指的是相同的语句。\n严格地说，case &#39;U&#39;的 break 语句并不需要。因为即使删除这条 break 语句，程序流会接着执行switch中的下一条语句，即default : break;。所以，可以把case &#39;U&#39;的break语句去掉以缩短代码。但是从另一方面看，保留这条break语句可以防止以后在添加新的case（例如，把y作为元音）时遗漏break语句。\n下面是该程序的运行示例：\n1234Enter some text; enter # to quit.I see under the overseer.#number of vowels:　　 A　 E　 I　 O　 U0　　7　 1　 1　 1在该例中，如果使用ctype.h系列的toupper()函数（参见表7.2）可以避免使用多重标签，在进行测试之前就把字母转换成大写字母：\n123456789101112131415161718while ((ch = getchar()) != '#')&#123;    ch = toupper(ch);    switch (ch)    &#123;        case 'A': a_ct++;        \tbreak;        case 'E': e_ct++;        \tbreak;        case 'I': i_ct++;        \tbreak;        case 'O': o_ct++;        \tbreak;        case 'U': u_ct++;        \tbreak;        default: break;    &#125; // switch结束&#125; // while循环结束或者，也可以先不转换ch，把toupper(ch)放进switch的测试条件中：switch(toupper(ch))。\n小结：带多重选择的switch语句\n关键字：switch\n一般注解：\n程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果有的话）；否则，将转至执行紧跟在switch语句后面的语句。\n形式：\n123456switch ( expression )&#123;    case label1 : statement1//使用break跳出switch    case label2 : statement2    default　　 : statement3&#125;可以有多个标签语句，default语句可选。\n示例：\n12345678switch (choice)&#123;    case 1 :    case 2 : printf(\"Darn tootin'!\\n\"); break;    case 3 : printf(\"Quite right!\\n\");    case 4 : printf(\"Good show!\\n\"); break;    default: printf(\"Have a nice day.\\n\");&#125;如果choice的值是1或2，打印第1条消息；如果choice的值是3，打印第2条和第3条消息（程序继续执行后续的语句，因为case 3后面没有break语句）；如果choice的值是4，则打印第3条消息；如果choice的值是其他值只打印最后一条消息。\nswitch和if else何时使用switch？何时使用if else？你经常会别无选择。如果是根据浮点类型的变量或表达式来选择，就无法使用 switch。如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦，这种情况用if就很方便：\n1if (integer &lt; 1000 &amp;&amp; integer &gt; 2)使用switch要涵盖以上范围，需要为每个整数（3～999）设置case标签。但是，如果使用switch，程序通常运行快一些，生成的代码少一些。\ngoto语句早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用。但是C和其他两种语言不同，没有goto语句C程序也能运行良好。Kernighan和Ritchie提到goto语句“易被滥用”，并建议“谨慎使用，或者根本不用”。首先，介绍一下如何使用goto语句；然后，讲解为什么通常不需要它。\ngoto语句有两部分：goto和标签名。标签的命名遵循变量命名规则，如下所示：\n1goto part2;要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句以标签名后紧跟一个冒号开始：\n1part2: printf(\"Refined analysis:\\n\");避免使用goto原则上，根本不用在C程序中使用goto语句。但是，如果你曾经学过FORTRAN或BASIC（goto对这两种语言而言都必不可少），可能还会依赖用goto来编程。为了帮助你克服这个习惯，我们先概述一些使用goto的常见情况，然后再介绍C的解决方案。\n处理包含多条语句的if语句：\n123456if (size &gt; 12)\tgoto a;goto b;a: cost = cost * 1.05;flag = 2;b: bill = cost * flag;对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才属于if，不能使用块或复合语句。我们把以上模式转换成等价的C代码，标准C用复合语句或块来处理这种情况：\n123456if (size &gt; 12)&#123;    cost = cost * 1.05;    flag = 2;&#125;bill = cost * flag;二选一：\n123456if (ibex &gt; 14)\tgoto a;sheds = 2;goto b;a: sheds= 3;b: help = 2 * sheds;C通过if else表达二选一更清楚：\n12345if (ibex &gt; 14)sheds = 3;elsesheds = 2;help = 2 * sheds;实际上，新版的BASIC和FORTRAN已经把else纳入新的语法中。\n创建不确定循环：\n123456readin: scanf(\"%d\", &amp;score);if (score &lt; O)\tgoto stage2;lots of statementsgoto readin;stage2: more stuff;C用while循环代替：\n1234567scanf(\"%d\", &amp;score);while (score &lt;= 0)&#123;    lots of statements    scanf(\"%d\", &amp;score);&#125;more stuff;跳转至循环末尾，并开始下一轮迭代。C使用continue语句代替。\n跳出循环。C使用break语句。实际上，break和continue是goto的特殊形式。使用break和 continue 的好处是：其名称已经表明它们的用法，而且这些语句不使用标签，所以不用担心把标签放错位置导致的危险。\n胡乱跳转至程序的不同部分。简而言之，不要这样做！\n但是，C程序员可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出（一条break语句只能跳出当前循环）：\n1234567891011121314151617while (funct &gt; 0)&#123;    for (i = 1, i &lt;= 100; i++)    &#123;        for (j = 1; j &lt;= 50; j++)        &#123;            其他语句            if (问题)            goto help;        \t其他语句        &#125;        其他语句    &#125;    其他语句&#125;其他语句help: 语句从其他例子中也能看出，程序中使用其他形式比使用goto的条理更清晰。当多种情况混在一起时，这种差异更加明显。哪些goto语句可以帮助if语句？哪些可以模仿if else？哪些控制循环？哪些是因为程序无路可走才不得已放在那里？过度地使用 goto 语句，会让程序错综复杂。如果不熟悉goto语句，就不要使用它。如果已经习惯使用goto语句，试着改掉这个毛病。讽刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用，因为C允许在标签中使用描述性的单词而不是数字。\n小结：程序跳转\n关键字：break、continue、goto\n一般注解：\n这3种语句都能使程序流从程序的一处跳转至另一处。\nbreak语句：\n所有的循环和switch语句都可以使用break语句。它使程序控制跳出当前循环或switch语句的剩余部分，并继续执行跟在循环或switch后面的语句。\n示例：\n12345678switch (number)&#123;    case 4: printf(\"That's a good choice.\\n\");    \tbreak;    case 5: printf(\"That's a fair choice.\\n\");    \tbreak;    default: printf(\"That's a poor choice.\\n\");&#125;continue语句：\n所有的循环都可以使用continue语句，但是switch语句不行。continue语句使程序控制跳出循环的剩余部分。对于while或for循环，程序执行到continue语句后会开始进入下一轮迭代。对于do while循环，对出口条件求值后，如有必要会进入下一轮迭代。\n示例：\n1234567while ((ch = getchar()) != '\\n')&#123;    if (ch == ' ')    \tcontinue;    putchar(ch);    chcount++;&#125;以上程序段把用户输入的字符再次显示在屏幕上，并统计非空格字符。\ngoto语句：\ngoto语句使程序控制跳转至相应标签语句。冒号用于分隔标签和标签语句。标签名遵循变量命名规则。标签语句可以出现在goto的前面或后面。\n形式：\n12goto label;label: statement示例：\n123top: ch=getchar();if (ch!='y')goto top;关键概念智能的一个方面是，根据情况做出相应的响应。所以，选择语句是开发具有智能行为程序的基础。C语言通过if、if else和switch语句，以及条件运算符（?:）可以实现智能选择。\nif 和 if else 语句使用测试条件来判断执行哪些语句。所有非零值都被视为 true，零被视为false。测试通常涉及关系表达式（比较两个值）、逻辑表达式（用逻辑运算符组合或更改其他表达式）。\n要记住一个通用原则，如果要测试两个条件，应该使用逻辑运算符把两个完整的测试表达式组合起来。例如，下面这些是错误的：\n1234if (a &lt; x &lt; z)　　　　　　 // 错误，没有使用逻辑运算符…if (ch != 'q' &amp;&amp; != 'Q')　 // 错误，缺少完整的测试表达式…正确的方式是用逻辑运算符连接两个关系表达式：\n1234if (a &lt; x &amp;&amp; x &lt; z)　　　　　　 // 使用&amp;&amp;组合两个表达式…if (ch != 'q' &amp;&amp; ch != 'Q')　　// 使用&amp;&amp;组合两个表达式…对比这两章和前几章的程序示例可以发现：使用第6章、第7章介绍的语句，可以写出功能更强大、更有趣的程序。\n本章小结本章介绍了很多内容，我们来总结一下。if语句使用测试条件控制程序是否执行测试条件后面的一条简单语句或复合语句。如果测试表达式的值是非零值，则执行语句；如果测试表达式的值是零，则不执行语句。if else语句可用于二选一的情况。如果测试条件是非零，则执行else前面的语句；如果测试表达式的值是零，则执行else后面的语句。在else后面使用另一个if语句形成else if，可构造多选一的结构。\n测试条件通常都是关系表达式，即用一个关系运算符（如，&lt;或==）的表达式。使用C的逻辑运算符，可以把关系表达式组合成更复杂的测试条件。\n在多数情况下，用条件运算符（?:）写成的表达式比if else语句更简洁。\nctype.h系列的字符函数（如，issapce()和isalpha()）为创建以分类字符为基础的测试表达式提供了便捷的工具。\nswitch 语句可以在一系列以整数作为标签的语句中进行选择。如果紧跟在 switch 关键字后的测试条件的整数值与某标签匹配，程序就转至执行匹配的标签语句，然后在遇到break之前，继续执行标签语句后面的语句。\nbreak、continue和goto语句都是跳转语句，使程序流跳转至程序的另一处。break语句使程序跳转至紧跟在包含break语句的循环或switch末尾的下一条语句。continue语句使程序跳出当前循环的剩余部分，并开始下一轮迭代。\n","plink":"https://dxsummer.gitee.io/posts/3e5d0fae/"},{"title":"emoji符号大全","date":"2020-06-05T04:14:30.000Z","date_formatted":{"ll":"2020年6月5日","L":"2020/06/05","MM-DD":"06-05"},"updated":"2020-06-08T01:55:22.313Z","content":"\nemoji符号大全\n\n🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥\n\nemoji表情(非图片可复制)\n\n😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫\n\n😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠\n\nemoji人物(非图片可复制)\n\n👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋\n\n🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪\n\nemoji手势(非图片可复制)\n\n💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍\n\nemoji日常(非图片可复制)\n\n👣👀👂👃👅👄💋👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂\n\nemoji手机(非图片可复制)\n\n📱📲📶📳📴☎📞📟📠\n\nemoji公共(非图片可复制)\n\n♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞💈\n\nemoji动物(非图片可复制)\n\n🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃\n\n🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸\n\n🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋\n\nemoji植物(非图片可复制)\n\n💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃\n\nemoji自然(非图片可复制)\n\n🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊\n\nemoji饮食(非图片可复制)\n\n🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚\n\n🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴\n\nemoji文体(非图片可复制)\n\n🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬\n\nemoji恐怖(非图片可复制)\n\n😈👿👹👺💀☠👻👽👾💣\n\nemoji旅游(非图片可复制)\n\n🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢\n\n🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥\n\n🚦🚧⚓⛵🚤🚢✈💺🚁🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅\n\nemoji物品(非图片可复制)\n\n💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀\n\n🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉\n\n📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨\n\n🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨\n\nemoji标志(非图片可复制)\n\n♠♥♦♣🀄🎴🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑✔✖❌❎➕➖➗➰➿〽✳\n\n✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿🆘🆙🆚🈁🈂\n\n🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵\n\nemoji生肖(非图片可复制)\n\n🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖\n\nemoji星座(非图片可复制)\n\n♈♉♊♋♌♍♎♏♐♑♒♓⛎\n\nemoji钟表(非图片可复制)\n\n🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦⌛⏳⌚⏰⏱⏲🕰\n\nemoji心形(非图片可复制)\n\n💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣\n\nemoji花草(非图片可复制)\n\n💐🌸💮🌹🌺🌻🌼🌷🌱🌿🍀\n\nemoji树叶(非图片可复制)\n\n🌿🍀🍁🍂🍃\n\nemoji月亮(非图片可复制)\n\n🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝\n\nemoji水果(非图片可复制)\n\n🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓\n\nemoji钱币(非图片可复制)\n\n💴💵💶💷💰💸💳\n\nemoji交通(非图片可复制)\n\n🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽\n\n🚨🚥🚦🚧⚓⛵🚣🚤🚢✈💺🚁🚟🚠🚡🚀\n\nemoji建筑(非图片可复制)\n\n🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🌆🌇🌉\n\nemoji办公(非图片可复制)\n\n📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡📔📕📖📗📘📙📚📓📃📜📄📰📑\n\n🔖💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑\n\nemoji箭头(非图片可复制)\n\n⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝\n","plink":"https://dxsummer.gitee.io/posts/e193db5d/"},{"title":"疫情期间基层党员如何发挥先锋模范作用","date":"2020-06-03T08:01:38.000Z","date_formatted":{"ll":"2020年6月3日","L":"2020/06/03","MM-DD":"06-03"},"updated":"2020-06-08T01:55:56.782Z","content":"参与调查问卷 即可参与抽奖，领取一下其一🍎微信10元红包\n🍖微信20元红包\n🍼安慕希酸奶6瓶\n🍬200元中小学名师课\n🍺感谢参与\n","plink":"https://dxsummer.gitee.io/posts/91d5787c/"},{"title":"Step4 C控制语句：循环","date":"2020-06-03T04:33:48.000Z","date_formatted":{"ll":"2020年6月3日","L":"2020/06/03","MM-DD":"06-03"},"updated":"2020-06-08T01:44:33.693Z","content":"C控制语句：循环本章介绍以下内容：\n关键字：for、while、do while\n运算符：&lt;、&gt;、&gt;=、&lt;=、!=、==、+=、*=、-=、/=、%=\n函数：fabs()\nC语言有3种循环：for、while、do while\n使用关系运算符构建控制循环的表达式\n其他运算符\n循环常用的数组\n编写有返回值的函数\n大多数人都希望自己是体格强健、天资聪颖、多才多艺的能人。虽然有时事与愿违，但至少我们用 C能写出这样的程序。诀窍是控制程序流。对于计算机科学（是研究计算机，不是用计算机做研究）而言，一门语言应该提供以下3种形式的程序流：\n执行语句序列；\n如果满足某些条件就重复执行语句序列（循环通过测试选择执行哪一个语句序列（分支）。\n读者对第一种形式应该很熟悉，前面学过的程序中大部分都是由语句序列组成。while循环属于第二种形式。本章将详细讲解while循环和其他两种循环：for和do while。第三种形式用于在不同的执行方案之间进行选择，让程序更“智能”，且极大地提高了计算机的用途。不过，要等到下一章才介绍这部分的内容。本章还将介绍数组，可以把新学的知识应用在数组上。另外，本章还将继续介绍函数的相关内容。首先，我们从while循环开始学习。\n再探while循环经过上一章的学习，读者已经熟悉了 while 循环。这里，我们用一个程序来回顾一下，程序清单 6.1根据用户从键盘输入的整数进行求和。程序利用了scanf()的返回值来结束循环。\n程序清单6.1 summing.c程序\n1234567891011121314151617181920/* summing.c -- 根据用户键入的整数求和 */#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;　　　　 /* 把sum初始化为0　*/    int status;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    status=scanf(\"%ld\",&amp;num);    while (status == 1)　　/* == 的意思是“等于”　*/    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        status=scanf(\"%ld\",&amp;num);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;该程序使用long类型以储存更大的整数。尽管C编译器会把0自动转换为合适的类型，但是为了保持程序的一致性，我们把sum初始化为0L（long类型的0），而不是0（int类型的0）。\n该程序的运行示例如下：\n123456Please　enter　an　integer　to　be　summed　(q　to　quit):　44Please　enter　next　integer　(q　to　quit):　33Please　enter　next　integer　(q　to　quit):　88Please　enter　next　integer　(q　to　quit):　121Please　enter　next　integer　(q　to　quit):　qThose　integers　sum　to　286.程序注释先看while循环，该循环的测试条件是如下表达式：\n1status==1==运算符是C的相等运算符（equality operator），该表达式判断status是否等于1。不要把status== 1与status = 1混淆，后者是把1赋给status。根据测试条件status == 1，只要status等于1，循环就会重复。每次循环，num的当前值都被加到sum上，这样sum的值始终是当前整数之和。当status的值不为1时，循环结束。然后程序打印sum的最终值。\n要让程序正常运行，每次循环都要获取num的一个新值，并重置status。程序利用scanf()的两个不同的特性来完成。首先，使用scanf()读取num的一个新值；然后，检查scanf()的返回值判断是否成功获取值。第4章中介绍过，scanf()返回成功读取项的数量。如果scanf()成功读取一个整数，就把该数存入num并返回1，随后返回值将被赋给status（注意，用户输入的值储存在num中，不是status中）。这样做同时更新了num和status的值，while循环进入下一次迭代。如果用户输入的不是数字（如， q），scanf()会读取失败并返回0。此时，status的值就是0，循环结束。因为输入的字符q不是数字，所以它会被放回输入队列中（实际上，不仅仅是 q，任何非数值的数据都会导致循环终止，但是提示用户输入q退出程序比提示用户输入一个非数字字符要简单）。\n如果 scanf()在转换值之前出了问题（例如，检测到文件结尾或遇到硬件问题），会返回一个特殊值EOF（其值通常被定义为-1）。这个值也会引起循环终止。\n如何告诉循环何时停止？该程序利用 scanf()的双重特性避免了在循环中交互输入时的这个棘手的问题。例如，假设scanf()没有返回值，那么每次循环只会改变num的值。虽然可以使用num的值来结束循环，比如把num &gt; 0（num大于0）或num ！= 0（num不等于0）作为测试条件，但是这样用户就不能输入某些值，如-3或0。也可以在循环中添加代码，例如每次循环时询问用户“是否继续循环？&lt;y/n&gt;”，然后判断用户是否输入y。这个方法有些笨拙，而且还减慢了输入的速度。使用scanf()的返回值，轻松地避免了这些问题。\n现在，我们来看看该程序的结构。总结如下：\n把sum初始化为0\n\n提示用户输入数据\n\n读取用户输入的数据\n\n当输入的数据为整数时，\n\n输入添加给sum，\n\n提示用户进行输入，\n\n然后读取下一个输入\n\n输入完成后，打印sum的值\n\n顺带一提，这叫作伪代码（pseudocode），是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应。伪代码有助于设计程序的逻辑。确定程序的逻辑无误之后，再把伪代码翻译成实际的编程代码。使用伪代码的好处之一是，可以把注意力集中在程序的组织和逻辑上，不用在设计程序时还要分心如何用编程语言来表达自己的想法。例如，可以用缩进来代表一块代码，不用考虑C的语法要用花括号把这部分代码括起来。\n总之，因为while循环是入口条件循环，程序在进入循环体之前必须获取输入的数据并检查status的值，所以在 while 前面要有一个 scanf()。要让循环继续执行，在循环内需要一个读取数据的语句，这样程序才能获取下一个status的值，所以在while循环末尾还要有一个scanf()，它为下一次迭代做好了准备。可以把下面的伪代码作为while循环的标准格式：\n获得第1个用于测试的值\n当测试为真时\n处理值\n获取下一个值\nC风格读取循环根据伪代码的设计思路，程序清单6.1可以用Pascal、BASIC或FORTRAN来编写。但是C更为简洁，下面的代码：\n1234567891011status=scanf(\"%ld\",　&amp;num);while(status　==　1)&#123;/* 循环行为 */status　=　scanf(\"%ld\",　&amp;num);&#125;可以用这些代码替换：while(scanf(\"%ld\",&amp;num)==1)&#123;/*循环行为*/&#125;第二种形式同时使用scanf()的两种不同的特性。首先，如果函数调用成功，scanf()会把一个值存入num。然后，利用scanf()的返回值（0或1，不是num的值）控制while循环。因为每次迭代都会判断循环的条件，所以每次迭代都要调用scanf()读取新的num值来做判断。换句话说，C的语法特性让你可以用下面的精简版本替换标准版本：\n当获取值和判断值都成功\n处理该值\n接下来，我们正式地学习while语句。\nwhile语句while循环的通用形式如下：\n12while(expression)statementstatement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句。\n到目前为止，程序示例中的expression部分都使用关系表达式。也就是说，expression是值之间的比较，可以使用任何表达式。如果expression为真（或者更一般地说，非零），执行 statement部分一次，然后再次判断expression。在expression为假（0）之前，循环的判断和执行一直重复进行。每次循环都被称为一次迭代（iteration），如图6.1所示。\n\n终止while循环while循环有一点非常重要：在构建while循环时，必须让测试表达式的值有变化，表达式最终要为假。否则，循环就不会终止（实际上，可以使用break和if语句来终止循环，但是你尚未学到）。考虑下面的例子：\n123index=1;while(index&lt;5)printf(\"Good　morning!\\n\");上面的程序段将打印无数次Good　morning!。为什么？因为循环中index的值一直都是原来的值1，不曾变过。\n现在，考虑下面的程序段：\n123index=1;while(--index&lt;5)printf(\"Good　morning!\\n\");这段程序也好不到哪里去。虽然改变了index的值，但是改错了！不过，这个版本至少在index减少到其类型到可容纳的最小负值并变成最大正值时会终止循环（第3章3.4.2节中的toobig.c程序解释过，最大正值加1一般会得到一个负值；类似地，最小负值减1一般会得到最大正值）。\n何时终止循环要明确一点：只有在对测试条件求值时，才决定是终止还是继续循环。例如，考虑程序清单6.2中的程序。\n程序清单6.2 when.c程序\n123456789101112131415// when.c -- 何时退出循环#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=5;    while (n&lt;7)　　　　　　　　　　　// 第7行    &#123;        printf(\"n=%d\\n\",n);        n++;　　　　　　　　　　　　　 // 第10行        printf(\"Now n=%d\\n\", n); // 第11行    &#125;    printf(\"The　loop　has　finished.\\n\");    return　0;&#125;运行程序清单6.2，输出如下：\n12345n = 5Now n = 6n = 6Now n = 7The loop has finished.在第2次循环时，变量n在第10行首次获得值7。但是，此时程序并未退出，它结束本次循环（第11行），并在对第7行的测试条件求值时才退出循环（变量n在第1次判断时为5，第2次判断时为6）。\nwhile：入口条件循环while循环是使用入口条件的有条件循环。所谓“有条件”指的是语句部分的执行取决于测试表达式描述的条件，如(index &lt; 5)。该表达式是一个入口条件（entry condition），因为必须满足条件才能进入循环体。在下面的情况中，就不会进入循环体，因为条件一开始就为假：\n123index=10;while(index++&lt;5)printf(\"Have　a　fair　day　or　better.\\n\");把第1行改为：\n1index = 3;就可以运行这个循环了。\n语法要点使用while时，要牢记一点：只有在测试条件后面的单独语句（简单语句或复合语句）才是循环部分。程序清单6.3演示了忽略这点的后果。缩进是为了让读者阅读方便，不是计算机的要求。\n1234567891011121314程序清单6.3 while1.c程序/* while1.c -- 注意花括号的使用 *//* 糟糕的代码创建了一个无限循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=0;    while(n&lt;3)        printf(\"n　is　%d\\n\",　n);    n++;    printf(\"That's　all　this　program　does\\n\");    return　0;&#125;该程序的输出如下：\n123456n　is　0n　is　0n　is　0n　is　0n　is　0...屏幕上会一直输出以上内容，除非强行关闭这个程序。\n虽然程序中缩进了n++;这条语句，但是并未把它和上一条语句括在花括号内。因此，只有直接跟在测试条件后面的一条语句是循环的一部分。变量n的值不会改变，条件n&lt;3一直为真。该循环会一直打印n is 0，除非强行关闭程序。这是一个无限循环（infinite loop）的例子，没有外部干涉就不会退出。\n记住，即使while语句本身使用复合语句，在语句构成上，它也是一条单独的语句。该语句从while开始执行，到第1个分号结束。在使用了复合语句的情况下，到右花括号结束。\n要注意放置分号的位置。例如，考虑程序清单6.4。\n123456789101112程序清单6.4 while2.c程序/* while2.c -- 注意分号的位置 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=0;    while(n++&lt;3);　　　　　 /* 第7行 */    printf(\"n is %d\\n\", n); /* 第8行 */    printf(\"That's　all　this　program　does.\\n\");    return　0;&#125;该程序的输出如下：\n12n is 4That's all this program does.如前所述，循环在执行完测试条件后面的第 1 条语句（简单语句或复合语句）后进入下一轮迭代，直到测试条件为假才会结束。该程序中第7行的测试条件后面直接跟着一个分号，循环在此进入下一轮迭代，因为单独一个分号被视为一条语句。虽然n的值在每次循环时都递增1，但是第8行的语句不是循环的一部分，因此只会打印一次循环结束后的n值。\n在该例中，测试条件后面的单独分号是空语句（null statement），它什么也不做。在C语言中，单独的分号表示空语句。有时，程序员会故意使用带空语句的while语句，因为所有的任务都在测试条件中完成了，不需要在循环体中做什么。例如，假设你想跳过输入到第1个非空白字符或数字，可以这样写：\n12while(scanf(\"%d\",&amp;num)==1); /* 跳过整数输入 */只要scanf()读取一个整数，就会返回1，循环继续执行。注意，为了提高代码的可读性，应该让这个分号独占一行，不要直接把它放在测试表达式同行。这样做一方面让读者更容易看到空语句，一方面也提醒自己和读者空语句是有意而为之。处理这种情况更好的方法是使用下一章介绍的continue语句。\n用关系运算符和表达式比较大小while循环经常依赖测试表达式作比较，这样的表达式被称为关系表达式（relational expression），出现在关系表达式中间的运算符叫做关系运算符（relational operator）。前面的示例中已经用过一些关系运算符，表 6.1 列出了 C 语言的所有关系运算符。该表也涵盖了所有的数值关系（数字之间的关系再复杂也没有人与人之间的关系复杂）。\n\n关系运算符常用于构造while语句和其他C语句（稍后讨论）中用到的关系表达式。这些语句都会检查关系表达式为真还是为假。下面有3个互不相关的while语句，其中都包含关系表达式。\n123456789101112while(number&lt;6)&#123;    printf(\"Your　number　is　too　small.\\n\");    scanf(\"%d\",　&amp;number);&#125;while(ch!='$')&#123;    count++;    scanf(\"%c\",　&amp;ch);&#125;while(scanf(\"%f\",&amp;num)==1)sum=sum+num;注意，第2个while语句的关系表达式还可用于比较字符。比较时使用的是机器字符码（假定为ASCII）。但是，不能用关系运算符比较字符串。第11章将介绍如何比较字符串。\n虽然关系运算符也可用来比较浮点数，但是要注意：比较浮点数时，尽量只使用&lt;和&gt;。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。例如，3乘以1/3的积是1.0。如果用把1/3表示成小数点后面6位数字，乘积则是.999999，不等于1。使用fabs()函数（声明在math.h头文件中）可以方便地比较浮点数，该函数返回一个浮点值的绝对值（即，没有代数符号的值）。\n例如，可以用类似程序清单6.5的方法来判断一个数是否接近预期结果。\n12345678910111213141516171819程序清单6.5 cmpflt.c程序// cmpflt.c -- 浮点数比较#include　&lt;math.h&gt;#include　&lt;stdio.h&gt;int　main(void)&#123;    const　double　ANSWER　=　3.14159;    double　response;    printf(\"What　is　the　value　of　pi?\\n\");    scanf(\"%lf\",&amp;response);    while(fabs(response-ANSWER)&gt;0.0001)    &#123;        printf(\"Try　again!\\n\");        scanf(\"%lf\",&amp;response);    &#125;    printf(\"Close　enough!\\n\");    return　0;&#125;循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差0.0001：\n12345What　is　the　value　of　pi?3.14Try　again!3.1416Close enough!什么是真这是一个古老的问题，但是对C而言还不算难。在C中，表达式一定有一个值，关系表达式也不例外。程序清单6.6中的程序用于打印两个关系表达式的值，一个为真，一个为假。\n程序清单6.6 t_and_f.c程序\n/* t_and_f.c – C中的真和假的值 */\n#include　&lt;stdio.h&gt;\nint　main(void)\n{\nint　true_val,　false_val;\ntrue_val = (10 &gt; 2);　　　　// 关系为真的值\nfalse_val = (10 == 2); // 关系为假的值\nprintf(“true　=　%d;　false　=　%d　\\n”,　true_val,　false_val);\nreturn　0;\n}\n程序清单6.6把两个关系表达式的值分别赋给两个变量，即把表达式为真的值赋给true_val，表达式为假的值赋给false_val。运行该程序后输出如下：\ntrue = 1; false = 0\n原来如此！对C而言，表达式为真的值是1，表达式为假的值是0。一些C程序使用下面的循环结构，由于1为真，所以循环会一直进行。\nwhile　(1)\n{\n…\n}\n其他真值既然1或0可以作为while语句的测试表达式，是否还可以使用其他数字？如果可以，会发生什么？我们用程序清单6.7来做个实验。\n12345678910111213141516程序清单6.7 truth.c程序// truth.c -- 哪些值为真#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=3;    while(n)        printf(\"%2d　is　true\\n\",　n--);    printf(\"%2d　is　false\\n\",　n);    n=-3;    while(n)        printf(\"%2d　is　true\\n\",　n++);    printf(\"%2d　is　false\\n\",　n);    return　0;&#125;该程序的输出如下：\n123456783　is　true2　is　true1　is　true0　is　false-3　is　true-2　is　true-1　is　true0　is　false执行第1个循环时，n分别是3、2、1，当n等于0时，第1个循环结束。与此类似，执行第2个循环时，n分别是-3、-2和-1，当n等于0时，第2个循环结束。一般而言，所有的非零值都视为真，只有0被视为假。在C中，真的概念还真宽！\n也可以说，只要测试条件的值为非零，就会执行 while 循环。这是从数值方面而不是从真/假方面来看测试条件。要牢记：关系表达式为真，求值得1；关系表达式为假，求值得0。因此，这些表达式实际上相当于数值。\n许多C程序员都会很好地利用测试条件的这一特性。例如，用while (goats)替换while (goats !=0)，因为表达式goats != 0和goats都只有在goats的值为0时才为0或假。第1种形式（while (goats != 0)）对初学者而言可能比较清楚，但是第2种形式（while (goats)）才是C程序员最常用的。要想成为一名C程序员，应该多熟悉while (goats)这种形式。\n真值的问题C对真的概念约束太少会带来一些麻烦。例如，我们稍微修改一下程序清单6.1，修改后的程序如程序清单6.8所示。\n123456789101112131415161718192021程序清单6.8 trouble.c程序// trouble.c -- 误用=会导致无限循环#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;    int status;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    status=scanf(\"%ld\",&amp;num);    while(status=1)    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        status　=　scanf(\"%ld\",　&amp;num);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;运行该程序，其输出如下：\n12345678Please　enter　an　integer　to　be　summed　(q　to　quit):　20Please　enter　next　integer　(q　to　quit):　5Please　enter　next　integer　(q　to　quit):　30Please　enter　next　integer　(q　to　quit):　qPlease　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):（„„屏幕上会一直显示最后的提示内容，除非强行关闭程序。也许你根本不想运行这个示例。）\n这个麻烦的程序示例改动了while循环的测试条件，把status == 1替换成status = 1。后者是一个赋值表达式语句，所以 status 的值为 1。而且，整个赋值表达式的值就是赋值运算符左侧的值，所以status = 1的值也是1。这里，while (status = 1)实际上相当于while (1)，也就是说，循环不会退出。虽然用户输入q，status被设置为0，但是循环的测试条件把status又重置为1，进入了下一次迭代。\n读者可能不太理解，程序的循环一直运行着，用户在输入q后完全没机会继续输入。如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，供下次读取。当scanf()把q作为整数读取时失败了，它把 q 留下。在下次循环时，scanf()从上次读取失败的地方（q）开始读取，scanf()把q作为整数读取，又失败了。因此，这样修改后不仅创建了一个无限循环，还创建了一个无限失败的循环，真让人沮丧。好在计算机觉察不出来。对计算机而言，无限地执行这些愚蠢的指令比成功预测未来10年的股市行情没什么两样。\n不要在本应使用==的地方使用=。一些计算机语言（如，BASIC）用相同的符号表示赋值运算符和关系相等运算符，但是这两个运算符完全不同（见图 6.2）。赋值运算符把一个值赋给它左侧的变量；而关系相等运算符检查它左侧和右侧的值是否相等，不会改变左侧变量的值（如果左侧是一个变量）。\n\n示例如下：\n12canoes=5\t\t←把5赋给canoescanoes==5\t\t←检查canoes的值是否为5要注意使用正确的运算符。编译器不会检查出你使用了错误的形式，得出也不是预期的结果（误用=的人实在太多了，以至于现在大多数编译器都会给出警告，提醒用户是否要这样做）。如果待比较的一个值是常量，可以把该常量放在左侧有助于编译器捕获错误：\n125=canoes\t←语法错误5==canoes\t←检查canoes的值是否为5可以这样做是因为C语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来。许多经验丰富的程序员在构建比较是否相等的表达式时，都习惯把常量放在左侧。\n总之，关系运算符用于构成关系表达式。关系表达式为真时值为1，为假时值为0。通常用关系表达式作为测试条件的语句（如while和if）可以使用任何表达式作为测试条件，非零为真，零为假。\n新的_Bool类型在C语言中，一直用int类型的变量表示真/假值。C99专门针对这种类型的变量新增了_Bool类型。该类型是以英国数学家George Boole的名字命名的，他开发了用代数表示逻辑和解决逻辑问题。在编程中，表示真或假的变量被称为布尔变量（Boolean variable），所以_Bool是C语言中布尔变量的类型名。_Bool类型的变量只能储存1（真）或0（假）。如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1。这反映了C把所有的非零值都视为真。\n程序清单6.9修改了程序清单6.8中的测试条件，把int类型的变量status替换为_Bool类型的变量input_is_good。给布尔变量取一个能表示真或假值的变量名是一种常见的做法。\n123456789101112131415161718192021程序清单6.9 boolean.c程序// boolean.c -- 使用_Bool类型的变量 variable#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;    _Bool input_is_good;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    input_is_good=(scanf(\"%ld\",&amp;num)==1);    while(input_is_good)    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        input_is_good=(scanf(\"%ld\",&amp;num)==1);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;注意程序中把比较的结果赋值给_Bool类型的变量input_is_good：\n1input_is_good=(scanf(\"%ld\", &amp;num) == 1);这样做没问题，因为==运算符返回的值不是1就是0。顺带一提，从优先级方面考虑的话，并不需要用圆括号把scanf(&quot;%ld&quot;,&amp;num)==1括起来。但是，这样做可以提高代码可读性。还要注意，如何为变量命名才能让while循环的测试简单易懂：\n1while (input_is_good)C99提供了stdbool.h头文件，该头文件让bool成为_Bool的别名，而且还把true和false分别定义为1和0的符号常量。包含该头文件后，写出的代码可以与C++兼容，因为C++把bool、true和false定义为关键字。\n如果系统不支持_Bool类型，导致无法运行该程序，可以把_Bool替换成int即可。\n优先级和关系运算符关系运算符的优先级比算术运算符低（包括+和-），比赋值运算符高。这意味着x &gt; y + 2和x &gt; (y+ 2)相同，x = y &gt; 2和x = (y &gt; 2)相同。换言之，如果y大于2，则给x赋值1，否则赋值0。y的值不会赋给x。\n关系运算符比赋值运算符的优先级高，因此，x_bigger=x&gt;y;相当于x_bigger=(x &gt; y);。\n关系运算符之间有两种不同的优先级。\n高优先级组： &lt;&lt;= &gt;&gt;=\n低优先级组： == !=\n与其他大多数运算符一样，关系运算符的结合律也是从左往右。因此：\nex!=wye==zee与(ex != wye) == zee相同\n首先，C判断ex与wye是否相等；然后，用得出的值1或0（真或假）再与zee比较。我们并不推荐这样写，但是在这里有必要说明一下。\n表6.2列出了目前我们学过的运算符的性质。附录B的参考资料II“C运算符”中列出了全部运算符的完整优先级表。\n\n小结：while语句\n关键字：while\n一般注解：\nwhile语句创建了一个循环，重复执行直到测试表达式为假或0。while语句是一种入口条件循环，也就是说，在执行多次循环之前已决定是否执行循环。因此，循环有可能不被执行。循环体可以是简单语句，也可以是复合语句。\n形式：\n12while(expression)statement在expression部分为假或0之前，重复执行statement部分。\n示例：\n1234567while(n++&lt;100)printf(\" %d %d\\n\",n,2*n+1); // 简单语句while(fargo&lt;1000)&#123; // 复合语句    fargo=fargo+step;    step=2*step;&#125;小结：关系运算符和表达式\n关系运算符：\n每个关系运算符都把它左侧的值和右侧的值进行比较。\n123456&lt;　　　　　小于&lt;=　　　　 小于或等于==　　　　 等于&gt;=　　　　 大于或等于&gt;　　　　　大于!=　　　　 不等于关系表达式：\n简单的关系表达式由关系运算符及其运算对象组成。如果关系为真，关系表达式的值为 1；如果关系为假，关系表达式的值为0。\n示例：\n5 &gt; 2为真，关系表达式的值为1\n(2 + a) == a 为假，关系表达式的值为0\n不确定循环和计数循环一些while循环是不确定循环（indefinite loop）。所谓不确定循环，指在测试表达式为假之前，预先不知道要执行多少次循环。例如，程序清单6.1通过与用户交互获得数据来计算整数之和。我们事先并不知道用户会输入什么整数。另外，还有一类是计数循环（counting loop）。这类循环在执行循环之前就知道要重复执行多少次。程序清单6.10就是一个简单的计数循环。\n123456789101112131415程序清单6.10 sweetie1.c程序// sweetie1.c -- 一个计数循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const　int　NUMBER　=　22;    int count = 1;　　　　　　　　　　　　　// 初始化    while(count&lt;=NUMBER)　　　　　　　 // 测试    &#123;        printf(\"Be my Valentine!\\n\");　 // 行为        count++;　　　　　　　　　　　　　　// 更新计数    &#125;    return　0;&#125;虽然程序清单6.10运行情况良好，但是定义循环的行为并未组织在一起，程序的编排并不是很理想。我们来仔细分析一下。\n在创建一个重复执行固定次数的循环中涉及了3个行为：\n必须初始化计数器；\n\n计数器与有限的值作比较；\n\n每次循环时递增计数器。\n\nwhile循环的测试条件执行比较，递增运算符执行递增。程序清单6.10中，递增发生在循环的末尾，这可以防止不小心漏掉递增。因此，这样做比将测试和更新组合放在一起（即使用count++ &lt;= NUMBER）要好，但是计数器的初始化放在循环外，就有可能忘记初始化。实践告诉我们可能会发生的事情终究会发生，所以我们来学习另一种控制语句，可以避免这些问题。\nfor循环for循环把上述3个行为（初始化、测试和更新）组合在一处。程序清单6.11使用for循环修改了程序清单6.10的程序。\n123456789101112程序清单6.11 sweetie2.c程序// sweetie2.c -- 使用for循环的计数循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const int NUMBER=22;    int count;    for(count=1;count&lt;=NUMBER;count++)        printf(\"Be　my　Valentine!\\n\");    return　0;&#125;关键字for后面的圆括号中有3个表达式，分别用两个分号隔开。\n第1个表达式是初始化，只会在for循环开始时执行一次。\n第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假（本例中，count大于NUMBER时），循环结束。\n第3个表达式执行更新，在每次循环结束时求值。程序清单6.10用这个表达式递增count 的值，更新计数。\n完整的for语句还包括后面的简单语句或复合语句。for圆括号中的表达式也叫做控制表达式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。图6.3演示了for循环的结构。\n\n程序清单6.12 for_cube.c程序\n1234567891011/* for_cube.c -- 使用for循环创建一个立方表 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int num;    printf(\"n　　n　cubed\\n\");    for(num=1;num&lt;=6;num++)        printf(\"%5d %5d\\n\",num,num*num*num);    return　0;&#125;程序清单6.12打印整数1～6及其对应的立方，该程序的输出如下：\n1234567n　　　 n　cubed1　　　　　　　12　　　　　　　83　　　　　　 274　　　　　　 645　　　　　 1256　　　　　 216for循环的第1行包含了循环所需的所有信息：num的初值，num的终值和每次循环num的增量。\n利用for的灵活性虽然for循环看上去和FORTRAN的DO循环、Pascal的FOR循环、BASIC的FOR...NEXT循环类似，但是for循环比这些循环灵活。这些灵活性源于如何使用for循环中的3个表达式。以前面程序示例中的for循环为例，第1个表达式给计数器赋初值，第2个表达式表示计数器的范围，第3个表达式递增计数器。这样使用for循环确实很像其他语言的循环。除此之外，for循环还有其他9种用法。\n可以使用递减运算符来递减计数器：\n1234567891011/* for_down.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int secs;    for(secs=5;secs&gt;0;secs--)        printf(\"%d　seconds!\\n\",secs);    printf(\"We　have　ignition!\\n\");    return　0;&#125;该程序输出如下：\n1234565 seconds!4 seconds!3 seconds!2 seconds!1 seconds!We have ignition!可以让计数器递增2、10等：\n12345678910/* for_13s.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n; // 从2开始，每次递增13    for　(n=2;n&lt;60;n=n+13)        printf(\"%d　\\n\",　n);    return　0;&#125;每次循环n递增13，程序的输出如下：\n12345215284154可以用字符代替数字计数：\n12345678910/* for_char.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    char ch;    for(ch='a';ch&lt;='z';ch++)    printf(\"The　ASCII　value　for　%c　is　%d.\\n\",　ch,　ch);    return　0;&#125;该程序假定系统用ASCII码表示字符。由于篇幅有限，省略了大部分输出：\n123456The　ASCII　value　for　a　is　97.The　ASCII　value　for　b　is　98....The　ASCII　value　for　x　is　120.The　ASCII　value　for　y　is　121.The　ASCII　value　for　z　is　122.该程序能正常运行是因为字符在内部是以整数形式储存的，因此该循环实际上仍是用整数来计数。\n除了测试迭代次数外，还可以测试其他条件。在for_cube程序中，可以把：\n1for(num=1;num&lt;=6;num++)替换成：\n1for(num=1;num*num*num&lt;=216;num++)如果与控制循环次数相比，你更关心限制立方的大小，就可以使用这样的测试条件。\n可以让递增的量几何增长，而不是算术增长。也就是说，每次都乘上而不是加上一个固定的量：\n12345678910/* for_geo.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    double　debt;    for (debt = 100.0; debt &lt; 150.0; debt = debt * 1.1)\t    printf(\"Your　debt　is　now　$%.2f.\\n\",　debt);    return　0;&#125;该程序中，每次循环都把debt乘以1.1，即debt的值每次都增加10%，其输出如下：\n12345Your　debt　is　now　$100.00.Your　debt　is　now　$110.00.Your　debt　is　now　$121.00.Your　debt　is　now　$133.10.Your　debt　is　now　$146.41.第3个表达式可以使用任意合法的表达式。无论是什么表达式，每次迭代都会更新该表达式的值。\n1234567891011/* for_wild.c */#include　&lt;stdio.h&gt;int main(void)&#123;    int x;    int y=55;    for(x=1;y&lt;=75;y=(++x*5)+50)        printf(\"%10d　%10d\\n\",　x,　y);    return　0;&#125;该循环打印x的值和表达式++x * 5 + 50的值，程序的输出如下：\n123451　　　　　 552　　　　　 603　　　　　 654　　　　　 705　　　　　 75注意，测试涉及y，而不是x。for循环中的3个表达式可以是不同的变量（注意，虽然该例可以正常运行，但是编程风格不太好。如果不在更新部分加入代数计算，程序会更加清楚）。\n可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。\n123456789101112/* for_none.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int ans,n;    ans=2;    for(n=3;ans&lt;=25;)\t\tans=ans*n;    printf(\"n　=　%d;　ans　=　%d.\\n\",　n,　ans);    return　0;&#125;该程序的输出如下：\n1n=3;ans=54.该循环保持n的值为3。变量ans开始的值为2，然后递增到6和18，最终是54（18比25小，所以for循环进入下一次迭代，18乘以3得54）。顺带一提，省略第2个表达式被视为真，所以下面的循环会一直运行：\n12for　(;　;　)printf(\"I　want　some　action\\n\");第1个表达式不一定是给变量赋初值，也可以使用printf()。记住，在执行循环的其他部分之前，只对第1个表达式求值一次或执行一次。\n1234567891011/* for_show.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int num　=　0;    for(printf(\"Keep　entering　numbers!\\n\");num!=6;)  \t  scanf(\"%d\",　&amp;num);    printf(\"That's　the　one　I　want!\\n\");    return　0;&#125;该程序打印第1行的句子一次，在用户输入6之前不断接受数字：\n123456Keep　entering　numbers!3586That's the one I want!循环体中的行为可以改变循环头中的表达式。例如，假设创建了下面的循环：\n1for(n=1;n&lt;10000;n=n+delta)如果程序经过几次迭代后发现delta太小或太大，循环中的if语句（详见第7章）可以改变delta的大小。在交互式程序中，用户可以在循环运行时才改变 delta 的值。这样做也有危险的一面，例如，把delta设置为0就没用了。\n总而言之，可以自己决定如何使用for循环头中的表达式，这使得在执行固定次数的循环外，还可以做更多的事情。接下来，我们将简要讨论一些运算符，使for循环更加有用。\n小结：for语句\n关键字：for\n一般注解：\nfor语句使用3个表达式控制循环过程，分别用分号隔开。initialize表达式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式为真（或非零），执行循环一次；接着对update表达式求值，并再次检查test表达式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。\n形式：\n12for(initialize;test;update　)statement在test为假或0之前，重复执行statement部分。\n示例：\n12for(n=0;n&lt;10;n++)printf(\" %d %d\\n\", n, 2 * n + 1);其他赋值运算符：+=、-=、*=、/=、%=C有许多赋值运算符。最基本、最常用的是=，它把右侧表达式的值赋给左侧的变量。其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式。赋给变量的新值是根据右侧表达式的值调整后的值。确切的调整方案取决于具体的运算符。例如：\n12345scores+=20\t\t与\t\tscores=scores+20\t\t相同dimes-=2\t\t与\t\tdimes=dimes-2\t\t\t相同bunnies*=2\t\t与\t\tbunnies=bunnies*2\t\t相同time/=2.73\t\t与\t\ttime=time/2.73\t\t\t相同reduce%=3\t\t与\t\treduce=reduce%3\t\t\t相同上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达式，例如：\n1x*=3*y+12\t与\tx=x*(3*y+12) \t相同以上提到的赋值运算符与=的优先级相同，即比+或*优先级低。上面最后一个例子也反映了赋值运算符的优先级，3 *y先与12相加，再把计算结果与x相乘，最后再把乘积赋给x。\n并非一定要使用这些组合形式的赋值运算符。但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效。当需要在for循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用。\n逗号运算符逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式。例如，程序清单6.13演示了一个打印一类邮件资费（first-class postage rate）的程序（在撰写本书时，邮资为首重40美分/盎司，续重20美分/盎司，可以在互联网上查看当前邮资）。\n程序清单6.13 postage.c程序\n12345678910111213// postage.c -- 一类邮资#include　&lt;stdio.h&gt;int　main(void)&#123;const int FIRST_OZ = 46;　　// 2013邮资const int NEXT_OZ = 20;　　 // 2013邮资int ounces,　cost;printf(\"　ounces　 cost\\n\");for(ounces=1,cost=FIRST_OZ;ounces&lt;=16;ounces++,cost+=NEXT_OZ)\tprintf(\"%5d　　$%4.2f\\n\",　ounces,　cost　/　100.0);return　0;&#125;该程序的前5行输出如下：\n12345ounces　\tcost1　　　　 $0.462　　　　 $0.663　　　　 $0.864　　　　 $1.06该程序在初始化表达式和更新表达式中使用了逗号运算符。初始化表达式中的逗号使ounces和cost都进行了初始化，更新表达式中的逗号使每次迭代ounces递增1、cost递增20（NEXT_Z的值是20）。绝大多数计算都在for循环头中进行（见图6.4）。\n\n逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方。逗号运算符有两个其他性质。首先，它保证了被它分隔的表达式从左往右求值（换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生）。因此，ounces在cost之前被初始化。在该例中，顺序并不重要，但是如果cost的表达式中包含了ounces时，顺序就很重要。例如，假设有下面的表达式：\n1ounces++,cost=ounces*FIRST_OZ在该表达式中，先递增ounce，然后在第2个子表达式中使用ounce的新值。作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值之前发生。\n其次，整个逗号表达式的值是右侧项的值。例如，下面语句\n1x=(y=3,(z=++y+2)+5);的效果是：先把3赋给y，递增y为4，然后把4加2之和（6）赋给z，接着加上5，最后把结果11赋给 x。至于为什么有人编写这样的代码，在此不做评价。另一方面，假设在写数字时不小心输入了逗号：\n1houseprice=249,500;这不是语法错误，C 编译器会将其解释为一个逗号表达式，即 houseprice = 249 是逗号左侧的子表达式，500 是右侧的子表达式。因此，整个逗号表达式的值是逗号右侧表达式的值，而且左侧的赋值表达式把249赋给变量houseprice。因此，这与下面代码的效果相同：\n1houseprice　=　249;500;记住，任何表达式后面加上一个分号就成了表达式语句。所以，500;也是一条语句，但是什么也不做。\n另外，下面的语句\n1houseprice &#x3D; (249,500);赋给houseprice的值是逗号右侧子表达式的值，即500。\n逗号也可用作分隔符。在下面语句中的逗号都是分隔符，不是逗号运算符：\n12char ch, date;printf(\"%d %d\\n\", chimps, chumps);小结：新的运算符\n赋值运算符：\n下面的运算符用右侧的值，根据指定的操作更新左侧的变量：\n12345+=\t\t\t把右侧的值加到左侧的变量上-=\t\t\t从左侧的变量中减去右侧的值*=\t\t\t把左侧的变量乘以右侧的值/=\t\t\t把左侧的变量除以右侧的值%=\t\t\t左侧变量除以右侧值得到的余数示例：\n1rabbits*=1.6;\t与\trabbits=rabbits*1.6;\t相同这些组合赋值运算符与普通赋值运算符的优先级相同，都比算术运算符的优先级低。因此，\n1contents*=old_rate+1.2;最终的效果与下面的语句相同：\n1contents = contents * (old_rate + 1.2);逗号运算符：\n逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值。逗号运算符通常在for循环头的表达式中用于包含更多的信息。整个逗号表达式的值是逗号右侧表达式的值。\n示例：\n12for(step = 2, fargo = 0;fargo&lt;1000;step*=2)fargo+=step;当Zeno遇到for循环接下来，我们看看 for 循环和逗号运算符如何解决古老的悖论。希腊哲学家 Zeno 曾经提出箭永远不会达到它的目标。首先，他认为箭要到达目标距离的一半，然后再达到剩余距离的一半，然后继续到达剩余距离的一半，这样就无穷无尽。Zeno认为箭的飞行过程有无数个部分，所以要花费无数时间才能结束这一过程。不过，我们怀疑Zeno是自愿甘做靶子才会得出这样的结论。\n我们采用一种定量的方法，假设箭用1秒钟走完一半的路程，然后用1/2秒走完剩余距离的一半，然后用1/4秒再走完剩余距离的一半，等等。可以用下面的无限序列来表示总时间：\n11 + 1/2 + 1/4 + 1/8 + 1/16 +....程序清单6.14中的程序求出了序列前几项的和。变量power_of_two的值分别是1.0、2.0、4.0、8.0等。\n程序清单6.14 zeno.c程序\n1234567891011121314151617/* zeno.c -- 求序列的和 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int t_ct;　　　 // 项计数    double time,power_of_2;    int limit;    printf(\"Enter　the　number　of　terms　you　want:　\");    scanf(\"%d\",&amp;limit);    for(time=0,power_of_2=1,t_ct=1;t_ct&lt;=limit;t_ct++,power_of_2*=2.0)    &#123;        time+=1.0/power_of_2;        printf(\"time=%f　when　terms　=　%d.\\n\",time,t_ct);    &#125;    return　0;&#125;下面是序列前15项的和：\n12345678910111213141516Enter　the　number　of　terms　you　want:　15time　=　1.000000　when　terms　=　1.time　=　1.500000　when　terms　=　2.time　=　1.750000　when　terms　=　3.time　=　1.875000　when　terms　=　4.time　=　1.937500　when　terms　=　5.time　=　1.968750　when　terms　=　6.time　=　1.984375　when　terms　=　7.time　=　1.992188　when　terms　=　8.time　=　1.996094　when　terms　=　9.time　=　1.998047　when　terms　=　10.time　=　1.999023　when　terms　=　11.time　=　1.999512　when　terms　=　12.time　=　1.999756　when　terms　=　13.time　=　1.999878　when　terms　=　14.time　=　1.999939　when　terms　=　15.不难看出，尽管不断添加新的项，但是总和看起来变化不大。就像程序输出显示的那样，数学家的确证明了当项的数目接近无穷时，总和无限接近2.0。假设S表示总和，下面我们用数学的方法来证明一下：\n1S = 1 + 1/2 + 1/4 + 1/8 + ...这里的省略号表示“等等”。把S除以2得：\n1S/2 = 1/2 + 1/4 + 1/8 + 1/16 + ...第1个式子减去第2个式子得：\n1S - S/2 = 1 +1/2 -1/2 + 1/4 -1/4 +...除了第1个值为1，其他的值都是一正一负地成对出现，所以这些项都可以消去。只留下：\n1S/2 = 1然后，两侧同乘以2，得：\n1S = 2从这个示例中得到的启示是，在进行复杂的计算之前，先看看数学上是否有简单的方法可用。\n程序本身是否有需要注意的地方？该程序演示了在表达式中可以使用多个逗号运算符，在for循环中，初始化了time、power_of_2和count。构建完循环条件之后，程序本身就很简短了。\n出口条件循环：do whilewhile循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。C语言还有出口条件循环（exit-condition loop），即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。这种循环被称为 do while循环。程序清单6.15 演示了一个示例。\n程序清单6.15 do_while.c程序\n12345678910111213141516/* do_while.c -- 出口条件循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    const int secret_code=13;    int code_entered;    do    &#123;        printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");        printf(\"please　enter　the　secret　code　number:　\");        scanf(\"%d\",&amp;code_entered);    &#125;while(code_entered!=secret_code);    printf(\"Congratulations!　You　are　cured!\\n\");    return　0;&#125;程序清单6.15在用户输入13之前不断提示用户输入数字。下面是一个运行示例：\n1234567To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　12To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　14To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　13Congratulations!　You　are　cured!使用while循环也能写出等价的程序，但是长一些，如程序清单6.16所示。\n程序清单6.16 entry.c程序\n12345678910111213141516171819/* entry.c -- 出口条件循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    const int secret_code=13;    int code_entered;    printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");    printf(\"please　enter　the　secret　code　number:　\");    scanf(\"%d\",　&amp;code_entered);    while(code_entered!=secret_code)    &#123;        printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");        printf(\"please　enter　the　secret　code　number:　\");        scanf(\"%d\",&amp;code_entered);    &#125;    printf(\"Congratulations!　You　are　cured!\\n\");    return　0;&#125;下面是do while循环的通用形式：\n123dostatementwhile(expression);statement可以是一条简单语句或复合语句。注意，do while循环以分号结尾，其结构见图6.5。\n\ndo while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次；而for循环或while循环都是在执行循环体之前先执行测试条件。do while循环适用于那些至少要迭代一次的循环。例如，下面是一个包含do while循环的密码程序伪代码：\n123456789101112do&#123;提示用户输入密码读取用户输入的密码&#125; while (用户输入的密码不等于密码);避免使用这种形式的do　while结构：do&#123;询问用户是否继续其他行为&#125; while (回答是yes);这样的结构导致用户在回答“no”之后，仍然执行“其他行为”部分，因为测试条件执行晚了。\n小结：do while语句\n关键字：do while\n一般注解：\ndo while 语句创建一个循环，在 expression 为假或 0 之前重复执行循环体中的内容。do while语句是一种出口条件循环，即在执行完循环体后才根据测试条件决定是否再次执行循环。因此，该循环至少必须执行一次。statement部分可是一条简单语句或复合语句。\n形式：\n123dostatementwhile(expression);在test为假或0之前，重复执行statement部分。\n示例：\n123doscanf(\"%d\",&amp;number);while　(number!=20);如何选择循环如何选择使用哪一种循环？首先，确定是需要入口条件循环还是出口条件循环。通常，入口条件循环用得比较多，有几个原因。其一，一般原则是在执行循环之前测试条件比较好。其二，测试放在循环的开头，程序的可读性更高。另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环。\n那么，假设需要一个入口条件循环，用for循环还是while循环？这取决于个人喜好，因为二者皆可。要让for循环看起来像while循环，可以省略第1个和第3个表达式。例如：\n1for ( ; test ; )与下面的while效果相同：\n1while ( test )要让while循环看起来像for循环，可以在while循环的前面初始化变量，并在while循环体中包含更新语句。例如：\n初始化;\n12345while ( 测试 )&#123;    其他语句    更新语句&#125;与下面的for循环效果相同：\n12for ( 初始化 ;测试 ; 更新 )其他语句一般而言，当循环涉及初始化和更新变量时，用for循环比较合适，而在其他情况下用while循环更好。对于下面这种条件，用while循环就很合适：\n1while (scanf(\"%ld\", &amp;num) == 1)对于涉及索引计数的循环，用for循环更适合。例如：\n1for (count = 1; count &lt;= 100; count++)嵌套循环嵌套循环（nested loop）指在一个循环内包含另一个循环。嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行。程序清单6.17演示了一个简单的示例。\n程序清单6.17 rows1.c程序\n1234567891011121314151617/* rows1.c -- 使用嵌套循环 */#include　&lt;stdio.h&gt;#define ROWS 6#define　CHARS　10int　main(void)&#123;    int row;    char ch;    for(row=0;row&lt;ROWS;row++)　　　　　　　　 /* 第10行 */    &#123;        for (ch='A';ch&lt;('A'+CHARS);ch++)　　 /* 第12行 */        \tprintf(\"%c\",ch);        printf(\"\\n\");    &#125;    return　0;&#125;运行该程序后，输出如下：\n123456ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ程序分析第10行开始的for循环被称为外层循环（outer loop），第12行开始的for循环被称为内层循环（inner loop）。外层循环从row为0开始循环，到row为6时结束。因此，外层循环要执行6次，row的值从0变为5。每次迭代要执行的第1条语句是内层的for循环，该循环要执行10次，在同一行打印字符A～J；第2条语句是外层循环的printf(&quot;\\n&quot;);，该语句的效果是另起一行，这样在下一次运行内层循环时，将在下一行打印的字符。\n注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环。在程序清单6.17中，内层循环一行打印10个字符，外层循环创建6行。\n嵌套变式上一个实例中，内层循环和外层循环所做的事情相同。可以通过外层循环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务。把程序清单6.17稍微修改后，如程序清单6.18所示。内层循环开始打印的字符取决于外层循环的迭代次数。该程序的第 1 行使用了新的注释风格，而且用 const 关键字代替#define，有助于读者熟悉这两种方法。\n程序清单6.18 rows2.c程序\n1234567891011121314151617// rows2.c -- 依赖外部循环的嵌套循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const　int　ROWS　=　6;    const　int　CHARS　=　6;    int　row;    char　ch;    for(row　=　0;　row　&lt;　ROWS;　row++)    &#123;        for(ch　=　('A'　+　row);　ch　&lt;　('A'　+　CHARS);　ch++)        printf(\"%c\",　ch);        printf(\"\\n\");    &#125;    return　0;&#125;该程序的输出如下：\n123456ABCDEFBCDEFCDEFDEFEFF因为每次迭代都要把row的值与‘A’相加，所以ch在每一行都被初始化为不同的字符。然而，测试条件并没有改变，所以每行依然是以F结尾，这使得每一行打印的字符都比上一行少一个。\n数组简介在许多程序中，数组很重要。数组可以作为一种储存多个相关项的便利方式。我们在第10章中将详细介绍数组，但是由于循环经常用到数组，所以在这里先简要地介绍一下。\n数组（array）是按顺序储存的一系列类型相同的值，如10个char类型的字符或15个int类型的值。整个数组有一个数组名，通过整数下标访问数组中单独的项或元素（element）。例如，以下声明：\n1float debts[20];声明debts是一个内含20个元素的数组，每个元素都可以储存float类型的值。数组的第1个元素是debts[0]，第2个元素是debts[1]，以此类推，直到debts[19]。注意，数组元素的编号从0开始，不是从1开始。可以给每个元素赋float类型的值。例如，可以这样写：\n12debts[5] = 32.54;debts[6] = 1.2e+21;实际上，使用数组元素和使用同类型的变量一样。例如，可以这样把值读入指定的元素中：\n1scanf(\"%f\", &amp;debts[4]); // 把一个值读入数组的第5个元素这里要注意一个潜在的陷阱：考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确。下面的代码，都不正确：\n12debts[20] = 88.32;　　 // 该数组元素不存在debts[33] = 828.12;　　// 该数组元素不存在编译器不会查找这样的错误。当运行程序时，这会导致数据被放置在已被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常中断。\n数组的类型可以是任意数据类型。\n123int nannies[22];　/* 可储存22个int类型整数的数组 */char actors[26];　/* 可储存26个字符的数组 */long big[500];　　/* 可储存500个long类型整数的数组 */我们在第4章中讨论过字符串，可以把字符串储存在char类型的数组中（一般而言，char类型数组的所有元素都储存char类型的值）。如果char类型的数组末尾包含一个表示字符串末尾的空字符\\0，则该数组中的内容就构成了一个字符串（见图6.6）。\n\n用于识别数组元素的数字被称为下标（subscript）、索引（indice）或偏移量（offset）。下标必须是整数，而且要从0开始计数。数组的元素被依次储存在内存中相邻的位置，如图6.7所示。\n\n在for循环中使用数组程序中有许多地方要用到数组，程序清单6.19是一个较为简单的例子。该程序读取10个高尔夫分数，稍后进行处理。使用数组，就不用创建10个不同的变量来储存10个高尔夫分数。而且，还可以用for循环来读取数据。程序打印总分、平均分、差点（handicap，它是平均分与标准分的差值）。\n程序清单6.19 scores_in.c程序\n123456789101112131415161718192021222324// scores_in.c -- 使用循环处理数组#include　&lt;stdio.h&gt;#define　SIZE　10#define　PAR　72int　main(void)&#123;    int index,score[SIZE];    int sum=0;    float average;    printf(\"Enter　%d　golf　scores:\\n\",SIZE);    for(index=0;index&lt;SIZE;index++)        scanf(\"%d\",&amp;score[index]);　　 // 读取10个分数    printf(\"The　scores　read　in　are　as　follows:\\n\");    for(index=0;index&lt;SIZE;index++)   \t\t printf(\"%5d\", score[index]);　　// 验证输入    printf(\"\\n\");    for(index=0;index&lt;SIZE;index++)   \t\t sum+=score[index];　　　　　　　// 求总分数    average=(float) sum/SIZE;　　　　// 求平均分    printf(\"Sum　of　scores　=　%d,　average　=　%.2f\\n\",　sum,　average);    printf(\"That's　a　handicap　of　%.0f.\\n\",　average　-　PAR);    return　0;&#125;先看看程序清单6.19是否能正常工作，接下来再做一些解释。下面是程序的输出：\n1234567Enter　10　golf　scores:99　95　109　105　10096　98　93　99　97　98The　scores　read　in　are　as　follows:99　95　109　105　100　96　98　93　99　97Sum　of　scores　=　991,　average　=　99.10That's　a　handicap　of　27.程序运行没问题，我们来仔细分析一下。首先，注意程序示例虽然打印了11个数字，但是只读入了10个数字，因为循环只读了10个值。由于scanf()会跳过空白字符，所以可以在一行输入10个数字，也可以每行只输入一个数字，或者像本例这样混合使用空格和换行符隔开每个数字（因为输入是缓冲的，只有当用户键入Enter键后数字才会被发送给程序）。\n然后，程序使用数组和循环处理数据，这比使用10个单独的scanf()语句和10个单独的printf()语句读取10个分数方便得多。for循环提供了一个简单直接的方法来使用数组下标。注意，int类型数组元素的用法与int类型变量的用法类似。要读取int类型变量fue，应这样写 scanf(&quot;&amp;d&quot;,&amp;fue)。程序清单6.19中要读取int类型的元素 score[index]，所以这样写scanf(&quot;%d&quot;,&amp;score[index]。\n该程序示例演示了一些较好的编程风格。第一，用#define 指令创建的明示常量（SIZE）来指定数组的大小。这样就可以在定义数组和设置循环边界时使用该明示常量。如果以后要扩展程序处理20个分数，只需简单地把SIZE重新定义为20即可，不用逐一修改程序中使用了数组大小的每一处。\n第二，下面的代码可以很方便地处理一个大小为SIZE的数组：\n1for(index=0;index&lt;SIZE;index++)设置正确的数组边界很重要。第1个元素的下标是0，因此循环开始时把index设置为0。因为从0开始编号，所以数组中最后一个元素的下标是SIZE - 1。也就是说，第10个元素是score[9]。通过测试条件index &lt; SIZE来控制循环中使用的最后一个index的值是SIZE - 1。\n第三，程序能重复显示刚读入的数据。这是很好的编程习惯，有助于确保程序处理的数据与期望相符。\n最后，注意该程序使用了3个独立的for循环。这是否必要？是否可以将其合并成一个循环？当然可以，读者可以动手试试，合并后的程序显得更加紧凑。但是，调整时要注意遵循模块化（modularity）的原则。模块化隐含的思想是：应该把程序划分为一些独立的单元，每个单元执行一个任务。这样做提高了程序的可读性。也许更重要的是，模块化使程序的不同部分彼此独立，方便后续更新或修改程序。在掌握如何使用函数后，可以把每个执行任务的单元放进函数中，提高程序的模块化。\n使用函数返回值的循环示例本章最后一个程序示例要用一个函数计算数的整数次幂（math.h库提供了一个更强大幂函数pow()，可以使用浮点指数）。该示例有3个主要任务：设计算法、在函数中表示算法并返回计算结果、提供一个测试函数的便利方法。\n首先分析算法。为简化函数，我们规定该函数只处理正整数的幂。这样，把n与n相乘p次便可计算n的p次幂。这里自然会用到循环。先把变量pow设置为1，然后将其反复乘以n：\n12for(i=1;i&lt;=p;i++)pow*=n;回忆一下，*=运算符把左侧的项乘以右侧的项，再把乘积赋给左侧的项。第1次循环后，pow的值是1乘以n，即n；第2次循环后，pow的值是上一次的值（n）乘以n，即n的平方；以此类推。这种情况使用for循环很合适，因为在执行循环之前已预先知道了迭代的次数（已知p）。\n现在算法已确定，接下来要决定使用何种数据类型。指数p是整数，其类型应该是int。为了扩大n及其幂的范围，n和pow的类型都是double。\n接下来，考虑如何把以上内容用函数来实现。要使用两个参数（分别是double类型和int类型）才能把所需的信息传递给函数，并指定求哪个数的多少次幂。而且，函数要返回一个值。如何把函数的返回值返回给主调函数？编写一个有返回值的函数，要完成以下内容：\n定义函数时，确定函数的返回类型；\n\n使用关键字return表明待返回的值。\n\n例如，可以这样写：\n12345678double power(double n,int p) // 返回一个double类型的值&#123;    double pow=1;    int i;    for(i=1;i&lt;=p;i++)    pow*=n;    return pow; // 返回pow的值&#125;要声明函数的返回类型，在函数名前写出类型即可，就像声明一个变量那样。关键字 return 表明该函数将把它后面的值返回给主调函数。根据上面的代码，函数返回一个变量的值。返回值也可以是表达式的值，如下所示：\n1return 2*x+b;函数将计算表达式的值，并返回该值。在主调函数中，可以把返回值赋给另一个变量、作为表达式中的值、作为另一个函数的参数（如，printf(&quot;%f&quot;,power(6.28,3)），或者忽略它。\n现在，我们在一个程序中使用这个函数。要测试一个函数很简单，只需给它提供几个值，看它是如何响应的。这种情况下可以创建一个输入循环，选择 while 循环很合适。可以使用 scanf()函数一次读取两个值。如果成功读取两个值，scanf()则返回2，所以可以把scanf()的返回值与2作比较来控制循环。还要注意，必须先声明power()函数（即写出函数原型）才能在程序中使用它，就像先声明变量再使用一样。程序清单6.20演示了这个程序。\n程序清单6.20 powwer.c程序\n12345678910111213141516171819202122232425262728// power.c -- 计算数的整数幂#include　&lt;stdio.h&gt;double power(double n,int p); // ANSI函数原型int main(void)&#123;    double x,xpow;    int exp;    printf(\"Enter　a　number　and　the　positive　integer　power\");    printf(\"　to　which\\n the　number　will　be　raised.　Enter　q\");    printf(\"　to　quit.\\n\");    while(scanf(\"%lf%d\",&amp;x,&amp;exp)==2)    &#123;        xpow=power(x,exp);　// 函数调用        printf(\"%.3g　to　the　power　%d　is　%.5g\\n\",　x,　exp,　xpow);        printf(\"Enter　next　pair　of　numbers　or　q　to　quit.\\n\");    &#125;    printf(\"Hope　you　enjoyed　this　power　trip　--　bye!\\n\");    return　0;&#125;double power(double n,int p)　 // 函数定义&#123;    double pow=1;    int i;    for(i=1;i&lt;=p;i++)    pow*=n;    return pow;　　　　　　　　　 // 返回pow的值&#125;运行该程序后，输出示例如下：\n1234567891011Enter　a　number　and　the　positive　integer　power　to　whichthe　number　will　be　raised.　Enter　q　to　quit.1.2　121.2　to　the　power　12　is　8.9161Enter　next　pair　of　numbers　or　q　to　quit.2162　to　the　power　16　is　65536Enter　next　pair　of　numbers　or　q　to　quit.qHope　you　enjoyed　this　power　trip　--　bye!程序分析该程序示例中的main()是一个驱动程序（driver），即被设计用来测试函数的小程序。\n该例的while循环是前面讨论过的一般形式。输入1.2  12，scanf()成功读取两值，并返回2，循环继续。因为scanf()跳过空白，所以可以像输出示例那样，分多行输入。但是输入q会使scanf()的返回值为0，因为q与scanf()中的转换说明%1f不匹配。scanf()将返回0，循环结束。类似地，输入2.8 q会使scanf()的返回值为1，循环也会结束。\n现在分析一下与函数相关的内容。power()函数在程序中出现了3次。首次出现是：\n1double power(double n,int p); // ANSI函数原型这是power()函数的原型，它声明程序将使用一个名为power()的函数。开头的关键字double表明power()函数返回一个double类型的值。编译器要知道power()函数返回值的类型，才能知道有多少字节的数据，以及如何解释它们。这就是为什么必须声明函数的原因。圆括号中的 double n,int p表示power()函数的两个参数。第1个参数应该是double类型的值，第2个参数应该是int类型的值。\n第2次出现是：\n1xpow=power(x,exp); // 函数调用程序调用power()，把两个值传递给它。该函数计算x的exp次幂，并把计算结果返回给主调函数。在主调函数中，返回值将被赋给变量xpow。\n第3次出现是：\n1double power(double n, int p) // 函数定义这里，power()有两个形参，一个是double类型，一个是int类型，分别由变量n和变量p表示。注意，函数定义的末尾没有分号，而函数原型的末尾有分号。在函数头后面花括号中的内容，就是power()完成任务的代码。\npower()函数用for循环计算n的p次幂，并把计算结果赋给pow，然后返回pow的值，如下所示：\n1return pow; //返回pow的值使用带返回值的函数声明函数、调用函数、定义函数、使用关键字return，都是定义和使用带返回值函数的基本要素。\n这里，读者可能有一些问题。例如，既然在使用函数返回值之前要声明函数，那么为什么在使用scanf()的返回值之前没有声明scanf()？为什么在定义中说明了power()的返回类型为double，还要单独声明这个函数？\n我们先回答第2 个问题。编译器在程序中首次遇到power()时，需要知道power()的返回类型。此时，编译器尚未执行到power()的定义，并不知道函数定义中的返回类型是double。因此，必须通过前置声明（forward declaration）预先说明函数的返回类型。前置声明告诉编译器，power()定义在别处，其返回类型为double。如果把power()函数的定义置于main()的文件顶部，就可以省略前置声明，因为编译器在执行到main()之前已经知道power()的所有信息。但是，这不是C的标准风格。因为main()通常只提供整个程序的框架，最好把 main()放在所有函数定义的前面。另外，通常把函数放在其他文件中，所以前置声明必不可少。\n接下来，为什么不用声明 scanf()函数就可以使用它？其实，你已经声明了。stdio.h 头文件中包含了scanf()、printf()和其他I/O函数的原型。scanf()函数的原型表明，它返回的类型是int。\n关键概念循环是一个强大的编程工具。在创建循环时，要特别注意以下3个方面：\n注意循环的测试条件要能使循环结束；\n确保循环测试中的值在首次使用之前已初始化；\n确保循环在每次迭代都更新测试的值。\nC通过求值来处理测试条件，结果为0表示假，非0表示真。带关系运算符的表达式常用于循环测试，它们有些特殊。如果关系表达式为真，其值为1；如果为假，其值为0。这与新类型_Bool的值保持一致。\n数组由相邻的内存位置组成，只储存相同类型的数据。记住，数组元素的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少1。C编译器不会检查数组下标值是否有效，自己要多留心。\n使用函数涉及3个步骤：\n通过函数原型声明函数；\n在程序中通过函数调用使用函数；\n定义函数。\n函数原型是为了方便编译器查看程序中使用的函数是否正确，函数定义描述了函数如何工作。现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义。接口部分描述了如何使用一个特性，也就是函数原型所做的；实现部分描述了具体的行为，这正是函数定义所做的。\n本章小结本章的主题是程序控制。C语言为实现结构化的程序提供了许多工具。while语句和for语句提供了入口条件循环。for语句特别适用于需要初始化和更新的循环。使用逗号运算符可以在for循环中初始化和更新多个变量。有些场合也需要使用出口条件循环，C为此提供了do while语句。\n典型的while循环设计的伪代码如下：\n12345678910/*获得初值*/while(值满足测试条件)&#123;    处理该值    获取下一个值&#125;/*for循环也可以完成相同的任务：*/for(获得初值; 值满足测试条件; 获得下一个值)处理该值这些循环都使用测试条件来判断是否继续执行下一次迭代。一般而言，如果对测试表达式求值为非0，则继续执行循环；否则，结束循环。通常，测试条件都是关系表达式（由关系运算符和表达式构成）。表达式的关系为真，则表达式的值为1；如果关系为假，则表达式的值为0。C99新增了_Bool类型，该类型的变量只能储存1或0，分别表示真或假。\n除了关系运算符，本章还介绍了其他的组合赋值运算符，如+=或*=。这些运算符通过对其左侧运算对象执行算术运算来修改它的值。\n接下来还简单地介绍了数组。声明数组时，方括号中的值指明了该数组的元素个数。数组的第 1 个元素编号为0，第2个元素编号为1，以此类推。例如，以下声明：\n1double hippos[20];创建了一个有20个元素的数组hippos，其元素从hippos[0]～hippos[19]。利用循环可以很方便地操控数组的下标。\n最后，本章演示了如何编写和使用带返回值的函数。\n","plink":"https://dxsummer.gitee.io/posts/287f677b/"},{"title":"Step3 运算符、表达式和语句","date":"2020-05-30T08:10:08.000Z","date_formatted":{"ll":"2020年5月30日","L":"2020/05/30","MM-DD":"05-30"},"updated":"2020-06-08T01:44:44.883Z","content":"[运算符、表达式和语句]本章介绍以下内容：\n关键字：while、typedef\n运算符：=、-、*、/、%、++、--、(类型名)\nC语言的各种运算符，包括用于普通数学运算的运算符\n运算符优先级以及语句、表达式的含义\nwhile循环\n复合语句、自动类型转换和强制类型转换\n如何编写带有参数的函数\n现在，读者已经熟悉了如何表示数据，接下来我们学习如何处理数据。C 语言为处理数据提供了大量的操作，可以在程序中进行算术运算、比较值的大小、修改变量、逻辑地组合关系等。我们先从基本的算术运算（加、减、乘、除）开始。\n组织程序是处理数据的另一个方面，让程序按正确的顺序执行各个步骤。C 有许多语言特性，帮助你完成组织程序的任务。循环就是其中一个特性，本章中你将窥其大概。循环能重复执行行为，让程序更有趣、更强大。\n循环简介程序清单5.1是一个简单的程序示例，该程序进行了简单的运算，计算穿9码男鞋的脚长（单位：英寸）。为了让读者体会循环的好处，程序的第1个版本演示了不使用循环编程的局限性。\n123456789101112131415程序清单5.1 shoes1.c程序/* shoes1.c -- 把鞋码转换成英寸 */#include　&lt;stdio.h&gt;#define ADJUST 7.31　　　　　　　　　　// 字符常量int　main(void)&#123;    const double SCALE = 0.333;// const变量    double　shoe,　foot;    shoe　=　9.0;    foot = SCALE * shoe + ADJUST;    printf(\"Shoe　size　(men's)　　 foot　length\\n\");    printf(\"%10.1f　%15.2f　inches\\n\",　shoe,　foot);    return　0;&#125;该程序的输出如下：\n12Shoe　size　(men's)　foot　length\t9.0　　　　10.31　inches该程序演示了用#define 指令创建符号常量和用 const 限定符创建在程序运行过程中不可更改的变量。程序使用了乘法和加法，假定用户穿9码的鞋，以英寸为单位打印用户的脚长。你可能会说：“这太简单了，我用笔算比敲程序还要快。”说得没错。写出来的程序只使用一次（本例即只根据一只鞋的尺码计算一次脚长），实在是浪费时间和精力。如果写成交互式程序会更有用，但是仍无法利用计算机的优势。\n应该让计算机做一些重复计算的工作。毕竟，需要重复计算是使用计算机的主要原因。C 提供多种方法做重复计算，我们在这里简单介绍一种——while循环。它能让你对运算符做更有趣地探索。程序清单5.2演示了用循环改进后的程序。\n程序清单5.2 shoes2.c程序\n12345678910111213141516171819/* shoes2.c -- 计算多个不同鞋码对应的脚长 */#include　&lt;stdio.h&gt;#define ADJUST 7.31　　　　　　　　　　// 字符常量int　main(void)&#123;    const double SCALE = 0.333;// const变量    double　shoe,　foot;    printf(\"Shoe size (men's) foot length\\n\");    shoe　=　3.0;    while (shoe &lt; 18.5)　　　　　　/* while循环开始 */    &#123;　　　　　　　　　　　　　　　/* 块开始　*/        foot = SCALE * shoe + ADJUST;        printf(\"%10.1f　%15.2f　inches\\n\",　shoe,　foot);        shoe　=　shoe　+　1.0;    &#125;　　　　　　　　　　　　　　　/* 块结束　　　 */    printf(\"If　the　shoe　fits,　wear　it.\\n\");    return　0;&#125;下面是shoes2.c程序的输出（…表示并未显示完整，有删节）：\n12345678910Shoe　size　(men's)　foot　length3.0　　　　　　 8.31　inches4.0　　　　　　 8.64　inches5.0　　　　　　 8.97　inches6.0　　　　　　 9.31　inches...16.0　　　　　12.64　inches17.0　　　　　12.97　inches18.0　　　　　13.30　inchesIf　the　shoe　fits,　wear　it.（如果读者对此颇有研究，应该知道该程序不符合实际情况。程序中假定了一个统一的鞋码系统。）\n下面解释一下while循环的原理。当程序第1次到达while循环时，会检查圆括号中的条件是否为真。该程序中，条件表达式如下：\n1shoe &lt; 18.5符号&lt;的意思是小于。变量shoe被初始化为3.0，显然小于18.5。因此，该条件为真，程序进入块中继续执行，把尺码转换成英寸。然后打印计算的结果。下一条语句把 shoe增加1.0，使shoe的值为4.0：\n1shoe = shoe + 1.0;此时，程序返回while入口部分检查条件。为何要返回while的入口部分？因为上面这条语句的下面是右花括号（}），代码使用一对花括号（{}）来标出while循环的范围。花括号之间的内容就是要被重复执行的内容。花括号以及被花括号括起来的部分被称为块（block）。现在，回到程序中。因为4小于18.5，所以要重复执行被花括号括起来的所有内容（用计算机术语来说就是，程序循环这些语句）。该循环过程一直持续到shoe的值为19.0。此时，由于19.0小于18.5，所以该条件为假：\n1shoe &lt; 18.5出现这种情况后，控制转到紧跟while循环后面的第1条语句。该例中，是最后的printf()语句。\n可以很方便地修改该程序用于其他转换。例如，把SCALE设置成1.8、ADJUST设置成32.0，该程序便可把摄氏温度转换成华氏温度；把SCALE设置成0.6214、ADJUST设置成0，该程序便可把公里转换成英里。注意，修改了设置后，还要更改打印的消息，以免前后表述不一。\n通过while循环能便捷灵活地控制程序。现在，我们来学习程序中会用到的基本运算符。\n基本运算符C用运算符（operator）表示算术运算。例如，+运算符使在它两侧的值加在一起。如果你觉得术语“运算符”很奇怪，那么请记住东西总得有个名称。与其叫“那些东西”或“运算处理符”，还不如叫“运算符”。现在，我们介绍一下用于基本算术运算的运算符：=、+、-、*和/（C 没有指数运算符。不过，C 的标准数学库提供了一个pow()函数用于指数运算。例如，pow(3.5, 2.2)返回3.5的2.2次幂）。\n赋值运算符：=在C语言中，=并不意味着“相等”，而是一个赋值运算符。下面的赋值表达式语句：\n1bmw = 2002;把值2002赋给变量bmw。也就是说，=号左侧是一个变量名，右侧是赋给该变量的值。符号=被称为赋值运算符。另外，上面的语句不读作“bmw等于2002”，而读作“把值2002赋给变量bmw”。赋值行为从右往左进行。\n也许变量名和变量值的区别看上去微乎其微，但是，考虑下面这条常用的语句：\n1i = i + 1;对数学而言，这完全行不通。如果给一个有限的数加上 1，它不可能“等于”原来的数。但是，在计算机赋值表达式语句中，这很合理。该语句的意思是：找出变量 i 的值，把该值加 1，然后把新值赋值变量i（见图5.1）。\n\n在C语言中，类似这样的语句没有意义（实际上是无效的）：\n12002 = bmw;因为在这种情况下，2002 被称为右值（rvale），只能是字面常量。不能给常量赋值，常量本身就是它的值。因此，在编写代码时要记住，=号左侧的项必须是一个变量名。实际上，赋值运算符左侧必须引用一个存储位置。最简单的方法就是使用变量名。不过，后面章节还会介绍“指针”，可用于指向一个存储位置。概括地说，C 使用可修改的左值（modifiable lvalue）标记那些可赋值的实体。也许“可修改的左值”不太好懂，我们再来看一些定义。\n几个术语：数据对象、左值、右值和运算符\n赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为数据对象（data object）。C 标准只有在提到这个概念时才会用到对象这个术语。使用变量名是标识对象的一种方法。除此之外，还有其他方法，但是要在后面的章节中才学到。例如，可以指定数组的元素、结构的成员，或者使用指针表达式（指针中储存的是它所指向对象的地址）。左值（lvalue）是 C 语言的术语，用于标识特定数据对象的名称或表达式。因此，对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签。\n对于早期的C语言，提到左值意味着：\n1.它指定一个对象，所以引用内存中的地址；\n2.它可用在赋值运算符的左侧，左值（lvalue）中的l源自left。\n但是后来，标准中新增了const限定符。用const创建的变量不可修改。因此，const标识符满足上面的第1项，但是不满足第2项。一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧。有些左值不能用于赋值运算符的左侧。此时，标准对左值的定义已经不能满足当前的状况。\n为此，C标准新增了一个术语：可修改的左值（modifiable lvalue），用于标识可修改的对象。所以，赋值运算符的左侧应该是可修改的左值。当前标准建议，使用术语对象定位值（object locator value）更好。\n右值（rvalue）指的是能赋值给可修改左值的量，且本身不是左值。例如，考虑下面的语句：\n1bmw = 2002;这里，bmw是可修改的左值，2002是右值。读者也许猜到了，右值中的r源自right。右值可以是常量、变量或其他可求值的表达式（如，函数调用）。实际上，当前标准在描述这一概念时使用的是表达式的值（value of an expression），而不是右值。\n我们看几个简单的示例：\n1234567int　ex;int　why;int　zee;const　int　TWO　=　2;why　=　42;zee = why;ex = TWO * (why + zee);这里，ex、why和zee都是可修改的左值（或对象定位值），它们可用于赋值运算符的左侧和右侧。TWO是不可改变的左值，它只能用于赋值运算符的右侧（在该例中，TWO被初始化为2，这里的=运算符表示初始化而不是赋值，因此并未违反规则）。同时，42 是右值，它不能引用某指定内存位置。另外，why和 zee 是可修改的左值，表达式(why + zee)是右值，该表达式不能表示特定内存位置，而且也不能给它赋值。它只是程序计算的一个临时值，在计算完毕后便会被丢弃。\n在学习名称时，被称为“项”（如，赋值运算符左侧的项）的就是运算对象（operand）。运算对象是运算符操作的对象。例如，可以把吃汉堡描述为：“吃”运算符操作“汉堡”运算对象。类似地可以说，=运算符的左侧运算对象应该是可修改的左值。\nC的基本赋值运算符有些与众不同，请看程序清单5.3。\n123456789101112程序清单5.3 golf.c程序/* golf.c -- 高尔夫锦标赛记分卡 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　jane,　tarzan,　cheeta;    cheeta=tarzan=jane=68;    printf(\"cheeta　　tarzan　　 jane\\n\");    printf(\"First　round　score　%4d　%8d　%8d\\n\",　cheeta,　tarzan,　jane);    return　0;&#125;许多其他语言都会回避该程序中的三重赋值，但是C完全没问题。赋值的顺序是从右往左：首先把68赋给jane，然后再赋给tarzan，最后赋给cheeta。因此，程序的输出如下：\n12cheetah　　tarzan　　　　janeFirst　round　score　　68　　　　　　68　　　　　　68加法运算符：+加法运算符（addition operator）用于加法运算，使其两侧的值相加。例如，语句：\n1printf(\"%d\", 4 + 20);打印的是24，而不是表达式\n14 + 20相加的值（运算对象）可以是变量，也可以是常量。因此，执行下面的语句：\n1income = salary + bribes;计算机会查看加法运算符右侧的两个变量，把它们相加，然后把和赋给变量income。\n在此提醒读者注意，income、salary和bribes都是可修改的左值。因为每个变量都标识了一个可被赋值的数据对象。但是，表达式salary + brives是一个右值。\n减法运算符：-减法运算符（subtraction operator）用于减法运算，使其左侧的数减去右侧的数。例如，下面的语句把200.0赋给takehome：\n1takehome = 224.00 – 24.00;+和-运算符都被称为二元运算符（binary operator），即这些运算符需要两个运算对象才能完成操作。\n符号运算符：-和+减号还可用于标明或改变一个值的代数符号。例如，执行下面的语句后，smokey的值为12：\n12rocky = –12;smokey = –rocky;以这种方式使用的负号被称为一元运算符（unary operator）。一元运算符只需要一个运算对象（见图5.2）。\nC90标准新增了一元+运算符，它不会改变运算对象的值或符号，只能这样使用：\n1dozen &#x3D; +12;编译器不会报错。但是在以前，这样做是不允许的。\n乘法运算符：*符号*表示乘法。下面的语句用2.54乘以inch，并将结果赋给cm：\n1cm = 2.54 * inch;C没有平方函数，如果要打印一个平方表，怎么办？如程序清单5.4所示，可以使用乘法来计算平方。\n程序清单5.4 squares.c程序\n12345678910111213/* squares.c -- 计算1～20的平方 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　num　=　1;    while　(num　&lt;　21)    &#123;        printf(\"%4d %6d\\n\", num, num * num);        num　=　num　+　1;    &#125;    return　0;&#125;该程序打印数字1～20及其平方。接下来，我们再看一个更有趣的例子。\n指数增长读者可能听过这样一个故事，一位强大的统治者想奖励做出突出贡献的学者。他问这位学者想要什么，学者指着棋盘说，在第1个方格里放1粒小麦、第2个方格里放2粒小麦、第3个方格里放4粒小麦，第4个方格里放 8 粒小麦，以此类推。这位统治者不熟悉数学，很惊讶学者竟然提出如此谦虚的要求。因为他原本准备奖励给学者一大笔财产。如果程序清单5.5运行的结果正确，这显然是跟统治者开了一个玩笑。程序计算出每个方格应放多少小麦，并计算了总数。可能大多数人对小麦的产量不熟悉，该程序以谷粒数为单位，把计算的小麦总数与粗略估计的世界小麦年产量进行了比较。\n程序清单5.5 wheat.c程序\n12345678910111213141516171819202122232425/* wheat.c -- 指数增长 */#include　&lt;stdio.h&gt;#define SQUARES 64　　　　　　 // 棋盘中的方格数int　main(void)&#123;    const double CROP = 2E16;　// 世界小麦年产谷粒数    double current,total;    int count=1;    printf(\"square　grains　total \");    printf(\"fraction　of　\\n\");    printf(\"　　added　　grains　　 \");    printf(\"world　total\\n\");    total=current=1.0;　　 /* 从1颗谷粒开始　*/    printf(\"%4d　%13.2e　%12.2e　%12.2e\\n\",count,　current,total,total/CROP);    while(count&lt;SQUARES)    &#123;        count=count+1;        current=2.0*current;　 /* 下一个方格谷粒翻倍 */        total=total+current;　 /* 更新总数 */        printf(\"%4d　%13.2e　%12.2e　%12.2e\\n\",count,　current,total,total/CROP);    &#125;    printf(\"That's　all.\\n\");    return　0;&#125;程序的输出结果如下：\n1234567891011121314151617181920212223square　　　　　　grains　　　　　 total　　　　　　 fraction　ofadded　　　　　　 grains　　　　　 world　total1　　　　　　　 1.00e+00　　　　1.00e+00　　　　5.00e-172　　　　　　　 2.00e+00　　　　3.00e+00　　　　1.50e-163　　　　　　　 4.00e+00　　　　7.00e+00　　　　3.50e-164　　　　　　　 8.00e+00　　　　1.50e+01　　　　7.50e-165　　　　　　　 1.60e+01　　　　3.10e+01　　　　1.55e-156　　　　　　　 3.20e+01　　　　6.30e+01　　　　3.15e-157　　　　　　　 6.40e+01　　　　1.27e+02　　　　6.35e-158　　　　　　　 1.28e+02　　　　2.55e+02　　　　1.27e-149　　　　　　　 2.56e+02　　　　5.11e+02　　　　2.55e-1410　　　　　　　5.12e+02　　　　1.02e+03　　　　5.12e-1410个方格以后，该学者得到的小麦仅超过了1000粒。但是，看看55个方格的小麦数是多少：\n155　　　　　 1.80e+16　　　　3.60e+16　　　　1.80e+00总量已超过了世界年产量！不妨自己动手运行该程序，看看第64个方格有多少小麦。\n这个程序示例演示了指数增长的现象。世界人口增长和我们使用的能源都遵循相同的模式。\n除法运算符：/C使用符号/来表示除法。/左侧的值是被除数，右侧的值是除数。例如，下面four的值是4.0：\n1four = 12.0/3.0;整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。整数是没有小数部分的数。这使得5除以3很让人头痛，因为实际结果有小数部分。在C语言中，整数除法结果的小数部分被丢弃，这一过程被称为截断（truncation）。\n运行程序清单5.6中的程序，看看截断的情况，体会整数除法和浮点数除法的区别。\n程序清单5.6 divide.c程序\n12345678910111213/* divide.c -- 演示除法 */#include　&lt;stdio.h&gt;int　main(void)&#123;    printf(\"integer　division:　5/4　is　%d　\\n\",5/4);    printf(\"integer　division:　6/3　is　%d　\\n\",6/3);    printf(\"integer　division:　7/4　is　%d　\\n\",7/4);    printf(\"floating　division:　7./4. is　%1.2f　\\n\",7./4.);    printf(\"mixed　division:　7./4　is　%1.2f　\\n\",7./4);    return　0;&#125;程序清单5.6中包含一个“混合类型”的示例，即浮点值除以整型值。C相对其他一些语言而言，在类型管理上比较宽容。尽管如此，一般情况下还是要避免使用混合类型。该程序的输出如下：\n12345integer　division:　 5/4　　 is　1integer　division:　 6/3　　 is　2integer　division:　 7/4　　 is　1floating　division:　7./4.　is　1.75mixed　division:　　　7./4　 is　1.75注意，整数除法会截断计算结果的小数部分（丢弃整个小数部分），不会四舍五入结果。混合整数和浮点数计算的结果是浮点数。实际上，计算机不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。本例中，在进行除法运算前，整数会被转换成浮点数。\nC99标准以前，C语言给语言的实现者留有一些空间，让他们来决定如何进行负数的整数除法。一种方法是，舍入过程采用小于或等于浮点数的最大整数。当然，对于3.8而言，处理后的3符合这一描述。但是-3.8 会怎样？该方法建议四舍五入为-4，因为-4 小于-3.8.但是，另一种舍入方法是直接丢弃小数部分。这种方法被称为“趋零截断”，即把-3.8转换成-3。在C99以前，不同的实现采用不同的方法。但是C99规定使用趋零截断。所以，应把-3.8转换成-3。\n运算符优先级考虑下面的代码：\n1butter=25.0+60.0*n/SCALE;这条语句中有加法、乘法和除法运算。先算哪一个？是25.0加上60.0，然后把计算的和85.0乘以n，再把结果除以SCALE？还是60.0乘以n，然后把计算的结果加上25.0，最后再把结果除以SCALE？还是其他运算顺序？假设n是6.0，SCALE是2.0，带入语句中计算会发现，第1种顺序得到的结果是255，第2种顺序得到的结果是192.5。C程序一定是采用了其他的运算顺序，因为程序运行该语句后，butter的值是205.0。\n显然，执行各种操作的顺序很重要。C 语言对此有明确的规定，通过运算符优先级来解决操作顺序的问题。每个运算符都有自己的优先级。正如普通的算术运算那样，乘法和除法的优先级比加法和减法高，所以先执行乘法和除法。如果两个运算符的优先级相同怎么办？如果它们处理同一个运算对象，则根据它们在语句中出现的顺序来执行。对大多数运算符而言，这种情况都是按从左到右的顺序进行（=运算符除外）。因此，语句：\n1butter=25.0+60.0*n/SCALE;的运算顺序是：\n12360.0*n　　　　　/*首先计算表达式中的*或/（假设n的值是6，所以60.0*n得360.0）*/360.0/SCALE　　 /*然后计算表达式中第2个*或*/25.0+180　　　　　/*最后计算表达式里第1个+或-，结果为205.0（假设SCALE的值是2.0）许多人喜欢用表达式树（expression tree）来表示求值的顺序，如图5.3所示。该图演示了如何从最初的表达式逐步简化为一个值。\n\n如何让加法运算在乘法运算之前执行？可以这样做：\n1flour=(25.0+60.0*n)/SCALE;最先执行圆括号中的部分。圆括号内部按正常的规则执行。该例中，先执行乘法运算，再执行加法运算。执行完圆括号内的表达式后，用运算结果除以SCALE。\n表5.1总结了到目前为止学过的运算符优先级。\n\n注意正号（加号）和负号（减号）的两种不同用法。结合律栏列出了运算符如何与运算对象结合。例如，一元负号与它右侧的量相结合，在除法中用除号左侧的运算对象除以右侧的运算对象。\n优先级和求值顺序运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定所有的顺序。C 给语言的实现者留出选择的余地。考虑下面的语句：\n1y=6*12+5*20;当运算符共享一个运算对象时，优先级决定了求值顺序。例如上面的语句中，12是和+运算符的运算对象。根据运算符的优先级，乘法的优先级比加法高，所以先进行乘法运算。类似地，先对 5 进行乘法运算而不是加法运算。简而言之，先进行两个乘法运算6 * 12和5 * 20，再进行加法运算。但是，优先级并未规定到底先进行哪一个乘法。C 语言把主动权留给语言的实现者，根据不同的硬件来决定先计算前者还是后者。可能在一种硬件上采用某种方案效率更高，而在另一种硬件上采用另一种方案效率更高。无论采用哪种方案，表达式都会简化为 72 + 100，所以这并不影响最终的结果。但是，读者可能会根据乘法从左往右的结合律，认为应该先执行+运算符左边的乘法。结合律只适用于共享同一运算对象运算符。例如，在表达式12 / 3 * 2中，/和运算符的优先级相同，共享运算对象3。因此，从左往右的结合律在这种情况起作用。表达式简化为4 * 2，即8（如果从右往左计算，会得到12/6，即2，这种情况下计算的先后顺序会影响最终的计算结果）。在该例中，两个*运算符并没有共享同一个运算对象，因此从左往右的结合律不适用于这种情况。\n学以致用\n接下来，我们在更复杂的示例中使用以上规则，请看程序清单5.7。\n1234567891011程序清单5.7 rules.c程序/* rules.c -- 优先级测试 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　top,　score;    top = score = -(2 + 5) * 6 + (4 + 3 * (2 + 3));    printf(\"top　=　%d,　score　=　%d\\n\",　top,　score);    return　0;&#125;该程序会打印什么值？先根据代码推测一下，再运行程序或阅读下面的分析来检查你的答案。\n首先，圆括号的优先级最高。先计算-(2 + 5) * 6中的圆括号部分，还是先计算(4 + 3 * (2 + 3))中的圆括号部分取决于具体的实现。圆括号的最高优先级意味着，在子表达式-(2 + 5) * 6中，先计算(2 + 5)的值，得7。然后，把一元负号应用在7上，得-7。现在，表达式是：\n1top = score = -7 * 6 + (4 + 3 * (2 + 3))下一步，计算2 + 3的值。表达式变成：\n1top = score = -7 * 6 + (4 + 3 * 5)接下来，因为圆括号中的*比+优先级高，所以表达式变成：\n1top = score = -7 * 6 + (4 + 15)然后，表达式为：\n1top = score = -7 * 6 + 19-7乘以6后，得到下面的表达式：\n1top = score = -42 + 19然后进行加法运算，得到：\n1top = score = -23现在，-23被赋值给score，最终top的值也是-23。记住，=运算符的结合律是从右往左。\n其他运算符C语言有大约40个运算符，有些运算符比其他运算符常用得多。前面讨论的是最常用的，本节再介绍4个比较有用的运算符。\nsizeof运算符和size_t类型读者在第3章就见过sizeof运算符。回顾一下，sizeof运算符以字节为单位返回运算对象的大小（在C中，1字节定义为char类型占用的空间大小。过去，1字节通常是8位，但是一些字符集可能使用更大的字节）。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float），则必须用圆括号将其括起来。程序清单5.8演示了这两种用法。\n1234567891011121314程序清单5.8 sizeof.c程序// sizeof.c -- 使用sizeof运算符// 使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu#include &lt;stdio.h&gt;int　main(void)&#123;    int　n=0;    size_t intsize;    intsize=sizeof(int);    printf(\"n=%d,　n　has　%zd　bytes;　all　ints　have　%zd　bytes.\\n\",n,sizeof　n,intsize);    return　0;&#125;C 语言规定，sizeof 返回 size_t 类型的值。这是一个无符号整数类型，但它不是新类型。前面介绍过，size_t是语言定义的标准类型。C有一个typedef机制（第14章再详细介绍），允许程序员为现有类型创建别名。例如，\n1typedef double real;这样，real就是double的别名。现在，可以声明一个real类型的变量：\n1real deal; // 使用typedef编译器查看real时会发现，在typedef声明中real已成为double的别名，于是把deal创建为double 类型的变量。类似地，C 头文件系统可以使用 typedef 把 size_t 作为 unsigned int 或unsigned long的别名。这样，在使用size_t类型时，编译器会根据不同的系统替换标准类型。\nC99 做了进一步调整，新增了%zd 转换说明用于 printf()显示 size_t 类型的值。如果系统不支持%zd，可使用%u或%lu代替%zd。\n求模运算符：%求模运算符（modulus operator）用于整数运算。求模运算符给出其左侧整数除以右侧整数的余数（remainder）。例如，13 % 5（读作“13求模5”）得3，因为13比5的两倍多3，即13除以5的余数是3。求模运算符只能用于整数，不能用于浮点数。\n乍一看会认为求模运算符像是数学家使用的深奥符号，但是实际上它非常有用。求模运算符常用于控制程序流。例如，假设你正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用。这种情况可以在程序中对月份求模3（即，month % 3），并检查结果是否为0。如果为0，便加进额外的费用。等学到第7章的if语句后，读者会更明白。\n程序清单5.9演示了%运算符的另一种用途。同时，该程序也演示了while循环的另一种用法。\n1234567891011121314151617181920212223程序清单5.9 min_sec.c程序// min_sec.c -- 把秒数转换成分和秒#include　&lt;stdio.h&gt;#define SEC_PER_MIN 60　　　　　 // 1分钟60秒int　main(void)&#123;    int sec,min,left;    printf(\"Convert　seconds　to　minutes　and　seconds!\\n\");    printf(\"Enter　the　number　of　seconds　(&lt;=0　to　quit):\\n\");    scanf(\"%d\",&amp;sec);　　　　　 // 读取秒数    while(sec&gt;0)    &#123;        min=sec/SEC_PER_MIN;　　// 截断分钟数        left=sec%SEC_PER_MIN;　 // 剩下的秒数        printf(\"%d　seconds　is　%d　minutes,　%d　seconds.\\n\",sec,        min,left);        printf(\"Enter　next　value　(&lt;=0　to　quit):\\n\");        scanf(\"%d\",&amp;sec);    &#125;    printf(\"Done!\\n\");    return　0;&#125;该程序的输出如下：\n\n程序清单5.2使用一个计数器来控制while循环。当计数器超出给定的大小时，循环终止。而程序清单5.9则通过scanf()为变量sec获取一个新值。只要该值为正，循环就继续。当用户输入一个0或负值时，循环退出。这两种情况设计的要点是，每次循环都会修改被测试的变量值。\n负数求模如何进行？C99规定“趋零截断”之前，该问题的处理方法很多。但自从有了这条规则之后，如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数：\n123411/5\t得2，\t\t11 % 5\t\t得111/-5\t得-2，\t11 % -2\t\t得1-11/-5\t得2，\t\t-11 % -5\t得-1-11/5\t得-2，\t-11 % 5\t\t得-1如果当前系统不支持C99标准，会显示不同的结果。实际上，标准规定：无论何种情况，只要a和b都是整数值，便可通过a - (a/b)*b来计算a%b。例如，可以这样计算-11%5：\n1-11-(-11/5)*5=-11-(-2)*5=-11-(-10)=-1递增运算符：++递增运算符（increment operator）执行简单的任务，将其运算对象递增1。该运算符以两种方式出现。第1种方式，++出现在其作用的变量前面，这是前缀模式；第2种方式，++出现在其作用的变量后面，这是后缀模式。两种模式的区别在于递增行为发生的时间不同。我们先解释它们的相似之处，再分析它们不同之处。程序清单5.10中的程序示例演示了递增运算符是如何工作的。\n程序清单5.10 add_one.c程序\n1234567891011121314/* add_one.c -- 递增：前缀和后缀 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int ultra=0,super=0;    while(super&lt;5)    &#123;        super++;        ++ultra;        printf(\"super=%d,ultra=%d\\n\",super,ultra);    &#125;    return　0;&#125;运行该程序后，其输出如下：\n12345super　=　1,　ultra　=　1super　=　2,　ultra　=　2super　=　3,　ultra　=　3super　=　4,　ultra　=　4super　=　5,　ultra　=　5该程序两次同时计数到5。用下面两条语句分别代替程序中的两条递增语句，程序的输出相同：\n12super　=　super　+　1;ultra　=　ultra　+　1;这些都是很简单的语句，为何还要创建两个缩写形式？原因之一是，紧凑结构的代码让程序更为简洁，可读性更高。这些运算符让程序看起来很美观。例如，可重写程序清单5.2（shoes2.c）中的一部分代码：\n1234567shoe=3.0;while(shoe&lt;18.5)&#123;    foot=SCALE*size+ADJUST;    printf(\"%10.1f　%20.2f　inches\\n\",shoe,foot);    ++shoe;&#125;但是，这样做也没有充分利用递增运算符的优势。还可以这样缩短这段程序：\n123456shoe　=　2.0;while　(++shoe&lt;18.5)&#123;    foot = SCALE*shoe + ADJUST;    printf(\"%10.1f　%20.2f　inches\\n\",　shoe,　foot);&#125;如上代码所示，把变量的递增过程放入while循环的条件中。这种结构在C语言中很普遍，我们来仔细分析一下。\n首先，这样的while循环是如何工作的？很简单。shoe的值递增1，然后和18.5作比较。如果递增后的值小于18.5，则执行花括号内的语句一次。然后，shoe的值再递增1，重复刚才的步骤，直到shoe的值不小于18.5为止。注意，我们把shoe的初始值从3.0改为2.0，因为在对foot第1次求值之前， shoe已经递增了1（见图5.4）。\n\n其次，这样做有什么好处？它使得程序更加简洁。更重要的是，它把控制循环的两个过程集中在一个地方。该循环的主要过程是判断是否继续循环（本例中，要检查鞋子的尺码是否小于 18.5），次要过程是改变待测试的元素（本例中是递增鞋子的尺码）。\n如果忘记改变鞋子的尺码，shoe的值会一直小于18.5，循环不会停止。计算机将陷入无限循环（infinite loop）中，生成无数相同的行。最后，只能强行关闭这个程序。把循环测试和更新循环放在一处，就不会忘记更新循环。\n但是，把两个操作合并在一个表达式中，降低了代码的可读性，让代码难以理解。而且，还容易产生计数错误。\n递增运算符的另一个优点是，通常它生成的机器语言代码效率更高，因为它和实际的机器语言指令很相似。尽管如此，随着商家推出的C编译器越来越智能，这一优势可能会消失。一个智能的编译器可以把x = x + 1当作++x对待。\n最后，递增运算符还有一个在某些场合特别有用的特性。我们通过程序清单5.11来说明。\n1234567891011121314程序清单5.11 post_pre.c程序/* post_pre.c -- 前缀和后缀 */#include &lt;stdio.h&gt;int main(void)&#123;    int a=1,b=1;    int a_post,　pre_b;    a_post=a++;　// 后缀递增    pre_b=++b;　 // 前缀递增    printf(\"a　 a_post　　b　　pre_b　\\n\");    printf(\"%1d　%5d　%5d　%5d\\n\",　a,　a_post,　b,　pre_b);    return　0;&#125;如果你的编译器没问题，那么程序的输出应该是：\n12a\ta_post\tb\t\tpre_b2\t1\t\t2　　　　2a和b都递增了1，但是，a_post是a递增之前的值，而b_pre是b递增之后的值。这就是++的前缀形式和后缀形式的区别（见图5.5）。\n\n12a_post = a++;　　　// 后缀：使用a的值乊后，递增ab_pre= ++b;　　　　// 前缀：使用b的值乊前，递增b单独使用递增运算符时（如，ego++;），使用哪种形式都没关系。但是，当运算符和运算对象是更复杂表达式的一部分时（如上面的示例），使用前缀或后缀的效果不同。例如，我们曾经建议用下面的代码：\n1while (++shoe &lt; 18.5)该测试条件相当于提供了一个鞋子尺码到18的表。如果使用shoe++而不是++shoes，尺码表会增至19。因为shoe会在与18.5进行比较之后才递增，而不是先递增再比较。\n当然，使用下面这种形式也没错：\n1shoe = shoe + 1;只不过，有人会怀疑你是否是真正的C程序员。\n在学习本书的过程中，应多留意使用递增运算符的例子。自己思考是否能互换使用前缀和后缀形式，或者当前环境是否只能使用某种形式。\n如果使用前缀形式和后缀形式会对代码产生不同的影响，那么最为明智的是不要那样使用它们。例如，不要使用下面的语句：\n1234b=++i; // 如果使用i++，会得到不同的结果应该使用下列语句：++i;　　　// 第1行b=i; // 如果第1行使用的是i++，幵不会影响b的值尽管如此，有时小心翼翼地使用会更有意思。所以，本书会根据实际情况，采用不同的写法。\n递减运算符：–每种形式的递增运算符都有一个递减运算符（decrement operator）与之对应，用–代替++即可：\n12--count; // 前缀形式的递减运算符count--; // 后缀形式的递减运算符程序清单5.12演示了计算机可以是位出色的填词家。\n程序清单5.12 bottles.c程序\n1234567891011121314#include　&lt;stdio.h&gt;#define　MAX　100int　main(void)&#123;    int　count　=　MAX　+　1;    while(--count&gt;0)　    &#123;        printf(\"%d　bottles　of　spring　water　on　the　wall,\"\"%d　bottles　of　spring　water!\\n\",　count,　count);        printf(\"Take　one　down　and　pass　it　around,\\n\");        printf(\"%d　bottles　of　spring　water!\\n\\n\",　count　-　1);    &#125;    return　0;&#125;该程序的输出如下（篇幅有限，省略了中间大部分输出）：\n12345678910100　bottles　of　spring　water　on　the　wall,　100　bottles　of　spring　water!Take　one　down　and　pass　it　around,99　bottles　of　spring　water!99　bottles　of　spring　water　on　the　wall,　99　bottles　of　spring　water!Take　one　down　and　pass　it　around,98　bottles　of　spring　water!...1 bottles of spring water on the wall, 1 bottles of spring water!Take one down and pass it around,0 bottles of spring water!显然，这位填词家在复数的表达上有点问题。在学完第7章中的条件运算符后，可以解决这个问题。\n顺带一提，&gt;运算符表示“大于”，&lt;运算符表示“小于”，它们都是关系运算符（relational operator）。我们将在第6章中详细介绍关系运算符。\n优先级递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，x*y++表示的是(x)*(y++)，而不是(x*y)++。不过后者无效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值），而组合x*y本身不是可修改的左值。\n不要混淆这两个运算符的优先级和它们的求值顺序。假设有如下语句：\n123y=2;n=3;nextnum=(y+n++)*6;nextnum的值是多少？把y和n的值带入上面的第3条语句得：\n1nextnum = (2 + 3)*6 = 5*6 = 30n的值只有在被使用之后才会递增为4。根据优先级的规定，++只作用于n，不作用与y + n。除此之外，根据优先级可以判断何时使用n的值对表达式求值，而递增运算符的性质决定了何时递增n的值。\n如果n++是表达式的一部分，可将其视为“先使用n，再递增”；而++n则表示“先递增n，再使用”。\n不要自作聪明如果一次用太多递增运算符，自己都会糊涂。例如，利用递增运算符改进 squares.c 程序（程序清单5.4），用下面的while循环替换原程序中的while循环：\n1234while　(num&lt;21)&#123;    printf(\"%10d %10d\\n\", num, num*num++);&#125;这个想法看上去不错。打印num，然后计算num*num得到平方值，最后把num递增1。但事实上，修改后的程序只能在某些系统上能正常运行。该程序的问题是：当 printf()获取待打印的值时，可能先对最后一个参数（ ）求值，这样在获取其他参数的值之前就递增了num。所以，本应打印：\n15　　　　　　 25却打印成：\n16　　　　　　 25它甚至可能从右往左执行，对最右边的num（++作用的num）使用5，对第2个num和最左边的num使用6，结果打印出：\n16　　　　　　 30在C语言中，编译器可以自行选择先对函数中的哪个参数求值。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。\n类似这样的语句，也会导致一些麻烦：\n1ans = num/2 + 5*(1 + num++);同样，该语句的问题是：编译器可能不会按预想的顺序来执行。你可能认为，先计算第1项（num/2），接着计算第2项（5*(1 + num++)）。但是，编译器可能先计算第2项，递增num，然后在num/2中使用num递增后的新值。因此，无法保证编译器到底先计算哪一项。\n还有一种情况，也不确定：\n12n=3;y=n++ + n++;可以肯定的是，执行完这两条语句后，n的值会比旧值大2。但是，y的值不确定。在对y求值时，编译器可以使用n的旧值（3）两次，然后把n递增1两次，这使得y的值为6，n的值为5。或者，编译器使用n的旧值（3）一次，立即递增n，再对表达式中的第2个n使用递增后的新值，然后再递增n，这使得 y 的值为 7，n 的值为 5。两种方案都可行。对于这种情况更精确地说，结果是未定义的，这意味着 C标准并未定义结果应该是什么。\n遵循以下规则，很容易避免类似的问题：\n如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；\n如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。\n另一方面，对于何时执行递增，C 还是做了一些保证。我们在本章后面的“副作用和序列点”中学到序列点时再来讨论这部分内容。\n表达式和语句在前几章中，我们已经多次使用了术语表达式（expression）和语句（statement）。现在，我们来进一步学习它们。C的基本程序步骤由语句组成，而大多数语句都由表达式构成。因此，我们先学习表达式。\n表达式表达式（expression）由运算符和运算对象组成（前面介绍过，运算对象是运算符操作的对象）。最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式。下面是一些表达式：\n12345674-64+21a*(b+c/d)/20q=5*2x=++q%3q&gt;3如你所见，运算对象可以是常量、变量或二者的组合。一些表达式由子表达式（subexpression）组成（子表达式即较小的表达式）。例如，c/d是上面例子中a*(b + c/d)/20的子表达式。\n每个表达式都有一个值\nC 表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序来执行操作。在上面我们列出的表达式中，前几个都很清晰明了。但是，有赋值运算符（=）的表达式的值是什么？这些表达式的值与赋值运算符左侧变量的值相同。因此，表达式q = 5*2作为一个整体的值是10。那么，表达式q &gt; 3的值是多少？这种关系表达式的值不是0就是1，如果条件为真，表达式的值为1；如果条件为假，表达式的值为0。表5.2列出了一些表达式及其值：\n\n虽然最后一个表达式看上去很奇怪，但是在C中完全合法（但不建议使用），因为它是两个子表达式的和，每个子表达式都有一个值。\n语句语句（statement）是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以分号结尾。因此，\n1legs = 4只是一个表达式（它可能是一个较大表达式的一部分），而下面的代码则是一条语句：\n1legs = 4;最简单的语句是空语句：\n1;　　 //空语句C把末尾加上一个分号的表达式都看作是一条语句（即，表达式语句）。因此，像下面这样写也没问题：\n128;3 + 4;但是，这些语句在程序中什么也不做，不算是真正有用的语句。更确切地说，语句可以改变值或调用函数：\n123x = 25;++x;y = sqrt(x);虽然一条语句（或者至少是一条有用的语句）相当于一条完整的指令，但并不是所有的指令都是语句。考虑下面的语句：\n1x = 6 + (y = 5);该语句中的子表达式y = 5是一条完整的指令，但是它只是语句的一部分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况下的语句（即，简单语句）。\n到目前为止，读者已经见过多种语句（不包括空语句）。程序清单5.13演示了一些常见的语句。\n1234567891011121314程序清单5.13 addemup.c程序/* addemup.c -- 几种常见的语句 */#include　&lt;stdio.h&gt;int main(void)　　　　　　　　 /* 计算前20个整数的和　 */&#123;    int count, sum;　　　　　/* 声明[[1\\]](part0010.xhtml#annot17)　　　　　　 */    count = 0;　　　　　　　　 /* 表达式语句　　　　　 */    sum = 0;　　　　　　　　　 /* 表达式语句　　　　　 */    while (count++ &lt; 20)　　　 /* 迭代语句　　　　　　*/    sum　=　sum　+　count;    printf(\"sum = %d\\n\", sum); /* 表达式语句[[2\\]](part0010.xhtml#annot18)　　　 */    return 0;　　　　　　　/* 跳转语句　　　　　　　　 */&#125;下面我们讨论程序清单 5.13。到目前为止，相信读者已经很熟悉声明了。尽管如此，我们还是要提醒读者：声明创建了名称和类型，并为其分配内存位置。注意，声明不是表达式语句。也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值：\n1int port /* 不是表达式，没有值 */赋值表达式语句在程序中很常用：它为变量分配一个值。赋值表达式语句的结构是，一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾。注意，在while循环中有一个赋值表达式语句。赋值表达式语句是表达式语句的一个示例。\n函数表达式语句会引起函数调用。在该例中，调用printf()函数打印结果。while语句有3个不同的部分（见图5.6）。首先是关键字while；然后，圆括号中是待测试的条件；最后如果测试条件为真，则执行while循环体中的语句。该例的while循环中只有一条语句。可以是本例那样的一条语句，不需要用花括号括起来，也可以像其他例子中那样包含多条语句。多条语句需要用花括号括起来。这种语句是复合语句，稍后马上介绍。\n\nwhile语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂。在后面的章节里，我们会遇到许多这样的语句。\n副作用和序列点\n我们再讨论一个C语言的术语副作用（side effect）。副作用是对数据对象或文件的修改。例如，语句：\n1states = 50;它的副作用是将变量的值设置为50。副作用？这似乎更像是主要目的！但是从C语言的角度看，主要目的是对表达式求值。给出表达式4 + 6，C会对其求值得10；给出表达式states = 50，C会对其求值得50。对该表达式求值的副作用是把变量states的值改为50。跟赋值运算符一样，递增和递减运算符也有副作用，使用它们的主要目的就是使用其副作用。\n类似地，调用 printf()函数时，它显示的信息其实是副作用（printf()的返回值是待显示字符的个数）。\n序列点（sequence point）是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在 C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。后面我们要讨论的一些运算符也有序列点。另外，任何一个完整表达式的结束也是一个序列点。\n什么是完整表达式？所谓完整表达式（full expression），就是指这个表达式不是另一个更大表达式的子表达式。例如，表达式语句中的表达式和while循环中的作为测试条件的表达式，都是完整表达式。\n序列点有助于分析后缀递增何时发生。例如，考虑下面的代码：\n12while(guests++&lt;10)printf(\"%d　\\n\",guests);对于该例，C语言的初学者认为“先使用值，再递增它”的意思是，在printf()语句中先使用guests，再递增它。但是，表达式guests++ &lt; 10是一个完整的表达式，因为它是while循环的测试条件，所以该表达式的结束就是一个序列点。因此，C 保证了在程序转至执行 printf()之前发生副作用（即，递增guests）。同时，使用后缀形式保证了guests在完成与10的比较后才进行递增。\n现在，考虑下面这条语句：\n1y=(4+x++)+(6+x++);表达式4+x++不是一个完整的表达式，所以C无法保证x在子表达式4+x++求值后立即递增x。这里，完整表达式是整个赋值表达式语句，分号标记了序列点。所以，C 保证程序在执行下一条语句之前递增x两次。C并未指明是在对子表达式求值以后递增x，还是对所有表达式求值后再递增x。因此，要尽量避免编写类似的语句。\n复合语句（块）复合语句（compound statement）是用花括号括起来的一条或多条语句，复合语句也称为块（block）。shoes2.c程序使用块让while语句包含多条语句。比较下面两个程序段：\n12345678910111213/* 程序段 1 */index　=　0;while(index++&lt;10)sam = 10 * index + 2;printf(\"sam　=　%d\\n\",　sam);/* 程序段 2 */index　=　0;while(index++&lt;10)&#123;    sam = 10 * index + 2;    printf(\"sam　=　%d\\n\",　sam);&#125;程序段1，while循环中只有一条赋值表达式语句。没有花括号，while语句从while这行运行至下一个分号。循环结束后，printf()函数只会被调用一次。\n程序段2，花括号确保两条语句都是while循环的一部分，每执行一次循环就调用一次printf()函数。根据while语句的结构，整个复合语句被视为一条语句（见图5.7）。\n\n提示 风格提示\n再看一下前面的两个while程序段，注意循环体中的缩进。缩进对编译器不起作用，编译器通过花括号和while循环的结构来识别和解释指令。这里，缩进是为了让读者一眼就可以看出程序是如何组织的。\n程序段2中，块或复合语句放置花括号的位置是一种常见的风格。另一种常用的风格是：\n1234while(index++&lt;10)&#123;    sam = 10*index + 2;    printf(\"sam　=　%d　\\n\",　sam);&#125;这种风格突出了块附属于while循环，而前一种风格则强调语句形成一个块。对编译器而言，这两种风格完全相同。\n总而言之，使用缩进可以为读者指明程序的结构。\n总结 表达式和语句\n表达式：\n表达式由运算符和运算对象组成。最简单的表达式是不带运算符的一个常量或变量（如，22 或beebop）。更复杂的例子是55 + 22和vap = 2 * (vip + (vup = 4))。\n语句：\n到目前为止，读者接触到的语句可分为简单语句和复合语句。简单语句以一个分号结尾。如下所示：\n赋值表达式语句:　　　toes = 12;\n函数表达式语句:　　　printf(&quot;%d\\n&quot;, toes);\n空语句:　　　　　\n1　;　 /* 什么也不做 */复合语句（或块）由花括号括起来的一条或多条语句组成。如下面的while语句所示：\n123456while(years&lt;100)&#123;    wisdom=wisdom * 1.05;    printf(\"%d　%d\\n\",　years,　wisdom);    years=　years　+　1;&#125;类型转换通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C 不会像 Pascal那样停在那里死掉，而是采用一套规则进行自动类型转换。虽然这很便利，但是有一定的危险性，尤其是在无意间混合使用类型的情况下（许多UNIX系统都使用lint程序检查类型“冲突”。如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题）。最好先了解一些基本的类型转换规则。\n1.当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int，如有必要会被转换成unsigned int（如果short与int的大小相同，unsigned short就比int大。这种情况下，unsigned short会被转换成unsigned int）。在K&amp;R那时的C中，float会被自动转换成double（目前的C不是这样）。由于都是从较小类型转换为较大类型，所以这些转换被称为升级（promotion）。\n2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。\n3.类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。\n4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。\n5.当作为函数参数传递时，char和short被转换成int，float被转换成double。第9章将介绍，函数原型会覆盖自动升级。\n类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦。原因很简单：较低类型可能放不下整个数字。\n例如，一个8位的char类型变量储存整数101没问题，但是存不下22334。\n如果待转换的值与目标类型不匹配怎么办？这取决于转换涉及的类型。待赋值的值与目标类型不匹配时，规则如下。\n1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256。\n2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。\n3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。\n如果把一个浮点值转换成整数类型会怎样？当浮点类型被降级为整数类型时，原来的浮点值会被截断。例如，23.12和23.99都会被截断为23，-23.5会被截断为-23。\n程序清单5.14演示了这些规则。\n程序清单5.14 convert.c程序\n1234567891011121314151617181920/* convert.c -- 自动类型转换 */#include　&lt;stdio.h&gt;int　main(void)&#123;    char ch;    int i;    float　fl;    fl=i=ch='C';　　　　　　　　　　　　　　　　　 /* 第9行　*/    printf(\"ch = %c, i = %d, fl = %2.2f\\n\", ch, i, fl);　/* 第10行 */    ch=ch+1;　　　　　　　　　　　　　　　　　　　　 /* 第11行 */    i=fl+2 * ch;　　　　　　　　　　　　　　　　　　 /* 第12行 */    fl=2.0 * ch + i;　　　　　　　　　　　　　　　　　 /* 第13行 */    printf(\"ch = %c, i = %d, fl = %2.2f\\n\", ch, i, fl);　/* 第14行 */    ch= 1107;　　　　　　　　　　　　　　　　　　　　　 /* 第15行 */    printf(\"Now ch = %c\\n\", ch);　　　　　　　　　　　　 /* 第16行 */    ch= 80.89;　　　　　　　　　　　　　　　　　　　　　/* 第17行 */    printf(\"Now ch = %c\\n\", ch);　　　　　　　　　　　　 /* 第18行 */    return　0;&#125;运行convert.c后输出如下：\n1234ch=C,　i=67,fl=67.00ch=D,　i=203,fl=339.00Now ch=SNow　ch=P在我们的系统中，char是8位，int是32位。程序的分析如下。\n第9行和第10行：字符&#39;C&#39;被作为1字节的ASCII值储存在ch中。整数变量i接受由&#39;C&#39;转换的整数，即按4字节储存67。最后，fl接受由67转换的浮点数67.00。\n第11行和第14行：字符变量&#39;C&#39;被转换成整数67，然后加1。计算结果是4字节整数68，被截断成1字节储存在ch中。根据%c转换说明打印时，68被解释成&#39;D&#39;的ASCII码。\n第12行和第14行：ch的值被转换成4字节的整数（68），然后2乘以ch。为了和fl相加，乘积整数（136）被转换成浮点数。计算结果（203.00f）被转换成int类型，并储存在i中。\n第13行和第14行：ch的值（’D’，或68）被转换成浮点数，然后2乘以ch。为了做加法，i的值（203）被转换为浮点类型。计算结果（339.00）被储存在fl中。\n第15行和第16行：演示了类型降级的示例。把ch设置为一个超出其类型范围的值，忽略额外的位后，最终ch的值是字符S的ASCII码。或者，更确切地说，ch的值是1107 % 256，即83。\n第17行和第18行：演示了另一个类型降级的示例。把ch设置为一个浮点数，发生截断后，ch的值是字符P的ASCII码。\n强制类型转换运算符通常，应该避免自动类型转换，尤其是类型降级。但是如果能小心使用，类型转换也很方便。我们前面讨论的类型转换都是自动完成的。然而，有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到强制类型转换（cast），即在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型名构成了强制类型转换运算符（cast operator），其通用形式是：\n1(type)用实际需要的类型（如，long）替换type即可。\n考虑下面两行代码，其中mice是int类型的变量。第2行包含两次int强制类型转换。\n12mice = 1.6 + 1.7;mice = (int)1.6 + (int)1.7;第1 行使用自动类型转换。首先，1.6和1.7相加得3.3。然后，为了匹配int 类型的变量，3.3被类型转换截断为整数3。第2行，1.6和1.7在相加之前都被转换成整数（1），所以把1+1的和赋给变量mice。本质上，两种类型转换都好不到哪里去，要考虑程序的具体情况再做取舍。\n一般而言，不应该混合使用类型（因此有些语言直接不允许这样做），但是偶尔这样做也是有用的。C语言的原则是避免给程序员设置障碍，但是程序员必须承担使用的风险和责任。\n总结 C的一些运算符\n下面是我们学过的一些运算符。\n赋值运算符：\n1=将其右侧的值赋给左侧的变量\n算术运算符：\n+　　　 将其左侧的值与右侧的值相加\n-　　　　将其左侧的值减去右侧的值\n-　　　　作为一元运算符，改变其右侧值的符号\n*　　　 将其左侧的值乘以右侧的值\n/　　　　将其左侧的值除以右侧的值，如果两数都是整数，计算结果将被截断\n%　　　　当其左侧的值除以右侧的值时，取其余数（只能应用于整数）\n++　　　 对其右侧的值加1（前缀模式），或对其左侧的值加1（后缀模式）\n--　　　 对其右侧的值减1（前缀模式），或对其左侧的值减1（后缀模式）\n其他运算符：\nsizeof　　　 获得其右侧运算对象的大小（以字节为单位），运算对象可以是一个被圆括号括起来的类型说明符，如sizeof(float)，或者是一个具体的变量名、数组名等，如sizeoffoo(类型名)\n强制类型转换运算符将其右侧的值转换成圆括号中指定的类型，如(float)9把整数9转换成浮点数9.0\n带参数的函数现在，相信读者已经熟悉了带参数的函数。要掌握函数，还要学习如何编写自己的函数（在此之前，读者可能要复习一下程序清单2.3中的butler()函数，该函数不带任何参数）。程序清单5.15中有一个pound()函数，打印指定数量的#号（该符号也叫作编号符号或井号）。该程序还演示了类型转换的应用。\n程序清单5.15 pound.c程序\n1234567891011121314151617181920/* pound.c -- 定义一个带一个参数的函数　*/#include　&lt;stdio.h&gt;void pound(int n);// ANSI函数原型声明int　main(void)&#123;    int times=5;    char ch='!';　　 // ASCII码是33    float　f=6.0f;    pound(times);　　　// int类型的参数    pound(ch);　　　　　// 和pound((int)ch);相同    pound(f);　　　　　 // 和pound((int)f);相同    return　0;&#125;void pound(int n)　　　// ANSI风格函数头&#123;　　　　　　　　　　　　 // 表明该函数接受一个int类型的参数    while(n--&gt;0)    printf(\"#\");    printf(\"\\n\");&#125;运行该程序后，输出如下：\n123############################################首先，看程序的函数头：\n1void pound(int n)如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。由于该函数接受一个 int 类型的参数，所以圆括号中包含一个int类型变量n的声明。参数名应遵循C语言的命名规则。\n声明参数就创建了被称为形式参数（formal argument或formal parameter，简称形参）的变量。该例中，形式参数是 int 类型的变量 n。像 pound(10)这样的函数调用会把 10 赋给 n。在该程序中，调用pound(times)就是把 times 的值（5）赋给 n。我们称函数调用传递的值为实际参数（actual argument或actual parameter），简称实参。所以，函数调用pound(10)把实际参数10传递给函数，然后该函数把10赋给形式参数（变量n）。也就是说，main()中的变量times的值被拷贝给pound()中的新变量n。\n注意 实参和形参\n形参为变量\n在英文中，argument和parameter经常可以互换使用，但是C99标准规定了：对于actual argument或actual parameter使用术语argument（译为实参）；对于formal argument或formal parameter使用术语parameter（译为形参）。为遵循这一规定，我们可以说形参是变量，实参是函数调用提供的值，实参被赋给相应的形参。因此，在程序清单5.15中，times是pound()的实参，n是pound()的形参。类似地，在函数调用pound(times + 4)中，表达式times + 4的值是该函数的实参。\n变量名是函数私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突。如果在pound()中用times代替n，那么这个times与main()中的times不同。也就是说，程序中出现了两个同名的变量，但是程序可以区分它们。\n现在，我们来学习函数调用。第1 个函数调用是pound(times)，times的值5被赋给n。因此， printf()函数打印了5个井号和1个换行符。第2个函数调用是pound(ch)。这里，ch是char类型，被初始化为!字符，在ASCII中ch的数值是33。但是pound()函数的参数类型是int，与char不匹配。程序开头的函数原型在这里发挥了作用。原型（prototype）即是函数的声明，描述了函数的返回值和参数。pound()函数的原型说明了两点：\n该函数没有返回值（函数名前面有void关键字）；\n该函数有一个int类型的参数。\n该例中，函数原型告诉编译器pound()需要一个int类型的参数。相应地，当编译器执行到pound(ch)表达式时，会把参数ch自动转换成int类型。在我们的系统中，该参数从1字节的33变成4字节的33，所以现在33的类型满足函数的要求。与此类似，最后一次调用是pound(f)，使得float类型的变量被转换成合适的类型。\n在ANSI C之前，C使用的是函数声明，而不是函数原型。函数声明只指明了函数名和返回类型，没有指明参数类型。为了向下兼容，C现在仍然允许这样的形式：\n1void pound(); /* ANSI C乊前的函数声明 */如果用这条函数声明代替pound.c程序中的函数原型会怎样？第 1 次函数调用，pound(times)没问题，因为times是int类型。第2次函数调用，pound(ch)也没问题，因为即使缺少函数原型，C也会把char和short类型自动升级为int类型。第3次函数调用，pound(f)会失败，因为缺少函数原型，float 会被自动升级为 double，这没什么用。虽然程序仍然能运行，但是输出的内容不正确。在函数调用中显式使用强制类型转换，可以修复这个问题：\n1pound ((int)f); // 把f强制类型转换为正确的类型注意，如果f的值太大，超过了int类型表示的范围，这样做也不行。\n示例程序程序清单5.16演示了本章介绍的几个概念，这个程序对某些人很有用。程序看起来很长，但是所有的计算都在程序的后面几行中。我们尽量使用大量的注释，让程序看上去清晰明了。请通读该程序，稍后我们会分析几处要点。\n程序清单5.16 running.c程序\n1234567891011121314151617181920212223242526272829303132333435363738//　running.c　--　A　useful　program　for　runners#include　&lt;stdio.h&gt;const int S_PER_M=60;　　　　　　　 // 1分钟的秒数const int S_PER_H=3600;　　　　　　// 1小时的分钟数const double M_PER_K=0.62137;　　 // 1公里的英里数int　main(void)&#123;    double distk, distm;　 // 跑过的距离（分别以公里和英里为单位）    double rate;　　　　　　 // 平均速度（以英里/小时为单位）    int min, sec;　　　　　 // 跑步用时（以分钟和秒为单位）    int time;　　　　　　　　// 跑步用时（以秒为单位）    double mtime;　　　　　 // 跑1英里需要的时间，以秒为单位    int mmin, msec;　　　　 // 跑1英里需要的时间，以分钟和秒为单位    printf(\"This　program　converts　your　time　for　a　metric　race\\n\");    printf(\"to　a　time　for　running　a　mile　and　to　your　average\\n\");    printf(\"speed　in　miles　per　hour.\\n\");    printf(\"Please　enter,　in　kilometers,　the　distance　run.\\n\");    scanf(\"%lf\", &amp;distk);　　　　　　// %lf表示读取一个double类型的值    printf(\"Next　enter　the　time　in　minutes　and　seconds.\\n\");    printf(\"Begin　by　entering　the　minutes.\\n\");    scanf(\"%d\",　&amp;min);    printf(\"Now　enter　the　seconds.\\n\");    scanf(\"%d\",　&amp;sec);    time=S_PER_M * min+sec;　　 // 把时间转换成秒    distm=M_PER_K*distk;　　　　// 把公里转换成英里    rate=distm/time * S_PER_H;　// 英里/秒×秒/小时 = 英里/小时    mtime=(double)time / distm;　// 时间/距离 = 跑1英里所用的时间    mmin=(int)mtime / S_PER_M;　 // 求出分钟数    msec=(int)mtime % S_PER_M;　 // 求出剩余的秒数    printf(\"You　ran　%1.2f　km　(%1.2f　miles)　in　%d　min,　%d　sec.\\n\",    distk,　distm,　min,　sec);    printf(\"That　pace　corresponds　to　running　a　mile　in　%d　min,　\",    mmin);    printf(\"%d　sec.\\nYour　average　speed　was　%1.2f　mph.\\n\",　msec,    rate);    return　0;&#125;程序清单5.16使用了min_sec程序（程序清单5.9）中的方法把时间转换成分钟和秒，除此之外还使用了类型转换。为什么要进行类型转换？因为程序在秒转换成分钟的部分需要整型参数，但是在公里转换成英里的部分需要浮点运算。我们使用强制类型转换运算符进行了显式转换。\n实际上，我们曾经利用自动类型转换编写这个程序，即使用int类型的mtime来强制时间计算转换成整数形式。但是，在测试的11个系统中，这个版本的程序在1个系统上无法运行，这是由于编译器（版本比较老）没有遵循C规则。而使用强制类型转换就没有问题。对读者而言，强制类型转换强调了转换类型的意图，对编译器而言也是如此。\n下面是程序清单5.16的输出示例：\n12345678910111213This　program　converts　your　time　for　a　metric　raceto　a　time　for　running　a　mile　and　to　your　averagespeed　in　miles　per　hour.Please　enter,　in　kilometers,　the　distance　run.10.0Next　enter　the　time　in　minutes　and　seconds.Begin　by　entering　the　minutes.36Now　enter　the　seconds.23You　ran　10.00　km　(6.21　miles)　in　36　min,　23　sec.That　pace　corresponds　to　running　a　mile　in　5　min,　51　sec.Your average speed was 10.25 mph.关键概念C 通过运算符提供多种操作。每个运算符的特性包括运算对象的数量、优先级和结合律。当两个运算符共享一个运算对象时，优先级和结合律决定了先进行哪项运算。每个 C表达式都有一个值。如果不了解运算符的优先级和结合律，写出的表达式可能不合法或者表达式的值与预期不符。这会影响你成为一名优秀的程序员。\n虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型。因此，C会进行自动类型转换。尽管如此，不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样，就不用担心出现不必要的自动类型转换。\n本章小结C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符。一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个运算对象的运算符（如负号和 sizeof）称为一元运算符，需要两个运算对象的运算符（如加法运算符和乘法运算符）称为二元运算符。\n表达式由运算符和运算对象组成。在C语言中，每个表达式都有一个值，包括赋值表达式和比较表达式。运算符优先级规则决定了表达式中各项的求值顺序。当两个运算符共享一个运算对象时，先进行优先级高的运算。如果运算符的优先级相等，由结合律（从左往右或从右往左）决定求值顺序。\n大部分语句都以分号结尾。最常用的语句是表达式语句。用花括号括起来的一条或多条语句构成了复合语句（或称为块）。while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句。\n在C语言中，许多类型转换都是自动进行的。当char和short类型出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为int类型；float类型在函数参数中时，会被升级为double类型。在K&amp;R C（不是ANSI C）下，表达式中的float也会被升级为double类型。当把一种类型的值赋给另一种类型的变量时，值将被转换成与变量的类型相同。当把较大类型转换成较小类型时（如，long转换成short，或 double 转换成 float），可能会丢失数据。根据本章介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型。\n定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中就可以使用该值了。\n","plink":"https://dxsummer.gitee.io/posts/d0061c8b/"},{"title":"string.h中常用函数","date":"2020-05-30T07:08:03.000Z","date_formatted":{"ll":"2020年5月30日","L":"2020/05/30","MM-DD":"05-30"},"updated":"2020-06-08T01:58:31.331Z","content":"strlen计算字符串长度\n1size_t strlen(const char *str)计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。\n函数实现：\n1234567int Strlen(const char *str)&#123;\tassert(str);\tint len = 0;\twhile ((*str++) != '\\0')len++;\treturn len;&#125;strcpy字符串复制\n1char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest。\n函数实现：\n1234567char *Strcpy(char *dst, const char *src)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile ((*dst++ = *src++) != '\\0');\treturn tmp;&#125;strncpy复制连续的n个字符\n1char *strncpy(char *dest, const char *src, size_t n)把 src 所指向的字符串复制到 dest，最多复制 n 个字符。\n函数实现：\n1234567891011121314151617181920char *Strncpy(char *dst, const char *src, int len)&#123;\tassert(dst&amp;&amp;src);\tchar *tmp = dst;\tint offset = 0;\tif (len &gt; strlen(src))\t&#123;\t\toffset = len - strlen(src);\t\tlen = strlen(src);\t&#125;\twhile (len--)\t&#123;\t\t*dst++ = *src++;\t&#125;\twhile (offset--)\t&#123;\t\t*dst++ = '\\0';\t&#125;\treturn tmp;&#125;strcat把一个字符串连接到另一个字符串后面\n1char *strcat(char *dest, const char *src)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。\n函数实现：\n123456789char *Strcat(char *dst, const char* src)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile (*dst++);\tdst--;\twhile (*dst++ = *src++);\treturn tmp;&#125;strncat把连续的n个字符连接到另一个字符串后面\n1char *strncat(char *dest, const char *src, size_t n)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。\n函数实现：\n12345678910111213char *Strncat(char *dst, const char* src, int len)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile (*dst++);\tdst--;\twhile (len--)\t&#123;\t\t*dst++ = *src++;\t&#125;\t*dst = '\\0';\treturn tmp;&#125;示例：\n12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123;    char str0[20] = \"Test:\";    char str1[20] = \"Welcome9999\";    char str2[20] = \" To \";    char str3[20] = \"0123Beijing55\";    char tmp[100];    strcpy(tmp, str0);    puts(tmp);      //Test:    strncpy(tmp, str1, 7);  //取st1前7个字符    puts(tmp);      //Welcome    strcat(tmp, str2);      //连接str2    puts(tmp);    strncat(tmp, str3 + 4, 7);  //取str3+4之后的7个字符    puts(tmp);    return 0;&#125;输出结果：\n\nstrchr查找某字符在字符串中首次出现的位置指针，如果不存在则返回NULL\n1char *strchr(const char *str, int c)在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。\n函数实现：\n12345678char* My_strchr(char *s, char c)&#123;    while(*s != '\\0' &amp;&amp; *s != c)    &#123;        ++s;    &#125;    return *s==c ? s : NULL;&#125;示例：\n1234567891011121314151617181920212223#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;    char string[20] = \"This is a string\";    char *ptr1, *ptr2;    char c1 = 'r', c2 = 'b';    ptr1 = strchr(string, c1);    ptr2 = strchr(string, c2);    if(ptr1)        printf(\"字符1:%c 的位置是: %s \\n\",c1,ptr1);    else        printf(\"字符1:%c 未找到 \\n\", c1);    if(ptr2)        printf(\"字符2:%c 的位置是: %s \\n\",c2,ptr2);    else        printf(\"字符2:%c 未找到 \\n\", c2);    return 0;&#125;输出结果：\n\nstrcmp字符串比较\n1int strcmp(const char *str1, const char *str2)把 str1 所指向的字符串和 str2 所指向的字符串进行比较。\n设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。\n函数实现：\n123456789101112131415161718int Strcmp(char const *s1, char const *s2)&#123;\tassert(s1&amp;&amp;s2);\twhile (*s1 == *s2 &amp;&amp; *s1 != '\\0' &amp;&amp; *s2 != '\\0')\t&#123;\t\ts1++;\t\ts2++;\t&#125;\tif (*s1 == *s2)\t&#123;\t\treturn 0;\t&#125;\telse if (*s1 &gt; *s2)\t&#123;\t\treturn 1;\t&#125;\treturn -1;&#125;示例：\n123456789101112131415161718#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;    char str1[20] = \"abc\";    char str2[20] = \"abc\";    char str3[20] = \"bbc\";    int r1, r2, r3;    r1 = strcmp(str1, str2);    r2 = strcmp(str1, str3);    r3 = strcmp(str3, str1);    printf(\"r1 = %d, r2 = %d, r3 = %d \\n\", r1, r2, r3);    return 0;&#125;输出结果：\n\nstrstr字符串查找\n1char *strstr(const char *haystack, const char *needle)在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。\n函数实现：\n12345678910111213141516171819char *Strstr(char const *s1, char const *s2)&#123;\tassert(s1&amp;&amp;s2);\tconst char *ps1, *ps2;\tps1 = s1;\tps2 = s2;\twhile (*ps1)\t&#123;\t\tconst char *tmp = ps1;\t\twhile (*tmp++ == *ps2++);\t\tif (*ps2 == '\\0')\t\t&#123;\t\t\treturn (char*)ps1;\t\t&#125;\t\tps2 = s2;\t\tps1++;\t&#125;\treturn NULL;&#125;strncmp1int strncmp(const char *str1, const char *str2, size_t n)把 str1 和 str2 进行比较，最多比较前 n 个字节。\n函数实现：\n12345678910int Strncmp(char const *s1, char const *s2, int len)&#123;\tassert(s1&amp;&amp;s2);\twhile (len-- &amp;&amp; *s1 == *s2 &amp;&amp; *s1 != '\\0' &amp;&amp; *s2 != '\\0')\t&#123;\t\ts1++;\t\ts2++;\t&#125;\treturn *s1 - *s2;&#125;memcpy内存复制\n1void *memcpy(void *dest, const void *src, size_t n)从 src 复制 n 个字符到 dest。\n函数实现\n1234567891011void *Memcpy(char *dst, char const *src, int len)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\tconst char *s = src;\twhile (len--)\t&#123;\t\t*dst++ = *src;\t&#125;\treturn tmp;&#125;","plink":"https://dxsummer.gitee.io/posts/52078792/"},{"title":"模拟电子技术基础笔记","date":"2020-05-28T10:29:09.000Z","date_formatted":{"ll":"2020年5月28日","L":"2020/05/28","MM-DD":"05-28"},"updated":"2020-06-08T01:55:42.762Z","content":"半导体二极管半导体的基本知识导体：自然界中很容易导电的物质称为导体，金属一般都是导体。\n\n绝缘体：有的物质几乎不导电，称为绝缘体，如橡皮、陶瓷、塑料和石英。\n\n半导体：另有一类物质的导电特性处于导体和绝缘体之间，称为半导体，如锗、硅、砷化镓和一些硫化物、氧化物等。\n当受外界热和光的作用时，它的导电能力明显变化。\n往纯净的半导体中掺入某些杂质，会使它的导电能力明显改变。\n\n本征半导体：完全纯净的、结构完整的半导体晶体。\n\n在常温下，由于热激发，使一些价电子获得足够的能量而脱离共价键的束缚，成为自由电子，同时共价键上留下一个空位，称为空穴。\n\n载流子可以运动的带电粒子\n\n\n本征半导体中电流\n自由电子移动产生的电流\n空穴移动产生的电流\n\n本征半导体的导电能力取决于载流子的浓度。温度越高，载流子的浓度越高。因此本征半导体的导电能力越强，温度是影响半导体性能的一个重要的外部因素，这是半导体的一大特点。\n\n杂质半导体N 型半导体：自由电子浓度大大增加的杂质半导体，也称为（电子半导体）。\n在硅或锗晶体中掺入少量的五价元素磷（或锑），晶体点阵中的某些半导体原子被杂质取代，磷原子的最外层有五个价电子，其中四个与相邻的半导体原子形成共价键，必定多出一个电子，这个电子几乎不受束缚，很容易被激发而成为自由电子，这样磷原子就成了不能移动的带正电的离子。每个磷原子给出一个电子，称为施主原子。\n由施主原子提供的电子，浓度与施主原子相同。\n本征半导体中成对产生的电子和空穴。\n掺杂浓度远大于本征半导体中载流子浓度，所以，自由电子浓度远大于空穴浓度。\n\n自由电子称为多数载流子（多子），空穴称为少数载流子（少子）\n\n\nP 型半导体：空穴浓度大大增加的杂质半导体，也称为（空穴半导体）。\n​    \nP 型半导体中空穴是多子，电子是少子\n\n杂质半导体的示意表示法PN结及半导体二极管PN 结的形成在同一片半导体基片上，分别制造P 型半导体和N 型半导体，经过载流子的扩散，在它们的交界面处就形成了PN 结。\n所以扩散和漂移这一对相反的运动最终达到平衡，相当于两个区之间没有电荷运动，空间电荷区的厚度固定不变。\n空间电荷区中没有载流子。\n空间电荷区中内电场阻碍P中的空穴、N区 中的电子（都是多子）向对方运动（扩散运动）。\nP 区中的电子和 N区中的空穴（都是少子），数量有限，因此由它们形成的电流很小。\nPN结的单向导电性PN 结加上正向电压、正向偏置的意思都是： P 区加正、N 区加负电压。\nPN 结加上反向电压、反向偏置的意思都是： P区加负、N 区加正电压。\n半导体二极管最大整流电流 IOM\n二极管长期使用时，允许流过二极管的最大正向平均电流。\n\n反向击穿电压UBR\n二极管反向击穿时的电压值。击穿时反向电流剧增，二极管的单向导电性被破坏，甚至过热而烧坏。手册上给出的最高反向工作电压UWRM一般是UBR的一半。\n\n反向电流 IR\n指二极管加反向峰值工作电压时的反向电流。反向电流大，说明管子的单向导电性差，因此反向电流越小越好。反向电流受温度的影响，温度越高反向电流越大。硅管的反向电流较小，锗管的反向电流要比硅管大几十到几百倍。\n\n","plink":"https://dxsummer.gitee.io/posts/dbbc2d17/"},{"title":"note和小tag标签","date":"2020-05-26T01:55:31.000Z","date_formatted":{"ll":"2020年5月26日","L":"2020/05/26","MM-DD":"05-26"},"updated":"2020-06-08T01:54:16.062Z","content":"/* note语法示例 */\n绿色\n红色\n黄色\n灰色\n蓝色12345&lt;p class&#x3D;&#39;div-border green&#39;&gt;绿色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border red&#39;&gt;红色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border yellow&#39;&gt;黄色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border grey&#39;&gt;灰色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border blue&#39;&gt;蓝色&lt;&#x2F;p&gt;/* 小tag标签语法示例 */\n红色小标签绿色小标签蓝色小标签黄色小标签灰色小标签\n12345&lt;span class&#x3D;&quot;inline-tag red&quot;&gt;红色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag green&quot;&gt;绿色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag blue&quot;&gt;蓝色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag yellow&quot;&gt;黄色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag grey&quot;&gt;灰色小标签&lt;&#x2F;span&gt;绿色1&lt;p class&#x3D;&#39;div-border green left right&#39;&gt;绿色&lt;&#x2F;p&gt;","plink":"https://dxsummer.gitee.io/posts/5d6d7b2d/"},{"title":"添加全局吸底APlayer","date":"2020-05-21T09:47:34.000Z","date_formatted":{"ll":"2020年5月21日","L":"2020/05/21","MM-DD":"05-21"},"updated":"2020-06-08T01:52:16.996Z","content":"如果你使用了butterfly做hexo主题可以向界面加入一些装饰,但butterfly使用了pug模板,所以与其他主题可能有些区别\n\nlive2d看板娘,能聊天,能玩耍,能换装等等这得感谢大神stevenjoezhang为原本只能显示一个模型的live2d插件添加了许多功能如果对位置什么的没有很大的要求的话,直接打开themes\\Butterfly\\layout\\includes\\head.pug结尾加入一行\n1script(src&#x3D;&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;stevenjoezhang&#x2F;live2d-widget&#x2F;autoload.js&#39;)就行了\n当然你会发现直接这样加的话,阅读Page时,打开TOC的话,看板娘会被遮住所以建议调整看板娘位置前往live2d-widget 下载\n解压后将autoload.js第二行的位置改成你挂载在服务器上的autoload.js所在文件夹的绝对路径比如autoload.js在科大ftp的/public_html/js/live2d-widget/目录下,这里就要改成http://home.ustc.edu.cn/~username/js/live2d-widget/ (科大ftp的根目录是/public_html/)然后修改waifu.css里面的 #waifu下的 left: 0;将这一行改成right: 70px;\n123456789#waifu &#123;\tbottom: -1000px;\tleft: 0;           &#x2F;&#x2F;这一行改成right: 70px;\tline-height: 0;\tposition: fixed;\ttransform: translateY(3px);\ttransition: transform .3s ease-in-out, bottom 3s ease-in-out;\tz-index: 1;&#125;将head.pug添加的src的autoload.js的路径改成你上传的路径就行了\n\n全局吸底APlayer打开themes\\Butterfly\\layout\\includes\\head.pug结尾加一句\n1include .&#x2F;third-party&#x2F;aplayer.pug然后在themes\\Butterfly\\layout\\includes\\third-party\\里面新建一个文件叫 aplayer.pug ,内容如下\n123456if theme.aplayer &amp;&amp; theme.aplayer.enable\t.aplayer(data-id&#x3D;theme.aplayer.id data-server&#x3D;theme.aplayer.server data-type&#x3D;theme.aplayer.type data-fixed&#x3D;theme.aplayer.fixed data-mini&#x3D;theme.aplayer.mini data-listFolded&#x3D;theme.aplayer.listFolded data-order&#x3D;theme.aplayer.order data-preload&#x3D;theme.aplayer.preload)\teach item in theme.aplayer.css\t\tlink(rel&#x3D;&#39;stylesheet&#39;, href&#x3D;item)\teach item in theme.aplayer.js\t\tscript(src&#x3D;item)然后打开butterfly.yml(如果你没有启用的话,就打开themes\\Butterfly_config.yml) 加入以下内容\n1234567891011121314aplayer:  enable: true  js:    - https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;aplayer&#x2F;1.10.1&#x2F;APlayer.min.js    - https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;meting@1.2.0&#x2F;dist&#x2F;Meting.min.js  css:    - https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;aplayer&#x2F;1.10.1&#x2F;APlayer.min.css  id: 2661264578  server: netease   type: playlist  fixed: &#39;true&#39;  order: random  preload: none  listFolded: &#39;false&#39;然后重新生成就可以看到 aplayer了,这里的id是我的网易云歌单号,可以修改成别的.但是浏览Page时会发现 aplayer会和 TOC(怎么又是它) 的切换按钮重合打开themes\\Butterfly\\source\\css\\_global\\index.styl修改第61行\n123456789#toggle-sidebar  position: fixed  bottom: $sidebar-icon-top           &#x2F;&#x2F;这里改成bottom: 70px  left: $sidebar-icon-left  z-index: 100  font-size: $sidebar-icon-size  &#x2F;&#x2F; opacity: 0  cursor: pointer  transition: all .2s\n","plink":"https://dxsummer.gitee.io/posts/ae7c64e9/"},{"title":"vscode下级文件夹与上级文件夹并列，文件夹折叠问题解决","date":"2020-05-19T10:16:02.000Z","date_formatted":{"ll":"2020年5月19日","L":"2020/05/19","MM-DD":"05-19"},"updated":"2020-06-08T01:56:37.672Z","content":"今天在创建文件夹的时候出现了创建的下级文件夹和上级文件夹并列，紧凑排列的情况，这里在最新版本的vs code中解决的途径如下：\n\n\n解决办法如下：\n\n点击上方文件，之后选择首选项，再进入设置；\n在用户中选择功能菜单栏下的资源管理器，在资源管理器中找到Compact Folders,将对号勾掉即可；\n\n\n这是改完后的效果，也是我们习惯的效果。\n\n\n","plink":"https://dxsummer.gitee.io/posts/98214d27/"},{"title":"GO语言环境搭建","date":"2020-05-19T07:18:47.000Z","date_formatted":{"ll":"2020年5月19日","L":"2020/05/19","MM-DD":"05-19"},"updated":"2020-06-08T01:53:48.832Z","content":"注意：\nGo语言1.14版本之后推荐使用`go modules`管理以来，也不再需要把代码写在GOPATH目录下了下载\n下载地址\n\nGo官网下载地址：https://golang.org/dl/\n\nGo官方镜像站（推荐）：https://golang.google.cn/dl/\n\n\n版本的选择\n\nWindows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。\n安装\nWindows安装\n\n此安装实例以 64位Win10系统安装 Go1.14.1可执行文件版本为例。将上一步选好的安装包下载到本地。\n\n双击下载好的文件，然后按照下图的步骤安装即可。\n\n\nLinux下安装\n\n如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。\n我们在版本选择页面选择并下载好go1.14.1.linux-amd64.tar.gz文件：\n1wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.14.1.linux-amd64.tar.gz将下载好的文件解压到/usr/local目录下：\n1tar -zxvf go1.14.1.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local  # 解压如果提示没有权限，加上sudo以root用户的身份再运行。执行完就可以在/usr/local/下看到go目录了。\n配置环境变量： Linux下有两个文件可以配置环境变量，其中/etc/profile是对所有用户生效的；$HOME/.profile是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。\n12export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;goexport PATH&#x3D;$PATH:$GOROOT&#x2F;bin修改/etc/profile后要重启生效，修改$HOME/.profile后使用source命令加载$HOME/.profile文件即可生效。 检查：\n12~ go versiongo version go1.14.1 linux&#x2F;amd64\nMac下安装\n\n下载可执行文件版，直接点击下一步安装即可，默认会将go安装到/usr/local/go目录下。\n检查上一步安装过程执行完毕后，可以打开终端窗口，输入go version命令，查看安装的Go版本。\n\n配置GOROOT和GOPATHGOROOT和GOPATH都是环境变量，其中GOROOT是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为GOPATH设置一个默认目录，参见下表。\nGOPATH在不同操作系统平台上的默认值\n\n平台GOPATH默认值举例\n\nWindows%USERPROFILE%/goC:\\Users\\用户名\\go\n\nUnix$HOME/go/home/用户名/go\n可以通过以下方法查看默认的GOPATH目录：\n\n我们只需要记住默认的GOPATH路径在哪里就可以了，并且默认情况下 GOROOT下的bin目录及GOPATH下的bin目录都已经添加到环境变量中了，我们也不需要额外配置了。\n\nGOPROXY\n\nGo1.14版本之后，都推荐使用go mod模式来管理依赖环境了，也不再强制我们把代码必须写在GOPATH下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）\n设置GOPATH路径（GOPATH路径是我们的工作区）\n1go env -w GOPATH&#x3D;我们自己的工作区路径例如我的就设为 /Users/naonao/go\n什么都别管，先打开GoMOD，再配置代理\n在这里感谢「七牛云」为我们中国区的Golang开发者提供的代理服务\n12$ go env -w GO111MODULE&#x3D;on$ go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct做到这2点后，我们现在就可以打开我们的VsCode（再次感谢七牛云，从此以后我们再也不用到Github以及Golang.org上clone到本地进行install了）\n查看GO相关的环境变量1go envGo项目结构在进行Go语言开发的时候，我们的代码总是会保存在$GOPATH/src目录下。在工程经过go build、go install或go get等指令后，会将下载的第三方包源代码文件放在$GOPATH/src目录下， 产生的二进制可执行文件放在 $GOPATH/bin目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。\n如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加$GOPATH/src目录的源代码即可。bin 和 pkg 目录的内容无需版本控制。\n适合个人开发者我们知道源代码都是存放在GOPATH的src目录下，那我们可以按照下图来组织我们的代码。\n\n目前流行的项目结构Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用顶级域名来作为包名的前缀，这样就不担心项目名冲突的问题了。\n因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。\n\n举个例子：张三和李四都有一个名叫studygo的项目，那么这两个包的路径就会是：\n1import &quot;github.com&#x2F;zhangsan&#x2F;studygo&quot;和\n1import &quot;github.com&#x2F;lisi&#x2F;studygo&quot;以后我们从github上下载别人包的时候，如：\n1go get github.com&#x2F;jmoiron&#x2F;sqlx那么，这个包会下载到我们本地GOPATH目录下的src/github.com/jmoiron/sqlx。\n适合企业开发场景\nGo开发编辑器Go采用的是UTF-8编码的文本文件存放源代码，理论上使用任何一款文本编辑器都可以做Go语言开发，这里推荐使用VS Code和Goland。 VS Code是微软开源的编辑器，而Goland是jetbrains出品的付费IDE。\n我们这里使用VS Code 加插件做为go语言的开发工具。\nVS Code介绍VS Code全称Visual Studio Code，是微软公司开源的一款免费现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，支持 Win、Mac 以及 Linux平台。\n虽然不如某些IDE功能强大，但是它添加Go扩展插件后已经足够胜任我们日常的Go开发。\n下载与安装VS Code官方下载地址：https://code.visualstudio.com/Download\n三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。\n\n双击下载好的安装文件，双击安装即可。\n配置安装中文简体插件点击左侧菜单栏最后一项管理扩展，在搜索框中输入chinese ，选中结果列表第一项，点击install安装。\n安装完毕后右下角会提示重启VS Code，重启之后你的VS Code就显示中文啦！\n\nVSCode主界面介绍：\n\n安装go扩展现在我们要为我们的VS Code编辑器安装Go扩展插件，让它支持Go语言开发。\n\n变更编辑器主题依次点击设置-&gt;颜色主题，\n\n会弹出如下窗口：\n\n可以根据自己的喜好选择相应的主题。\n安装Go语言开发工具包在座Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。\n在此之前请先设置GOPROXY，打开终端执行以下命令：\n1go env -w GOPROXY=https://goproxy.cn,directWindows平台按下Ctrl+Shift+P，Mac平台按Command+Shift+P，这个时候VS Code界面会弹出一个输入框，如下图：\n\n我们在这个输入框中输入&gt;go:install，下面会自动搜索相关命令，我们选择Go:Install/Update Tools这个命令，按下图选中并会回车执行该命令（或者使用鼠标点击该命令）\n\n在弹出的窗口选中所有，并点击“确定”按钮，进行安装。\n\n然后会弹出如下窗口，开始安装工具：\n\n喝口水，等待所有工具都安装成功，如下图所示:\n\n配置VSCode开启自动保存按下图依次点击 文件-&gt;首选项-&gt;设置，\n打开设置页面就能看到自动保存相关配置如下图，可以根据自己的喜好选择自动保存的方式：\n配置代码片段快捷键还是按Ctrl/Command+Shift+P,按下图输入&gt;snippets，选择命令并执行：\n然后在弹出的窗口点击选择go选项：\n然后弹出如下页面：\n大家可以简单看下上面的注释，介绍了主要用法：\n12345“这里放个名字”:&#123;    &quot;prefix&quot;: &quot;这个是快捷键&quot;,    &quot;body&quot;: &quot;这里是按快捷键插入的代码片段&quot;,    &quot;description&quot;: &quot;这里放提示信息的描述&quot;&#125;其中$0表示最终光标提留的位置。 举个例子，我这里创建了两个快捷方式，一个是输入pln就会在编辑器中插入fmt.Println()代码；输入plf，就会插入fmt.Printf(&quot;&quot;)代码。\n123456789101112&#123;\t&quot;println&quot;:&#123;\t\t&quot;prefix&quot;: &quot;pln&quot;,\t\t&quot;body&quot;:&quot;fmt.Println($0)&quot;,\t\t&quot;description&quot;: &quot;println&quot;\t&#125;,\t&quot;printf&quot;:&#123;\t\t&quot;prefix&quot;: &quot;plf&quot;,\t\t&quot;body&quot;: &quot;fmt.Printf(\\&quot;$0\\&quot;)&quot;,\t\t&quot;description&quot;: &quot;printf&quot;\t&#125;&#125;把上面的代码，按下图方式粘贴到配置文件中，保存并关闭配置文件即可。\n添加如上配置后，保存。 我们打开一个go文件，测试一下效果：\n文章源于[Q1mi](https://www.liwenzhou.com/posts/Go/00_go_in_vscode/)","plink":"https://dxsummer.gitee.io/posts/c876fc85/"},{"title":"GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床","date":"2020-05-12T08:29:03.000Z","date_formatted":{"ll":"2020年5月12日","L":"2020/05/12","MM-DD":"05-12"},"updated":"2020-06-08T01:53:13.707Z","content":"GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床前言\n为什么要使用图床呢？\n\n因为在不同平台发布同一篇文章的时候，最一个痛苦的点就是，图片存储问题，各个平台的文件存储方式各不相同，无法直接 Ctrl + C 的方式一键搞定，为了解决这个问题，使用 MarkDown + 图床 的方式进行文章的写作，将图片放到一个统一的地方，在文章中引入图片外链。所谓图床，就是将图片储存到第三方静态资源库中，其返回给你一个 URL 进行获取图片。MarkDown 支持使用 URL 的方式显示图片，我想这也是程序员为什么对其偏爱的原因之一。作为程序员，你会发现，现在很多论坛和社区都开始支持使用 MarkDown，如果你没使用图床的情况下，你分享同一篇文章，你要在不同的平台，各自重新编辑排版一遍和上传图片一次。有了图床，情况就不一样了，Ctrl+C 的方式就搞定了，根本不用再 Check 文章内容一遍。\n\n图床的选择？\n\n微博图床：以前用的人比较多，从 2019 年 4 月开始开启了防盗链，凉凉\nSM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧\n其他小众图床：随时有挂掉的风险\nImgur 等国外图床：国内访问速度太慢，随时有被墙的风险\n大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说）\nGitHub 图床：免费，但是国内访问速度慢（不过没关系，利用 jsDelivr 提供的免费的 CDN 加速 速度足够了）\n使用流程新建 GitHub 仓库\n生成一个 Token\n配置 PicGo 并使用 jsdelivr 作为 CDN 加速\n使用 Imagine 进行图片压缩\n上传图片到 PicGo 并使用图床\n新建 GitHub 仓库登录/注册 GitHub\n新建一个仓库，填写好仓库名\n仓库描述\n将权限设置成 public\n根据需求选择是否为仓库初始化一个 README.md 描述文件\n\n新建 GitHub 仓库\n生成一个 Token点击用户头像 -&gt; 选择 Settings\n\nSettings\n点击 Developer settings\n\nDeveloper settings\n点击 Personal access tokens\n\nPersonal access tokens\n点击 Generate new token\n\nGenerate new token\n填写 Token 描述，勾选 repo，然后点击 Generate token 生成一个 Token\n\n填写 Token 描述\n获取 Token 密钥\n\n注意这个 Token 只会显示一次，自己先保存下来，或者等后面配置好 PicGo 后再关闭此网页\n\n\n获取 Token 密钥\n配置 PicGo 并使用 jsdelivr 作为 CDN 加速前往下载 PicGo（点击下载），安装好后开始配置图床\n设定仓库名：按照 用户名/图床仓库名 的格式填写\n设定分支名：master\n设定 Token：粘贴之前生成的 Token\n指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为 img 的文件夹，图片将会储存在此文件夹中\n设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名\n\n配置 PicGo\nText\n123Q：什么是 jsdelivr ?A：jsDelivr 为开发者提供免费公共 CDN 加速服务使用 Imagine 进行图片压缩通常情况下，图片大小都是超过 200KB 的，所以网页加载的时候会特别慢，一般我们会对图片进行压缩，这里我推荐 Imagine（点击下载） 支持全平台。\n\n使用 Imagine 进行图片压缩\n\nImagine 采用的是有损压缩，介意的可以忽略这一步\n\n顺便推荐一个无损压缩的网站：https://tinypng.com/\n上传图片到 PicGo 并使用图床配置好 PicGo 后，我们就可以进行高效创作了，将压缩后的图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的\n\n上传图片到 PicGo 并使用图床\n此外 PicGo 还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo 还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！\n文章源于\n[Sitoi](https://sitoi.cn/posts/39161.html)","plink":"https://dxsummer.gitee.io/posts/b6c34a37/"},{"title":"Step 2 了解英语中关键的关键—单词","date":"2020-05-11T09:36:38.000Z","date_formatted":{"ll":"2020年5月11日","L":"2020/05/11","MM-DD":"05-11"},"updated":"2020-06-10T12:20:22.610Z","content":"Day03形容词（含比较级&amp;最高级）形容词的用法\n形容词主要用来修饰名词或不定代词（some，no，every，all，each，both，much，many，（a）little，（a）few，other（s），another），表示人或事物的性质、状态和特征的词。形容词在句中作定语、补语及修饰从句等。例如：\nShe is a pretty girl.（她是一个漂亮的女孩。）He looks very happy.（他看起来很开心。）\n使用时机及用法定语：一般放在所修饰词的前面。\n\n动词补语：放在系动词后面。\n\n宾语补语：修饰句中宾语。\n\n副词从句：成为形容词短语从句，修饰主句。\n\n使用规则及要点修饰不定代词时置于其后：当形容词修饰由some-, any-, no-, every-这些字首所构成的不定代词时，形容词要放在这些不定代词之后。例如：\n\n There must be something wrong with my computer.（我的电脑出了点问题。）\n两个以上的形容词的顺序：\n当一个句子中，有两个以上的形容词用来修饰同一个名词时，其先后顺序为：（冠词＋数量＋性质＋大小＋形状＋新旧＋颜色＋国籍）＋名词。可背诵以下的例句辅助记忆：\n I have a beautiful little new white Chinese wooden table.（我有一张新的白色中式木桌，漂亮且小巧。）\n\n“The＋形容词”用来表示特定的人／物：\n用“The＋形容词”可用来表示特定的人或物，例如：the rich富人、the young年轻人、the old老人等。后面须接复数动词。\nWe should look after the old and love the young.（我们应该尊老爱幼。）\n\n\n两个以上形容词当定语置于最后：\n用and或or连接起来的两个形容词做定语时，一般把它们放在被修饰的名词后面，以进一步产生修饰作用。\nYou can take any dress, pink or blue.（你可以拿这两件裙子中的任何一条，粉红色或蓝色的都行。）\n\n\n修饰长宽高深及年龄置于名词之后：\n表示长、宽、高、深及年龄的形容词，应放在相应的名词之后。\nThe river is about two hundred meters long.（这条河大约两百米长。）\n\n\n形容词的比较级、最高级\n规则变化单音节词在字尾加-er / -est：单音节形容词在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：clean→cleaner→cleanest。\n\n单音节词以–e结尾在字尾加-r / -st：以–e结尾的单音节形容词，转变为比较级和最高级时，规则是在字尾加–r和–st。例如：wide→wider→widest。\n\n双音节（音节中含有两个元音音素，称为双音节单词；如：hello,alone,etc）词以-y, -er, -ow, -ble结尾在字尾加-er / -est：少数以-y, -er, -ow, -ble结尾的双音节形容词，在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：slow→slower→slowest。\n\n以-y结尾的形容词，去掉字尾-y加-ier / -iest：以–y结尾，但–y前是辅音字母的形容词的比较级和最高级是把-y去掉，加上–ier和-iest。例如：lonely→lonelier→loneliest。\n\n形容词字尾“辅元辅”重复字尾再加–er：当形容词或其字尾出现“辅音＋元音＋辅音”现象，也就是最后三个字母和音标的排列是“辅元辅”，在转变为比较级和最高级时，规则是要重复字尾，再加-er。例如：big→bigger→biggest。\n\n三音节词和多音节词，以more / most修饰：三个音节以上的形容词，则在其前加more / most，以形成比较级及最高级。另外注意，more / most后的形容词必须是原级。例如：beautiful→more beautiful→most beautiful。\n\n不规则变化\n比较级与最高级用法两个人或两种事物比较时，用比较级。\n 句型为“比较级＋than…”例如： Bob is taller than Jack.（鲍勃比杰克高。）\n\n三个或三个以上的人或事物比较，其中有一个在某一方面超过其他几个时，用最高级。\n 句型为“the＋最高级＋…in / of…”。例如： Bob is the tallest in his class.（鲍勃是他班上最高的。）\n\n表示双方程度相等时，用“…as＋形容词原级＋as…”句型，可译为“…和…一样”；表示双方程度不相等时，用“…not so / as＋形容词原级＋as…”句型，可译为“…和…不一样”或“…不如…”，例如：\n This box is as big as mine.（这个盒子和我的一样大。） He runs not so fast as me.（他跑得没我快。）\n\n表示“越来越……”可用“The＋形容词比较级……, the＋形容词比较级”。\n 例如：The more you study, the more you know.（你学习的越多，你就知道的越多。）\n\n表示程度越来越强，用“比较级＋and＋比较级”句型，可译为“越来越……”。例如：\n It is getting hotter and hotter.（天气变得越来越热。）\n\nmost同形容词连用，前面不加the，可表示极……，很……，非常……，十分……。例如：\n It’s most dangerous to be here.（在这儿实在很危险。）\n\n比较级前可以加副词修饰，以加强程度。例如：much, far, still, even, a lot, a little, a bit等等。例如：\n The rope is much longer than that one.（这条绳比那条绳长很多。）\n\n两者之间选择“哪一个更……”时，用句型“Which / Who＋is＋比较级，…or…?”，例如：\n Which is bigger, the sun or the moon?（太阳和月亮，哪一个更大？）\n\n表示“最……之一”时，用“one of＋the＋最高级”。例如：\n The light bulb is one of the most helpful inventions.（电灯泡是最有用的发明之一。）\n\n语法观念例句示范01．The sunset was a beautiful sight.日落是一种美丽的景象。\n02．He is the happiest man on earth.他是地球上最快乐的人。\n03．The film is boring.那个电影很枯燥。\n04．It’s an utter mystery.这完全是个迷。\n05．She looked embarrassed.她好像很尴尬。\n06．He is one of the greatest composers in the word.他是世界上最伟大的作曲家之一。\n07．It’s foolish of her to go alone.她单独出去太傻了。\n08．The black one is the more expensive of the two boxes.黑色的是这两个盒子当中最贵的。\n09．The more careful you are, the fewer mistakes you will make.你越仔细，犯的错误越少。\n10．Mountain climbing is one of the most dangerous sports.爬山是最危险的运动之一。\n语法观念辨析练习请选出正确的选项。\n01．The writer died before finishing his________book.\nA lateB laterC lastD latest.\n02．She got________that she couldn’t dance anymore.\nA very angrilyB too angrilyC too angryD so angry\n03．The sweater is very beautiful, but it’s________small.\nA too muchB much tooC manyD more\n04．She looks very________. I think she needs rest.\nA tiredB hardC wellD hardly.\n05．Lots of visitors come to visit Hamburg because she’s________city.\nA very a beautifulB quite a beautifulC so a beautifulD a quite beautiful\n06．- Which is________, the sun, the moon or the earth? —— Of course the moon.\nA smallB smallerC smallestD the smallest\n07．She isn’t so________at math as you are.\nA wellB goodC betterD best\n08．I have________to do today.\nA anything importantB something importantC important nothingD important something\n09．Mary writes________of the three.\nA betterB bestC goodD well\n10．My________brother is________than I.\nA elder, three years olderB older, olderC older, three years elderD elder, elder\n正确答案及题目译文：\n副词（含比较级&amp;最高级）副词主要用来修饰动词、形容词、其他副词或全句，用来说明时间、地点、程度、方式等概念的词。副词在句中主要作状语。副词可以分为时间副词、地点副词、方式副词、程度副词、频率副词等。\nShe speaks English quite well.（她英语说得相当好。）\n\nThey live frugally.（她们生活很节俭。）\n\n使用时机及用法\n使用时机及用法置于形容词前方，修饰形容词用。例如：\n\n置于动词前方，修饰动词用。例如：\n\n置于副词前方，修饰副词用。例如：\n\n置于介词短语前方，修饰介词短语用。例如：\n\n使用enough修饰形容词或其他副词时，置于被修饰词后方。例如：\n\n频率副词，例如：usually, always, often, never等，一般放在行为动词前，或是使役动词、助动词或be动词之后。例如：\n\n句中同时出现时间、地点的副词时，先地点再时间。\n\n某些副词形式相似，但要注意，两种形式的字义不同。例如：\n\nclose接近地←→closely仔细地，密切地\nwide广阔地，充分地←→widely广泛地\n副词的比较级、最高级副词和形容词一样有比较级和最高级。\n同级副词的比较→as＋原级＋as：\n\n比较级副词的比较→副词比较级＋than：\n\n最高级副词的比较→同形容词用法但不加the：\n\n副词的比较级与最高级规则变化：\n 同形容词，单音节词在字尾加-er / -est、以–y结尾的去掉字尾-y加-ier / -iest等。\n （速度）快地：fast→faster→fastest （时间）快地：soon→sooner→soonest （声音）大地：loud→louder→loudest\n\n副词的比较级与最高级常见之不规则变化：\n （程度）良好地：well→better→best （程度）不好地：badly→worse→worst （距离）远地：far→farther→farthest （时间）迟地：late→later→last （数量、程度）多地：much→more→most （数量、程度）少地：little→less→least （程度）糟糕地：poorly→worse→worst （程度）邪恶地：ill→worse→worst\n\n语法观念例句示范01．He knew London very well.他对伦敦很熟悉。\n02．You need to form the habit of reading carefully.你需要养成仔细阅读的习惯。\n03．Please listen to me carefully.请认真听我说。\n04．Her pronunciation is very good.她的发音很棒。\n05．He didn’t study hard enough.他学习不够刻苦。\n06．Tom looked at me suspiciously.汤姆怀疑地看着我。\n07．I sometimes stay up all night.我有时会熬夜。\n语法观念辨析练习请填入正确时态的副词。\n01．My purse was stolen on the bus yesterday.____(Fortunate), there was no money in it.\n02．He put on his coat and went out________(quick).\n03．It’s snowing hard. You must drive________(careful).\n04．I used to smoke________(heavy) but I give it up three years ago.\n05．What have you been doing________(late)?\n06．He thinks________(high) of my opinion.\n07．He is________(strong) enough to carry the heavy box.\n08．These oranges taste________(good).\n正确答案及题目译文：\n动词短语（不可分离vs．可分离）\n所谓的动词短语，是指由动词加上介词／副词所组成的短语。其短语意义有时与原先单独动词的字义不同，并且有多种字义。英语中的动词短语依照结构分为两种：不可分离的动词短语（动词＋介词），及可分离的动词短语（动词＋副词）。\n不可分离动词短语句型结构：（不及物）动词＋介词＋宾语\n不可分离动词短语中，常常是不及物动词连接介词，宾语必须接在后面。\n\n常见的此类动词短语有look after, look for, ask for, care about, laugh at, hear of等，所组成的动词短语字义通常不变。\nDon’t laugh at others.（不要嘲笑别人。）\nThey didn’t look after the children properly.（她们没有正确地照顾孩子们。）\n\n可分离动词短语句型结构：\n（及物）动词＋宾语＋副词\n\n（及物）动词＋副词＋宾语\n可分离动词短语是及物动词与副词可以被分开，并可以在中间加入宾语，也可以把宾语放在副词后面。\n\n\n副词改变原动词字义：\n可分离动词短语中的副词可置于动词后修饰动词，使得动词改变原本的意思，而产生新的字义。\n\n此类常见的动词短语有：give up, find out, think over, pick up, point out, hand in等。\n\n名词放在副词之前或之后：可分离动词短语中，如果宾语是名词，既可放在副词前面，又可放在副词后面。\n\n人称代名词、反身代词放介副词之前：可分离动词短语中，如果宾语是人称代名词或反身代词，则放在副词前面。\n\n语法观念例句示范01．The police are looking into the case.\n警察们在调查那件案子。\n02．They turned down my offer.\n他们拒绝了我的提议。\n03．Something unexpected has turned up.\n出现了令人意外的情况。\n04．This paper comes out once a week.\n这份报纸每星期出版一次。\n05．The meeting has been called off.\n会议被取消了。\n06．I filled in an application form.\n我填写了申请表。\n07．Mr. Ericsson, please put it down.\n艾瑞克森先生，请把东西放下来。\n08．Please don’t forget to hand it in.\n请不要忘了把它交上来。\n09．I can’t figure out why you said that.\n我不能理解你为什么那么说。\n10．I won’t let him down in any way.\n无论如何我是不会让他失望的。\n语法观念辨析练习01．没有人能够解释他的怪异行为。（account for）\n\n02．火车被大雾阻挡而晚点了。（hold up）\n\n03．我在公园等了她很长时间，但是她没有出现。（turn up）\n\n04．请勿践踏草坪！（keep off）\n\n05．如果我这次饶恕了你，你就能保证下次不会这么做了吗？（let off）\n\n06．不要把今天的事情拖到明天做。（pull off）\n\n07．别受骗上当。（take in）\n\n08．请关门。（shut off）\n\n09．你昨天买的这条裙子很漂亮，快穿上吧。（put on）\n\n10．明天早上记得叫我起床。（wake up）\n\n正确答案及题目译文：\n\nDay04系动词vs．感官动词\n系动词是用来补充描述和指明事物的，常用形容词来补充说明主语的不足，使得整句意思更完整，常用的系动词有seem, appear, look, feel, sound, taste, become, get, turn, smell, grow等；感官动词是表示人的感觉的动词，常见的感官动词有feel, hear, sound, see, taste, smell, look at等。\n系动词本质\n系动词是在主语和补语之间起连接功能的动词\n\n补语特性及句型结构\n系动词＋形容词\n\n系动词＋like＋名词\n\n系动词所连接的表语一般为形容词。若要连接名词时可以在系动词后加“like”，例如：\nThe story sounds interesting.（这个故事听起来很有趣。）\nIt sounds like an interesting story.（听起来是个有趣的故事。）\n\n状态的改变\n状态的改变：become, get, grow\nbecome, get, grow等系动词可用来表示“从一种状态变为另一种状态”，并且可以搭配使用进行时，表示（越来越……）。\nI am getting more and more tired.（我变得越来越累。）\n\n感官动词\n本质\n表达人类感受的动词。\n感官动词是表示人类感觉、感受的动词，故称为感官动词。可作完全及物动词或不完全及物动词，例如：listen to, hear, watch, see, feel等。\n   I feel sick today.（我今天觉得不舒服。）\n\n句型结构及特性\n不完全及物动词＋宾语＋动词原形→表示全部过程\n\n不完全及物动词＋宾语＋现在分词→表示正在进行的动作\n I saw the old lady cross the road.（我看到老太太过马路。）\n I saw the old lady crossing the road.（我看见老太太正在过马路。）\n\n\n被动语态\n   感官动词用于被动语态，“V原形”改为“to+V”：\n   感官动词用于被动语态，后面原有动词原形要改为带to的不定式，例如：\n   I hear the boy sing every day.\nThe boy is heard to sing every day.\n（我每天都听到那个男孩唱歌。）\n\n语法观念例句示范01．His suggestion sounds ridiculous.\n他的建议听起来很可笑。\n\n02．The soup tastes good.\n这汤的味道尝起来不错。\n\n03．He becomes lazy.\n他变懒了。\n\n04．She feels nervous before the exam.\n考试前她很紧张。\n\n05．It sounds like a good idea.\n听起来是个不错的主意。\n\n06．The weather usually turns cold in the end of August.\n天气通常在八月底开始变冷。\n\n07．You get fat again.\n你又变胖了。\n\n08．The weather is getting hotter every day.\n天气一天天越来越热了。\n语法观念辨析练习请将以下句子翻译为英语。\n01．我听到有人在唱歌。\n\n02．我昨天晚上觉得牙齿很痛。\n\n03．我看他进房间了。\n\n04．她长得像她妈妈。\n\n05．那时候他很开心。\n\n06．这款布料很柔顺。\n\n07．比赛越来越精彩了。\n\n正确答案及题目译文：\n\n动名词与不定式\n当一个句子中出现两个动词时，通常会用两种形式呈现。\n\n动名词：动词＋ing→具有动词及名词的特性，在句子中作为名词使用。\n\n\n不定式：to＋动词原形→具有名词、形容词和副词的特性，在句子中作为主语、补语及副词使用。\n\n动名词使用时机作为主语使用→置于句首：\n当动名词作为主语时，通常位于句首，例如：\nSeeing is believing.（眼见为实。）\n\n主语为动作→使用动名词：\n在英语语法中，若句子的主语为动作时，通常必须转化为动名词形式。例如：\nWalking to office is a best way to lose weight.（走路上班是减肥的最好方法。）\n\n动名词作补语使用，句子的主语通常为→\n无生命的名词，例如：\nMy favorite sport is playing tennis.（我最喜欢是运动是打网球。）\n以what引导的名词从句，例如：\nWhat I want is having a rest.（我想要的是好好休息一下。）\n\n作为宾语使用→可当动词宾语或介词的宾语：\n\n动词宾语：  英语中有些动词后面只能使用动名词作为宾语。这类动词常见的有：admit, advice, anticipate, appreciate, avoid, consider, delay, deny, dislike, enjoy, escape, excuse, fancy, favor, finish, imagine, include, keep, mind, miss, postpone, practice, prevent, propose, resist, risk, suggest等。例如：\nPlease pardon my disturbing you.（请原谅我打扰您了。）\nI suggest doing it in a different way.（我建议用不同的方法做。）\n\nTIPS!\n\n  连接在need, require, want之后的动词以动名词呈现时，表示被动意义。例如：\n  The car needs repairing.（这辆车需要修理。）\n\n介词的宾语：\n英语中有些连接在介词后面的动词需要以动名词的形式呈现。例如：\nShe is worring about discussing the new proposal with sales manager tomorrow very much.（她现在非常担心明天要跟业务经理讨论新方案。）\n\nTIPS!\n\n\n这类介词后面连接动名词的状况常常出现在特定介词短语中，例如：be afraid of, be careful of, talk about, worry about。\n5 .  作形容词使用→置于名词之前：\n动名词放在名词之前可作为修饰用形容词使用，例如：\n\n时态陈述句动名词→所表时间与主要动词时间一致或未来：\n陈述句动名词所表示的时间，与句中动词所表示的时间“一致或是表示未来”。例如：\nI am sure of his quitting.＝I am sure he will quit.\n（我很肯定他会辞职。）\n\n完成时动名词→所表示的时间比主要动词时间更早：\n完成时动名词所表示的时间，比句中动词所表示的时间“更早发生”。例如：\nI am sure of his having done so.＝I am sure that he has done so.\n（我很肯定他曾经这样做过。）\n\n不定式\n使用时机作为主语使用→置于句首：\n不定式做为主语使用时，一般表示具体的动作，常置于句首。例如：\nTo save time is to lengthen life.（节约时间就等于延长了人的生命。）\n\n作为补语使用→表示将来的动作：\n不定式作补语使用时，常表示将来的动作。而句中主语常常是表示意向、打算、计划的词，例如wish, idea, task, purpose, duty, job等。\nMy work is to clean the classroom every day.（我的工作是每天打扫教室。）\n\n置于系动词后→表示状态：\n不定式置于seem, appear, prove等系动词后面时，表示状态，例如：\nThis plan seems to be possible.（这个计划似乎是可行的。）\n\n作为宾语使用→可当动词宾语或限定介词的宾语：\n\n动词宾语：\n不定式常在下列动词后做宾语，例如afford, agree, apply, arrange, ask, attempt, beg, begin, care, choose, claim, consent, demand, decide, desire, determine, expect, fail, hope, hesitate, hate, intend, learn, like, manage, mean, neglect, offer, plan, prepare, pretend, promise, refuse, resolve, seek, tend, threaten, want等。\nHe promises to keep my secret.（他答应替我保守秘密。）\n\n限定介词之宾语：\n不定式通常不做介词的宾语。但是遇到but, except, besides, than, instead of, about这几个特殊介词，不定式可连接在后面作为宾语。例如：\nWe can do nothing but to wait.（除了等我们什么也做不了。）\n\n作为动词之后的宾语补语\n不定式常跟在下列动词之后做宾语补语：ask, advise, allow, beg, cause, compel, command, enable, encourage, expect, feel, force, find, hear, have, inform, invite, let, make, mean, notice, order, permit, persuade, remind, require, request, teach, tell, urge, watch, warn, watch等。\nThe teacher asked her to answer the question.（老师叫她回答问题。）\n\n\nTIPS!\n\n不定式在下列动词的后面做宾语补语时，需要省略to，例如feel, hear, listen to, let, have, make, look at, see, watch, notice, observe, help等，但是变成被动语态时，省略的to必须再补上。\nWhenever something is wrong with you, please do let me know.（无论什么时候你出问题了，请告诉我。）\n6．作副词使用\n修饰动词→表目的：\n不定式做副词修饰动词时，通常表示特定目的，或是表示出乎意料的结果。\nHe woke up to find everybody gone.\n（他起来后发现所有人都不见了。）→不定式表结果\n\n修饰形容词→表原因：\n不定式做副词修饰形容词时，通常表示原因，并且通常与以下表示感情的形容词连用：glad, sorry, proud, angry, ashamed, excited, disappointed, interested…\nI am sorry to hear this information.（我很遗憾听到这个消息。）→不定式表原因\n\n时态陈述句不定式→所表示的时间与主要动词一致\nI like to read newspaper.（我喜欢看报纸。）\n\n进行时不定式→所表示的时间与主要动词同时\nI am very glad to be work with you.（我很高兴能与你一同工作。）\n\n完成时不定式→所表示的时间比主要动词更早\nI am sorry to have kept you waiting so long.（很抱歉让你等这么久。）\n\n语态主动语态→主语是执行者\n句中不定式使用主动语态时，通常代表主语是该动作的执行者。例如：\nI am glad to attend your marriage.（我很高兴能出席你的婚礼。）\n\n被动语态→主语是承受者\n句中不定式使用被动语态时，通常代表主语是该动作的承受者。例如：\nHe didn’t like to be laughed at.（他不喜欢被人嘲笑。）\n\n延伸用法，事半功倍！动名词和不定式都可以做主语。不定式做主语表示具体的动作，动名词做主语则可以表示抽象或一般性的动作或情况。例如：\nTo play with fire will be dangerous.（玩火是非常危险的。）\n→ 指特定的人的具体动作\nPlaying with fire is dangerous.（玩火是非常危险的。）\n→ 泛指玩火\n\n在allow, advise, forbid, permit等动词后，以另一个动词作宾语时，要用动名词形式。但如果后面有名词、代名词作宾语时，需连接不定式。例如：\nYou don’t allow smoking here.（你不允许在这里抽烟。）\nI don’t allow you to smoke here.（我不允许你在这里抽烟。）\n\n语法观念例句示范01．Smoking may cause cancer.\n吸烟会致癌。\n\n02．It’s useless arguing about it.\n争论这件事没有意义。\n\n03．Her hobby is painting.\n她的爱好是绘画。\n\n04．Remember to tell him the news.\n记得告诉他这个消息。\n\n05．I don’t feel like going to the movie.\n我不想去看电影。\n\n06．To master a foreign language is really important nowadays.\n如今，掌握一门外语真的很重要。\n\n07．It’s kind of you to think so much of us.\n你为我们考虑这么多真是太好了。\n\n08．To see is to believe.\n眼见为实。\n\n09．You must learn to look after yourself.\n你必须自己学会照顾自己。\n\n10．I don’t know what to do next.\n我不知道接下来该怎么做。\n语法观念辨析练习请选出正确的选项。\n01．She can’t help________the house because her guests is about to come.\nA to clean\nB cleaning\nC cleaned\nD being cleaned\n\n02．It is difficult to get used________on the sofa.\nA sleep\nB to sleeping\nC slept\nD to sleep\n\n03．Though________money, his parents managed to send him to university.\nA lacked\nB lacking of\nC lacking\nD lacked in\n\n04．She pretended________me when I passed by.\nA not to see\nB not seeing\nC to not see\nD have not seen\n\n05．It’s no use________to get a bargain in the department store.\nA to except\nB excepting\nC wanting\nD you excepting\n\n06．After________for the job, you will be required to take a language test.\nA being interviewed\nB interviewed\nC interviewing\nD having interviewed\n\n07．It was unbelievable that the fans waited outside the gym for three hours just________a look at the sports stars.\nA had\nB having\nC to have\nD have\n\n08．I saw him________out of the room.\nA go\nB had gone\nC has gone\nD goes\n\n09．No one can avoid________by advertisements.\nA to be influenced\nB being influenced\nC influencing\nD having influence\n\n10．It was impolite of him________without________good-bye.\nA to leave, saying\nB leaving, to say\nC to leave, to say\nD leaving, saying\n\n正确答案及题目译文：\n\n连词\n功能连接单词\nlove and hate（爱和恨）\na difficult but worthy life（艰难却有价值的人生）\nneither the teacher nor his student（不是那位老师也不是他的学生）\n\n连接短语\nready to start and easy to finish（准备出发和容易完成）\n\n连接从句\nJohnny has not smoked since his daughter was born.（自从强尼的女儿出生后，他就没有抽过烟了。）\n\n使用分类并列连词\n此类连词有and, but, so, yet, still, either, or, neither, nor, than, either…or, neither...nor, not only...but also, as well as等。例如：\nI will do it right away and do it well.（我现在就做，而且我会把这件事做好。）\nShe agreed with Martin’s proposal, but she didn’t want to join his team.（她同意马丁的提案，但是她不想加入马丁的团队。）\n\n从属连词\n\n名词从属连词及从句\n可用来当主语和宾语，此类连词有whoever, whatever, who, whom, which, that, when, where, how, what, why, whether等。\nWhen mother finished the cake was a surprise.（妈妈完成蛋糕的时间是个惊喜。）\n→ 名词从句当主语\nMicheal joined the team which is leaded by his father.（迈克加入了由他爸爸领军的团队。）\n→ 名词从句当宾语\n\n形容词从属连词及从句\n可用来当主语补语和形容词，此类连词有who, whom, whose, which, that, when, where等。\nThe point is who did this.（重点是谁完成了这件事。）\n→ 形容词从句当主语补语\nThe old lady who has 5 dogs is my mother-in-law.（有五只狗的老太太是我的岳母。）\n→ 形容词从句当形容词\n\n副词从属连词及从句\n可以当副词使用或是引出副词从句，此类连词有after, as, although, because, before, if, since, though, until, when, whenever, while, wherever等。\nShe woke up after I left home.（我一出家门她就醒了。）\n→ 连词带出副词从句\n\n语法观念例句示范01．Air and water are indispensible for human beings.\n空气和水对人类来说必不可少。\n\n02．You may go, only come back early.\n你可以去，只是要早点回来。\n\n03．We should strike while the iron is hot.\n我们要趁热打铁。\n\n04．Where there is a will, there is a way.\n有志者，事竟成。\n\n05．We wouldn’t lose heart even if we should fail ten times.\n我们就是失败十次也不灰心。\n\n06．Now that you are all back, we’d better start the work right now.\n你们既然都回来了，我们最好马上就开始工作。\n\n07．Wherever you are, I will be with you.\n不管你到哪，我都会在你身边。\n语法观念辨析练习01　I was reading a newspaper________he came in.\nA as soon as\nB since\nC while\nD when\n\n02．Hurry up, ____you’ll be late for school.\nA and\nB but\nC so\nD or\n\n03．Excuse me for breaking in, ____I have some news for you.\nA so\nB and\nC but\nD yet\n\n04．____you’ve got a chance, you might as well make full use of it.\nA Now that\nB After\nC Although\nD As soon as\n\n05．The old man________lives in that old house is my uncle.\nA who\nB which\nC where\nD how\n\n06．One can’t learn a foreign language well________he studies hard.\nA because\nB though\nC unless\nD if\n\n07________you decide to take this job, you should try to make it a success.\nA Whatever\nB Unless\nC Whenever\nD If only\n\n08．I’ll accept any job________I don’t have to get up early.\nA lest\nB as long as\nC in case\nD though\n\n正确答案及题目译文：\n\nDay05介词","plink":"https://dxsummer.gitee.io/posts/2f6cae91/"},{"title":"Butterfly主题更新总结","date":"2020-05-08T06:33:23.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:49:56.372Z","content":"本文仅记录一些看似无意义的小改动，你可以在本文 get：\n1. 各种自定义样式的`路径`\n2. 如何自定义字体和文字色块\n3. 如何增加评分的小星星\n4. 插件的总结等…\n对于没学过任何 CSS 的我能改成这样实属不易，还望各位大佬指出我的错误~~并五星好评~~。修改主题，先装依赖出现报错，未安装渲染依赖！\n执行以下命令\n1npm install hexo-renderer-pug hexo-renderer-stylus --save菜单栏设置新版本默认是中文，但是修改根目录配置文件的 language 为 zh-CN 之后，菜单栏会变回英文。直接修改主题配置文件 menu 为中文即可\n123456menu:  首页: &#x2F; || fa fa-home  归档: &#x2F;archives&#x2F; || fa fa-archive  标签: &#x2F;tags&#x2F; || fa fa-tags  分类: &#x2F;categories&#x2F; || fa fa-list-ul  友链: &#x2F;link&#x2F; || fa fa-cogs\n首页留空表示跳转起始页，若加上 /home/ 则为新页面，类似分类标签页\n\n菜单栏跳转外链，去掉 / 直接写链接即可\n\n1云盘 || http:&#x2F;&#x2F;kd.xiabor.com || fa fa-mixcloud文章主页描述关闭自动节选，才能在 Page Front-matter 中添加 description\n1234# 自動節選auto_excerpt:  enable: false  length: 150代码高亮及自动换行代码高亮试了其他的插件，Mac Pannel 样式等，调来调去还不如默认的，索性不改了\n\n打开自动换行code_word_wrap: true，根目录下配置文件_config.yml，將 line_number 改成 false:\n12345highlight:  enable: true  line_number: false  auto_detect: false  tab_replace:事实证明，代码换行在移动端很不舒服，还是关掉吧。\n\n主题美化取消主题配置文件 theme_color 的注释\n自定义主色调为浅绿，设置 footer 显示图片背景与 top_img 一致。\n推荐文章设置 limit: 3\n打开图片文字描述 photofigcaption: true\n设置评论区打字冒光和抖动效果，activate_power_mode: true\n鼠标点击出现爱心 click_heart: true\n美化页面展示，修改标题前图标为闪电 title-prefix-icon:&#39;\\f0e7&#39;，颜色为黄色 title-prefix-icon-color: &quot;#ffb821&quot;\n主页调用金山词霸的每日一句打字效果，需注意的是：自定义副标题 sub 的时候，符号必须用 ASCII 码表示，常用的逗号为 , 句号为 . 双引号为 &quot; 英文缩写符号为 &#39;\n打开 snackbar 弹窗并设置底部居中 position: bottom-center\n打开中英文之间添加空格 pangu: true\n至此主题配置文件在不装插件前提下算是修改完毕了，明天继续折腾插件和 css 样式。眼睛疼，睡了自定义样式修改菜单字体大小为 18，修改鼠标悬停时颜色为主色调浅绿。\n在路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\head.styl 下查找.site-page，设置 font-size 为.7rem\n在此目录下 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl 新增自定义颜色值 $laurel-green = #9fefaf，在路径下修改 &amp;:hover: $laurel-greenhexo clean &amp;&amp; hexo s 查看效果\n\n由于菜单打开子菜单是悬停后选中，鼠标移开子菜单便关闭。导致鼠标如果不是从主菜单近乎垂直往下滑就无法点击子菜单。（改动意义似乎不大）自定义修改参考旧版本如下：路径 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl\n1234567891011121314151617181920212223.menus_item_child        position: absolute        right: 0        display: none        margin-top: 8px        padding: 0        border-radius: 5px        width: max-content        background-color: alpha($white, .8)        box-shadow: 0 5px 20px -4px rgba($dark-black, .5)        animation: sub_menus .3s .1s ease both        &amp;:before          position: absolute          top: -55px          left: 50%          width: 0          height: 21px          content: &#39;&#39;          margin-left: -18px          border-width: 18px          border-style: solid          border-color: transparent transparent rgba($white 0.8)\n主页文章区域，路径均为 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\pagination.styl\n外圆角修改为 5px，且图片与描述圆角为 3px\n\n主页文章描述修改，增加描述区域高度，标题距离描述适当增加，字体由 1.2 调整至 1rem\n123456789101112131415161718&amp; &gt;.recent-post-info  display: inline-block  overflow: hidden  padding: 50px 40px  width: 55%  &amp; &gt; .article-title    display: -webkit-box    overflow: hidden    margin-bottom: 1.2rem    color: $font-black    text-overflow: ellipsis    word-wrap: break-word    font-size: 1.2rem    line-height: 1.5    transition: all .2s ease-in-out    -webkit-box-orient: vertical    -webkit-line-clamp: 2\n描述文字可能较多，因此调整溢出方式为 scroll\n1234567display: -webkit-boxoverflow: scrollmargin-top: .2remheight: 97pxword-break: break-word-webkit-line-clamp: 3-webkit-box-orient: vertical\n并适当降低侧栏滚动条宽度，-webkit-scrollbar 路径为 D:\\blog\\themes\\Butterfly\\source\\css\\_global\\index.styl\n\n调整分类和发表时间字体大小为 80%，路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\page.styl\n12&amp; &gt; .article-meta-wrap      font-size: 80%\n\n\n调整移动端主页文章区域边距 5px 为 0.75rem，调整移动端描述字体大小为 0.6rem\n1234567@media screen and (max-width: $sm)    .layout_page      padding: 1rem 0.75rem !important      .content        height: auto        font-size: 0.6rem\n既然要圆润，那就全部都要圆润。调整页码圆角，算了，直接改成圆形。路径为 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\pagination.styl\n1234567891011121314.page-number  display: inline-block  margin: 0 .2rem  min-width: w &#x3D; 1.5rem  height: w  text-align: center  line-height: w  cursor: pointer&amp;.current  background: $theme-color  color: $button-color  cursor: default  border-radius: 20px\n调整页脚高度，去除驱动和主题描述，，修改 By 字母为红色爱心。\n在路径D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug下，将 By 替换为以下内容\n1&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;\n同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n12345678.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly\n利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n\n\n修改侧栏设置及返回顶部按钮\n在路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\rightside.styl下加大按钮高宽度并设置圆角，调整间距，使设置按钮的子菜单不打开状态隐藏到最右侧不可见。\n1234567891011121314151617181920212223242526#rightside  position: fixed  right: -38px  bottom: 10px  opacity: 0  transition: all .3s  #rightside-config-hide    transform: translate(40px, 0)&amp; &gt; div  &amp; &gt; i,  &amp; &gt; a,  &amp; &gt; div    display: block    margin-bottom: 2px    width: 36px    height: 36px    background-color: $light-blue    color: $button-color    text-align: center    font-size: 16px    line-height: 35px    margin-bottom: 4px    margin-right: 4px    cursor: pointer    border-radius: 3px\n\n文章目录美化\n调整左侧边距 0.5rem 为 2rem\n\n选择某一目录时，背景框宽度为最大且为方形，修改选中时边框为圆润且适应标题长度，路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\sidebar.styl下修改或增加以下内容\n12345678910.toc-link  &amp;.active    border-right-color: darken($theme-toc-color, 20%)    background: $theme-toc-color    color: $sidebar-active-color    border-radius: 5px    width: max-content    padding-right: 5px    padding-left: 5px\n\n打赏按钮美化，设置圆角并修改颜色，调整赞赏码大小确保能扫描成功\n路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\reward.styl 下修改赞赏码大小，默认 130，扫描可能无法识别，建议 200。\n\n修改底部标签边框和字体为黑色，调整大小。底部版权声明增加 1px 边框\n路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下修改以下内容\n12345678910111213141516171819202122232425&amp;__tags   display: inline-block   margin: .4rem .4rem .4rem 0   padding: 0 .6rem   width: fit-content   border: 2px solid $font-black   border-radius: .2rem   color: $font-black   font-size: 14px   text-decoration: overline   cursor: pointer   transition: all .2s ease-in-out  .post-copyright   position: relative   margin: 2rem 0 .5rem   padding: .5rem .8rem   border: 1px solid $dark-white   transition: box-shadow .3s ease-in-out   border-radius: 5px   .post-copyright     &amp;-meta       color: $grey       font-weight: bold\n提到版权申明，修改默认的灰色链接的颜色为蓝色。可以先在 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl 里添加自定义颜色，再去 post.styl 里修改，或者直接修改链接颜色为蓝色。修改其他自定义颜色的方法亦是如此。\n1$a-link-color &#x3D; #638fff版权声明\n\n文章作者: xx\n文章链接: https://xxx\n版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。\n\n点击这部分的文章作者出现 mailto:undefined，查看 copyright.pug 文件发现 email 需要在根目录 config.yml 下自定义\n因此在根目录 config.yml 下添加即可\n1email: xxxx@xxx.com\nRating 评分评价文章打字麻烦？那就用小星星吧，直接给文章打分。效果如下：\n配置教程：参考学姐的添加 Rating 投票功能\n官网传送门：widgetpack.com\n由于 butterfly 主题和 next、Sakura 等主题文件结构不同，所以详细记录本主题的配置：\n注册完 Widgetpack 选择 Rating 可以拿到一段代码如下：\n123456789101112131415&lt;div id&#x3D;&quot;wpac-rating&quot;&gt;&lt;&#x2F;div&gt;  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  wpac_init &#x3D; window.wpac_init || [];  wpac_init.push(&#123;widget: &#39;Rating&#39;, id: 你的IDxxx&#125;);  (function() &#123;      if (&#39;WIDGETPACK_LOADED&#39; in window) return;      WIDGETPACK_LOADED &#x3D; true;      var mc &#x3D; document.createElement(&#39;script&#39;);      mc.type &#x3D; &#39;text&#x2F;javascript&#39;;      mc.async &#x3D; true;      mc.src &#x3D; &#39;https:&#x2F;&#x2F;embed.widgetpack.com&#x2F;widget.js&#39;;      var s &#x3D; document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(mc, s.nextSibling);  &#125;)();  &lt;&#x2F;script&gt;  &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;widgetpack.com&quot; class&#x3D;&quot;wpac-cr&quot;&gt;Star Rating WIDGET PACK&lt;&#x2F;a&gt;利用在线转化将其转为.pug 格式，并增加点小改动，使其居中。创建并放入目录 D:\\blog\\themes\\Butterfly\\layout\\includes\\addons\\rating.pub 中\n1234567891011121314151617htmlbody  #wpac-rating(align&#x3D;&quot;center&quot;)  script(type&#x3D;&quot;text&#x2F;javascript&quot;).    wpac_init &#x3D; window.wpac_init || [];    wpac_init.push(&#123;widget: &#39;Rating&#39;, id: 你的ID&#125;);     (function() &#123;    if (&#39;WIDGETPACK_LOADED&#39; in window) return;    WIDGETPACK_LOADED &#x3D; true;    var mc &#x3D; document.createElement(&#39;script&#39;);    mc.type &#x3D; &#39;text&#x2F;javascript&#39;;    mc.async &#x3D; true;    mc.src &#x3D; &#39;https:&#x2F;&#x2F;embed.widgetpack.com&#x2F;widget.js&#39;;    var s &#x3D; document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(mc, s.nextSibling);    &#125;)();  #copy(align&#x3D;&quot;center&quot;)    | ღ喜欢记得五星好评哦~\n在合适位置引入评分，例如我的：（置于赞赏的上面）\n12345if theme.rating.enable  include includes&#x2F;addons&#x2F;rating.pug&#x2F;&#x2F;-加入以上代码，下面为赞赏    if theme.reward.enable  !&#x3D;partial(&#39;includes&#x2F;post&#x2F;reward&#39;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)\n最后，在主题配置文件设置是否打开该功能，星星颜色在 widgetpack.com 修改\n1234# Star rating support to each article.# To get your ID visit https:&#x2F;&#x2F;widgetpack.comrating:   enable: true\n\n特别提示：设置投票记录方式，有三种可选，国内最好选择 IP Address 记录。另外，widgetpack.com 只能绑定一个域名，但可以随时更换\n\n\n特别鸣谢 @GamerNoTitle，一提需求，立马奋笔疾书教我配置小星星。还回来看我文章并指出错误，佩服大佬的细心与热心。\n\n自动切换夜间模式时间修改夜间模式自动切换时间为晚上 21 点至早晨 7 点，路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\head，修改时注意格式不变\n移动端优化PC 端分类归档标签等是显示在右侧，移动端则在底部，与侧栏重复，因此去除分类标签归档个人信息，只保留网站统计。将以下代码添加进任意.styl文件里即可。效果如图（补充：调整移动端底部网站资讯字体大小为 13px）\n12345@media screen and (max-width: $sm)  #aside_content    div:not(:last-child)      display: none      font-size: 13px\n\n手机端侧栏美化，缩小头像及菜单间距。路径 D:\\blog\\themes\\Butterfly\\source\\css\\mobile-sidebar.styl 下自行调整\n在路径 post.styl 下调整移动端.post_cover 圆角为 5px\n调整移动端文章字体大小在D:\\blog\\themes\\Butterfly\\source\\css\\var.styl下自定义一个字体大小值，例如：$font-media-size = 13px，然后在D:\\anewblog\\themes\\Butterfly\\source\\css\\_global\\index.styl增加以下内容\n123@media screen and (max-width: $sm)body    font-size: $font-media-size &#x3D; 13px\n侧栏自定义加入书签按钮设置圆角aside.styl\n123456789#bookmark-it  position: relative  z-index: 1  display: block  background-color: $light-blue  color: $button-color  text-transform: uppercase  line-height: 1.6rem  border-radius: 5px\n顺便设置选中时的圆角D:\\blog\\themes\\Butterfly\\source\\css\\_global\\index.styl\n123456789101112.button--animated  transition-duration: 1s  transition-property: color  &amp;:before    position: absolute    top: 0    right: 0    bottom: 0    left: 0    z-index: -1    border-radius: 5px\n修改某些名称，例如网站资讯的名称在 D:\\blog\\themes\\Butterfly\\languages\\zh-CN 下修改即可\n\n自定义字体，图标引用外部字体和鼠标样式引用格式\n123@font-face &#123; font-family:MyFont;src: url(https:xxx)&#125;body&#123;font-family:MyFont!important;&#125;\n引用方法：将引用代码添加到 D:\\blog\\themes\\Butterfly\\source\\css\\_third-party\\normalize.min.css 末尾即可，鼠标样式亦是如此。\n\n鼠标样式引用格式\n12body &#123; cursor: url(https:&#x2F;&#x2F;xxx.png),default;&#125;a:hover &#123; cursor: url(https:&#x2F;&#x2F;xxx.png),pointer;&#125;\n修改图标可直接使用 Font Awesome 的图标。地址：Font Awesome\n\n在路径 D:\\anewblog\\themes\\Butterfly\\layout\\includes\\mixins\\UI.pug不对等我找找。第二天找到了正确的路径为 D:\\anewblog\\themes\\Butterfly\\layout\\includes\\header 可修改文章内头部（发表、更新、分类等）图标。\n12345678910111213141516#post-meta  .meta-firstline    if (theme.post_meta.post.date_type)      if (theme.post_meta.post.date_type &#x3D;&#x3D;&#x3D; &#39;both&#39;)        time.post-meta__date          span.post-meta__date-created(title&#x3D; _p(&#39;post.created&#39;)+&#39; &#39;+full_date(page.date))            i.fa.fa-pencil(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;&#39; &#39;+_p(&#39;post.created&#39;)+&#39; &#39;+date(page.date, config.date_format)          span.post-meta__separator |          span.post-meta__date-updated(title&#x3D; _p(&#39;post.updated&#39;)+&#39; &#39;+full_date(page.updated))            i.fa.fa-wrench(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;&#39; &#39;+_p(&#39;post.updated&#39;)+&#39; &#39;+date(page.updated, config.date_format)      else        - var data_type_update &#x3D; theme.post_meta.post.date_type &#x3D;&#x3D;&#x3D; &#39;updated&#39;        - var date_type &#x3D; data_type_update ? &#39;updated&#39; : &#39;date&#39;        - var date_icon &#x3D; data_type_update ? &#39;fa-wrench&#39; :&#39;fa-pencil&#39;\n修改主页文章的分类和发表时间图标，在路径 D:\\anewblog\\themes\\Butterfly\\layout\\includes 下修改即可\n12345678910111213141516if (theme.post_meta.page.date_type)      if (theme.post_meta.page.date_type &#x3D;&#x3D;&#x3D; &#39;both&#39;)        time.post-meta__date          span.post-meta__date-created(title&#x3D;_p(&#39;post.created&#39;) + &#39; &#39; + full_date(article.date))            i.fa.fa-pencil(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;date(article.date, config.date_format)          span.article-meta__separator |          span.post-meta__date-updated(title&#x3D;_p(&#39;post.updated&#39;) + &#39; &#39; + full_date(article.updated))            i.fa.fa-wrench(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;date(article.updated, config.date_format)      else        - var data_type_updated &#x3D; theme.post_meta.page.date_type &#x3D;&#x3D;&#x3D; &#39;updated&#39;        - var date_type &#x3D; data_type_updated ? &#39;updated&#39; : &#39;date&#39;        - var date_icon &#x3D; data_type_updated ? &#39;fa-wrench&#39; :&#39;fa-pencil&#39;        - var date_title &#x3D; data_type_updated ? _p(&#39;post.updated&#39;) : _p(&#39;post.created&#39;)        time.post-meta__date(title&#x3D;date_title + &#39; &#39; + full_date(article[date_type]))\n例如修改主页底部向下箭头为双箭头，先去 Font Awesome 找到合适的图标，新版在路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\header\\index.pug 的末尾修改\n12.scroll-down  i.fa.fa-angle-double-down.scroll-down-effects旧版在路径 H:\\blog\\themes\\Butterfly\\layout\\includes\\nav.pug 下修改\n\n文章内引用图标，格式如下\n1&lt;i class&#x3D;&quot;fa fa-plane&quot;&gt;&lt;&#x2F;i&gt;\n插件总结搜索插件采用本地搜索，安装插件 hexo-generator-search\n1npm install hexo-generator-search --save\n根目录配置文件添加以下内容，打开主题配置文件 local_search 即可\n1234search:  path: search.xml  field: post  content: true字数统计安装统计插件，主题配置文件打开 wordcount 即可\n1npm install hexo-wordcount --save音乐电影豆瓣插件\n安装 hexo-douban 插件\n1npm install hexo-douban --save\n并将以下内容加入根目录配置文件，hexo douban 命令进行初始化\n12345678910111213douban:  user: mythsman  builtin: false  book:    title: &#39;This is my book title&#39;    quote: &#39;This is my book quote&#39;  movie:    title: &#39;This is my movie title&#39;    quote: &#39;This is my movie quote&#39;  game:    title: &#39;This is my game title&#39;    quote: &#39;This is my game quote&#39;  timeout: 10000\n\n播放器插件在 Hexo 页面中嵌入APlayer 播放器\n1npm install --save hexo-tag-aplayer\n用法：参数选项详见 APlayer\n1&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;\n部署插件安装安装 hexo-deployer-git, 填写仓库就可以部署至网络世界啦\n1npm install hexo-deployer-git --save\n置顶插件\n文章置顶\n\n要为文章置顶，你需要安装插件(hexo-generator-index-pin-top 或者 hexo-generator-indexed)，记得先卸载掉hexo-generator-index\n如果使用hexo-generator-index-pin-top, 在文章的front-matter区域里添加top: true属性来把这篇文章置顶\n如果使用hexo-generator-indexed, 在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大\n方法1\n- 卸载替换置顶插件\n  12npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save\n在文章的 front-matter 添加 top: true或数值将篇文章置顶方法2\n如果使用`hexo-generator-indexed`, 在文章的`front-matter`区域里添加`sticky: 1`属性来把这篇文章置顶。数值越大，置顶的优先级越大脚注插件这个插件是最容易忘记的，还好看到文章里有注脚脚注，执行以下命令安装注脚插件：\n1npm install hexo-reference --savenew page\nhexo new page xxx\n\n版本更新后建议页面重新建立，再复制 md 内容进去，否则容易报错。出现报错的页面有 music、photo，为什么新建页面一模一样的 md 复制进去就不报错了呢？\n设置页面顶部图photo、music、link 页面均在相应 md 文件内增加 top_img，设置顶部图。其余在主题配置文件设置即可。\n不常见问题侧栏目录消失卸载原有的渲染插件，安装新的插件\n123npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save\n菜单栏消失更新产生的问题，将_data 的 butterfly.yml 移动到其他地方，重新 hexo clean&amp;&amp;hexo s，在将主题配置文件拷贝替换 butterfl.yml 即可。\n底部去除驱动和主题描述，，修改 By 字母为红色爱心在路径D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug下，将 By 替换为以下内容\n1&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;\n同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n12345678.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly\n利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n\n","plink":"https://dxsummer.gitee.io/posts/d1a5291c/"},{"title":"hexo博客添加live2d看板娘","date":"2020-05-08T05:12:15.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:51:40.886Z","content":"下载安装检测npm版本是否最新\n1npm -v\nnpm更新方法:\n\n1nmp install npm@latest -g安装hexo-helper-live2d进入hexo目录下\n1npm install –save hexo-helper-lived打开hexo目录下的_config.yml的配置文件\n配置\n将以下代码添加到站点配置文件末尾\n\n123456789101112131415161718192021222324252627282930313233  # Live2D## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2dlive2d:  enable: true  # scriptFrom: jsdelivr # jsdelivr CDN  # scriptFrom: unpkg # unpkg CDN  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url  # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名  # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径  # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url  # enable: false  scriptFrom: local # 默认  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径  model:    use: live2d-widget-model-ni-j # npm-module package name    scale: 1    hHeadPos: 0.5    vHeadPos: 0.618  display:    superSample: 2    width: 150    height: 300    position: left    hOffset: 0    vOffset: -50  mobile:    show: true    scale: 0.5  react:    opacityDefault: 0.7    opacityOnHover: 0.2下载模型动画后宫预览点这里选择你的后宫看好了默默记下小姐姐的名字,初音的模型名字:ni-j博客中都是按照ni-j操作\n1npm install –save live2d-widget-model-ni-j\n此时初音模型已经下载完毕\n\n12model:   use: live2d-widget-model-ni-j # 将&#96;ni-j&#96;替换成其他包名,即可替换不同模型人物.资源1[github源码和中文操作指南][3]重新加载博客\nhexo cleanhexo g打开浏览器看看你的初音吧\n\n","plink":"https://dxsummer.gitee.io/posts/2805db8d/"},{"title":"hexo博客开启pwa","date":"2020-05-08T04:41:25.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:53:02.940Z","content":"前言Progressive Web App, 简称PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。\nPWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。\nPWA 的主要特点包括下面三点：\n可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现\n体验 - 快速响应，并且有平滑的动画响应用户的操作\n粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面\nPWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。\n Warning Header\n开始pwa之前，全站必须支持HTTPS\n开始pwa之前，全站必须支持HTTPS\n开始pwa之前，全站必须支持HTTPS安装pwahexo@4.2.0 目前赞不兼容 hexo-pwa,使用 hexo@4.2.0 版本的用户推荐降级到 hexo@4.1.1\n使用sudo hexo -version 查看版本\n安装指定版本 sudo npm install hexo@4.1.1 --save\n安装hexo-pwa\n1sudo npm install hexo-pwa --save配置添加manifest.json在manifest.json生成网站生成manifest.json首先你需要准备一个你喜欢的图标，填写香相关选项，并上传图标，将生成的manifest.json文件，放到 博客根目录下\n我生成的如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123;  &quot;name&quot;: &quot;YH&#39;s Blog&quot;,  &quot;short_name&quot;: &quot;YH&#39;s Blog&quot;,  &quot;theme_color&quot;: &quot;#2196f3&quot;,  &quot;background_color&quot;: &quot;#2196f3&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;Scope&quot;: &quot;&#x2F;&quot;,  &quot;start_url&quot;: &quot;&#x2F;&quot;,  &quot;icons&quot;: [    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-72x72.png&quot;,      &quot;sizes&quot;: &quot;72x72&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-96x96.png&quot;,      &quot;sizes&quot;: &quot;96x96&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-128x128.png&quot;,      &quot;sizes&quot;: &quot;128x128&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-144x144.png&quot;,      &quot;sizes&quot;: &quot;144x144&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-152x152.png&quot;,      &quot;sizes&quot;: &quot;152x152&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-192x192.png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-384x384.png&quot;,      &quot;sizes&quot;: &quot;384x384&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-512x512.png&quot;,      &quot;sizes&quot;: &quot;512x512&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;  ],  &quot;splash_pages&quot;: null&#125;参数解释\nname: {string} 应用名称，用于安装横幅、启动画面显示\nshort_name: {string} 应用短名称，用于主屏幕显示\ntheme_color: {Color} css色值theme_color 属性可以指定 PWA 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如 PWA 启动画面上状态栏、内容页中状态栏、地址栏的颜色，会被 theme_color 所影响。\nbackground_color: {Color} css色值 可以指定启动画面的背景颜色。\ndisplay: {string} 显示类型\nfullscreen 应用的显示界面将占满整个屏幕\nstandalone 浏览器相关UI（如导航栏、工具栏等）将会被隐藏\nminimal-ui 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同\nbrowser 浏览器模式，与普通网页在浏览器中打开的显示一致\nscope: {string} 作用域\n\nscope 应遵循如下规则：如果没有在 manifest 中设置 scope，则默认的作用域为 manifest.json 所在文件夹；scope 可以设置为 …/ 或者更高层级的路径来扩大PWA的作用域；\n\nstart_url 必须在作用域范围内；\n\n如果 start_url 为相对地址，其根路径受 scope 所影响；如果 start_url 为绝对地址（以 / 开头），则该地址将永远以 / 作为根地址；\n\nstart_url: {string} 应用启动地址\nicons: {Array.} 应用图标列表\nsrc: {string} 图标 url\n\nsizes {string} 图标尺寸，格式为widthxheight，宽高数值以 css 的 px 为单位。如果需要填写多个尺寸，则使用空格进行间隔，如”48x48 96x96 128x128”type {string} 图标的 mime 类型，非必填项，该字段可让浏览器快速忽略掉不支持的图标类型\n\n添加sw.js新建一个名为sw.js的文件，放在站点根目录下，在文件里填入一下内容\n1234567891011121314importScripts(&#39;https:&#x2F;&#x2F;g.alicdn.com&#x2F;kg&#x2F;workbox&#x2F;3.3.0&#x2F;workbox-sw.js&#39;);​if (workbox) &#123;    workbox.setConfig(&#123; modulePathPrefix: &#39;https:&#x2F;&#x2F;g.alicdn.com&#x2F;kg&#x2F;workbox&#x2F;3.3.0&#x2F;&#39; &#125;);​    workbox.precaching.precache([&#39;&#x2F;&#39;, &#39;&#x2F;index.html&#39;]);​    workbox.routing.registerRoute(new RegExp(&#39;^https?:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;?$&#39;), workbox.strategies.networkFirst());​    workbox.routing.registerRoute(new RegExp(&#39;.*.html&#39;), workbox.strategies.networkFirst());​    workbox.routing.registerRoute(new RegExp(&#39;.*.(?:js|css|jpg|png|gif)&#39;), workbox.strategies.staleWhileRevalidate());​&#125;\n将其中域名改为你自己主页的域名：https?://dxsummer.gitee.io/ 改为你的域名，格式要和我的一样。\n\n配置站点配置文件首先将生成的images文件复制到 /source 文件夹下将下面的配置代码复制到你的站点根目录配置文件 _config.yml中\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# https:&#x2F;&#x2F;github.com&#x2F;lavas-project&#x2F;hexo-pwapwa:  manifest:    path: &#x2F;manifest.json    body:      name: YH&#39;s Blog      short_name: YH&#39;s Blog      theme_color: #2196f3      background_color: #2196f3      display: standalone      orientation: portrait      scope: &#x2F;      start_url: &#x2F;      icons:        - src: &#x2F;images&#x2F;icons&#x2F;icon-72x72.png          type: image&#x2F;png          sizes: 72x72        - src: &#x2F;images&#x2F;icons&#x2F;icon-96x96.png          type: image&#x2F;png          sizes: 96x96        - src: &#x2F;images&#x2F;icons&#x2F;icon-128x128.png          type: image&#x2F;png          sizes: 128x128        - src: &#x2F;images&#x2F;icons&#x2F;icon-144x144.png          type: image&#x2F;png          sizes: 144x144        - src: &#x2F;images&#x2F;icons&#x2F;icon-152x152.png          type: image&#x2F;png          sizes: 152x152        - src: &#x2F;images&#x2F;icons&#x2F;icon-192x192.png          type: image&#x2F;png          sizes: 192x192        - src: &#x2F;images&#x2F;icons&#x2F;icon-384x384.png          type: image&#x2F;png          sizes: 384x384        - src: &#x2F;images&#x2F;icons&#x2F;icon-512x512.png          type: image&#x2F;png          sizes: 512x512  serviceWorker:    path: &#x2F;sw.js    preload:      urls:        - &#x2F;      posts: 12    opts:      networkTimeoutSeconds: 30    routes:      - pattern: !!js&#x2F;regexp &#x2F;hm.baidu.com&#x2F;        strategy: networkOnly      - pattern: !!js&#x2F;regexp &#x2F;www.google-analytics.com&#x2F;        strategy: networkOnly      - pattern: !!js&#x2F;regexp &#x2F;.*\\.(js|css|jpg|jpeg|png|gif)$&#x2F;        strategy: cacheFirst      - pattern: !!js&#x2F;regexp &#x2F;\\&#x2F;&#x2F;        strategy: networkFirst  priority: 5检查pwa部署是否成功执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n然后在浏览器输入localhost:4000，查看效果。\n按F12，然后选择Application—&gt;Service Workers，查看是否成功？\n\n成功状态提示：Status #xxx activated and is running\n\n谷歌浏览器安装PWA\n前面的步骤操作没错，配置也没问题，则在本地运行试，浏览器地址栏中会出现一个类似 ➕ 加号的图标，点击它会出现一个弹出框，就说明配置成功，当然你可以选择安装，安装过后桌面会出现一个图标，点击就可以访问，但是如果你本地服务关闭的话，再点击这个图标，有些页面可以访问，但有些页面访问不了。如果需要它都能够全部访问的话，你需要开启本地服务，也就是hexo s\n如果你的地址栏没有出现这个加号，首先在新的标签页上的地址栏输入Chrome://flags，然后再搜索栏输入PWAS进行查找，会出现两个选项一个为Desktop PWAs local updating，另一个为Desktop PWAs installable from the omnibox，将其设为Enabled，然后点击Relaunch，进行浏览器的重启，再查看localhost:4000，就会出现加号了。\n部署到github和coding123sudo hexo cleansudo hexo gsudo hexo d参考资料引用郭元洪\nHexo添加PWA支持\n","plink":"https://dxsummer.gitee.io/posts/805d5d89/"},{"title":"高数例题","date":"2020-05-06T11:11:13.000Z","date_formatted":{"ll":"2020年5月6日","L":"2020/05/06","MM-DD":"05-06"},"updated":"2020-06-08T01:54:58.972Z","content":"9.7方向导数与梯度1\n2\n设f(x,y,z)=x2+y2+z2,求gradf(1,-1,2)及其模\n\n\n9.8多元函数的极值及其求法1\n2\n![](https://i.loli.net/2020/05/08/SE3YZ9O2FiyweGU.png \"|block\")第九章测试1\n2\n3\n10.1二重积分的概念与性质1\n2\n3\n4 √\n10.2二重积分的计算1\n2\n3\n4\n5 √\n","plink":"https://dxsummer.gitee.io/posts/7c5cf7ba/"},{"title":"C语言程序算法","date":"2020-05-04T12:05:29.000Z","date_formatted":{"ll":"2020年5月4日","L":"2020/05/04","MM-DD":"05-04"},"updated":"2020-06-11T15:07:16.162Z","content":"三角形12345678910111213#include &lt;stdio.h&gt;main()&#123;    int a,b,c;    for(a=1;a&lt;6;a++)    &#123;\t        for(b=5;b&gt;=a*2-a;b--)            printf(\" \");        for(b=1;b&lt;=a*2-1;b++)            printf(\"*\");        printf(\"\\n\");    &#125;&#125;输出结果：\n12345    *   ***  ***** ****************对用户输入的任意一组数字，如{2,3,4,3,5,2,7,8,3,4}输出其中出现次数最多的数及次数1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123;    int i,j,n,max,a[1010],b[1010]=&#123;&#125;;    printf(\"要输入多少个数？\");    scanf(\"%d\",&amp;n);    printf(\"请输入\");    for(i=0;i&lt;n;i++)        scanf(\"%d\",&amp;a[i]);    for(i=0;i&lt;n;i++)        for(j=0;j&lt;n;j++)            if(a[i]==a[j])                b[i]++;    max=b[0],j=0;    for(i=0;i&lt;n;i++)        if(b[i]&gt;max)        &#123;            max=b[i];            j=i;        &#125;    printf(\"重复值%d 数量%d\\n\",a[j],max);    return 0;&#125;字符串多组输入，直到遇到回车结束输入\n论他大神给出的解决办法\n\n12string s;while(getline(std::cin,s)&amp;&amp;!s.empty())&#123;&#125;12char s[maxn];while(gets(s)&amp;&amp;strcmp(s,\"\")!=0)&#123;&#125;比较大小12345678910111213141516#include &lt;stdio.h&gt;int main()&#123;\tint a[5]=&#123;5,2,1,8&#125;,i,k,z;\tscanf(\"%d\",a[4]);\tfor(i=0;i&lt;5;i++)\t\tfor(k=i+1;k&lt;5;k++)\t\t\tif(a[i]&gt;a[k])\t\t\t&#123;\t\t\t\tz=a[i];\t\t\t\ta[i]=a[k];\t\t\t\ta[k]=z;\t\t\t&#125;\tfor(k=0;k&lt;5;k++)\tprintf(\"%d\\n\",a[k]);&#125;🍓以二进制形式打印制整数123456789101112131415161718192021222324252627/* binary.c -- 以二进制形式打印制整数 */#include　&lt;stdio.h&gt;void to_binary(unsigned long n);int main(void)&#123;    unsigned long number;    printf(\"Enter　an　integer　(q　to　quit):\\n\");    while(scanf(\"%lu\",&amp;number)　==　1)    &#123;        printf(\"Binary　equivalent:　\");        to_binary(number);        putchar('\\n');        printf(\"Enter　an　integer　(q　to　quit):\\n\");    &#125;    printf(\"Done.\\n\");    return　0;&#125;void to_binary(unsigned long n)　/* 递归函数 */&#123;    int r;    r=n%2;    if(n&gt;=2)    \tto_binary(n/2);    putchar(r==0?'0':'1');    return;&#125;","plink":"https://dxsummer.gitee.io/posts/13623648/"},{"title":"Step2 字符串和格式化输入/输出","date":"2020-04-29T09:02:38.000Z","date_formatted":{"ll":"2020年4月29日","L":"2020/04/29","MM-DD":"04-29"},"updated":"2020-06-08T01:44:53.958Z","content":"本章介绍以下内容：\n  函数：strlen()  关键字：const  字符串  如何创建、存储字符串  如何使用strlen()函数获取字符串的长度  用C预处理器指令#define和ANSIC的const修饰符创建符号常量  \n\n\n本章重点介绍输入和输出。与程序交互和使用字符串可以编写个性化的程序，本章将详细介绍C语言的两个输入/输出函数：printf()和scanf()。学会使用这两个函数，不仅能与用户交互，还可根据个人喜好和任务要求格式化输出。最后，简要介绍一个重要的工具——C预处理器指令，并学习如何定义、使用符号常量。\n\n程序清单4.1 talkback.c程序\n123456789101112131415161718192021// talkback.c -- 演示与用户交互#include &lt;stdio.h&gt;#include &lt;string.h&gt;　　 // 提供strlen()函数的原型#define DENSITY 62.4　　// 人体密度（单位：磅/立方英尺）int main()&#123;    float weight, volume;    int size, letters;    char name[40];　　　 // name是一个可容纳40个字符的数组    printf(\"Hi! What's your first name?\\n\");    scanf(\"%s\", name);    printf(\"%s, what's your weight in pounds?\\n\", name);    scanf(\"%f\", &amp;weight);    size = sizeof name;    letters = strlen(name);    volume = weight / DENSITY;    printf(\"Well, %s, your volume is %2.2f cubic feet.\\n\", name, volume);    printf(\"Also, your first name has %d letters,\\n\", letters);    printf(\"and we have %d bytes to store it.\\n\", size);    return 0;&#125;运行talkback.c程序，输入结果如下：\n1234567Hi! What's your first name?ChristineChristine, what's your weight in pounds?154Well, Christine, your volume is 2.47 cubic feet.Also, your first name has 9 letters,and we have 40 bytes to store it.该程序包含以下新特性。\n用数组（array）储存字符串（character string）。在该程序中，用户输入的名被储存在数组中，该数组占用内存中40个连续的字节，每个字节储存一个字符值。\n使用%s转换说明来处理字符串的输入和输出。注意，在scanf()中，name没有&amp;前缀，而weight有（稍后解释，&amp;weight和name都是地址）。\n用C预处理器把字符常量DENSITY定义为62.4。\n用C函数strlen()获取字符串的长度。\n对于BASIC的输入/输出而言，C的输入/输出看上去有些复杂。不过，复杂换来的是程序的高效和方便控制输入/输出。而且，一旦熟悉用法后，会发现它很简单。\n字符串简介字符串（character string）是一个或多个字符的序列，如下所示：\n1\"Zing went the strings of my heart!\"双引号不是字符串的一部分。双引号仅告知编译器它括起来的是字符串，正如单引号用于标识单个字符一样。\nchar类型数组和null字符C语言没有专门用于储存字符串的变量类型，字符串都被储存在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符（见图4.1）。\n注意图4.1中数组末尾位置的字符\\0。这是空字符（null character），C语言用它标记字符串的结束。空字符不是数字0，它是非打印字符，其ASCII码值是（或等价于）0。C中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。因此，程序清单4.1中有40个存储单元的字符串，只能储存39个字符，剩下一个字节留给空字符。\n那么，什么是数组？可以把数组看作是一行连续的多个存储单元。用更正式的说法是，数组是同类型数据元素的有序序列。程序清单4.1通过以下声明创建了一个包含40个存储单元（或元素）的数组，每个单元储存一个char类型的值：\n1char name[40];name后面的方括号表明这是一个数组，方括号中的40表明该数组中的元素数量。char表明每个元素的类型（见图4.2）。\n字符串看上去比较复杂！必须先创建一个数组，把字符串中的字符逐个放入数组，还要记得在末尾加上一个\\0。还好，计算机可以自己处理这些细节。\n使用字符串试着运行程序清单4.2，使用字符串其实很简单。\n程序清单4.2 praise1.c程序\n1234567891011/* praise1.c -- 使用不同类型的字符串 */#include &lt;stdio.h&gt;#define PRAISE \"You are an extraordinary being.\"int main(void)&#123;    char name[40];    printf(\"What's your name? \");    scanf(\"%s\", name);    printf(\"Hello, %s.%s\\n\", name, PRAISE);    return 0;&#125;%s告诉printf()打印一个字符串。%s出现了两次，因为程序要打印两个字符串：一个储存在name数组中；一个由PRAISE来表示。运行praise1.c，其输出如下所示：\n12What's your name? Angela PlainsHello, Angela.You are an extraordinary being.你不用亲自把空字符放入字符串末尾，scanf()在读取输入时就已完成这项工作。也不用在字符串常量PRAISE末尾添加空字符。稍后我们会解释#define指令，现在先理解PRAISE后面用双引号括起来的文本是一个字符串。编译器会在末尾加上空字符。\n注意（这很重要），scanf()只读取了Angela Plains中的Angela，它在遇到第1个空白（空格、制表符或换行符）时就不再读取输入。因此，scanf()在读到Angela和Plains之间的空格时就停止了。一般而言，根据%s转换说明，scanf()只会读取字符串中的一个单词，而不是一整句。C语言还有其他的输入函数（如，fgets()），用于读取一般字符串。后面章节将详细介绍这些函数。\n字符串和字符字符串常量&quot;x&quot;和字符常量&#39;x&#39;不同。区别之一在于&#39;x&#39;是基本类型（char），而&quot;x&quot;是派生类型（char数组）；区别之二是&quot;x&quot;实际上由两个字符组成：&#39;x&#39;和空字符\\0（见图4.3）。\nstrlen()函数上一章提到了 sizeof 运算符，它以字节为单位给出对象的大小。strlen()函数给出字符串中的字符长度。因为 1 字节储存一个字符，读者可能认为把两种方法应用于字符串得到的结果相同，但事实并非如此。请根据程序清单4.3，在程序清单4.2中添加几行代码，看看为什么会这样。\n程序清单4.3 praise2.c程序\n123456789101112131415161718/* praise2.c */// 如果编译器不识别%zd，尝试换成%u或%lu。#include &lt;stdio.h&gt;#include &lt;string.h&gt;　　/* 提供strlen()函数的原型 */#define PRAISE \"You are an extraordinary being.\"int main(void)&#123;    char name[40];    printf(\"What's your name? \");    scanf(\"%s\", name);    printf(\"Hello, %s.%s\\n\", name, PRAISE);    printf(\"Your name of %zd letters occupies %zd memory cells.\\n\",    strlen(name), sizeof name);    printf(\"The phrase of praise has %zd letters \",    strlen(PRAISE));    printf(\"and occupies %zd memory cells.\\n\", sizeof PRAISE);    return 0;&#125;如果使用ANSI C之前的编译器，必须移除这一行：\n1#include &lt;string.h&gt;string.h头文件包含多个与字符串相关的函数原型，包括strlen()。第11章将详细介绍该头文件（顺带一提，一些ANSI之前的UNIX系统用strings.h代替string.h，其中也包含了一些字符串函数的声明）。\n一般而言，C 把函数库中相关的函数归为一类，并为每类函数提供一个头文件。例如，printf()和scanf()都隶属标准输入和输出函数，使用stdio.h头文件。string.h头文件中包含了strlen()函数和其他一些与字符串相关的函数（如拷贝字符串的函数和字符串查找函数）。\n注意，程序清单4.3使用了两种方法处理很长的printf()语句。第1种方法是将printf()语句分为两行（可以在参数之间断为两行，但是不要在双引号中的字符串中间断开）；第 2 种方法是使用两个printf()语句打印一行内容，只在第2条printf()语句中使用换行符（\\n）。运行该程序，其交互输出如下：\n1234What's your name? Serendipity ChanceHello, Serendipity.You are an extraordinary being.Your name of 11 letters occupies 40 memory cells.The phrase of praise has 31 letters and occupies 32 memory cells.sizeof运算符报告，name数组有40个存储单元。但是，只有前11个单元用来储存Serendipity，所以strlen()得出的结果是11。name数组的第12个单元储存空字符，strlen()并未将其计入。图4.4演示了这个概念。\n对于 PRAISE，用 strlen()得出的也是字符串中的字符数（包括空格和标点符号）。然而，sizeof运算符给出的数更大，因为它把字符串末尾不可见的空字符也计算在内。该程序并未明确告诉计算机要给字符串预留多少空间，所以它必须计算双引号内的字符数。\n第 3 章提到过，C99 和 C11 标准专门为 sizeof 运算符的返回类型添加了%zd 转换说明，这对于strlen()同样适用。对于早期的C，还要知道sizeof和strlen()返回的实际类型（通常是unsigned或unsigned long）。\n另外，还要注意一点：上一章的 sizeof 使用了圆括号，但本例没有。圆括号的使用时机否取决于运算对象是类型还是特定量？运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无。也就是说，对于类型，应写成sizeof(char)或sizeof(float)；对于特定量，可写成sizeof name或sizeof 6.28。尽管如此，还是建议所有情况下都使用圆括号，如sizeof(6.28)。\n程序清单4.3中使用strlen()和sizeof，完全是为了满足读者的好奇心。在实际应用中，strlen()和 sizeof 是非常重要的编程工具。例如，在各种要处理字符串的程序中，strlen()很有用。详见第11章。\n下面我们来学习#define指令。\n常量和C预处理器有时，在程序中要使用常量。例如，可以这样计算圆的周长：\n1circumference &#x3D; 3.14159 * diameter;这里，常量3.14159代表著名的常量pi（π）。在该例中，输入实际值便可使用这个常量。然而，这种情况使用符号常量（symbolic constant）会更好。也就是说，使用下面的语句，计算机稍后会用实际值完成替换：\n1circumference &#x3D; pi * diameter;为什么使用符号常量更好？首先，常量名比数字表达的信息更多。请比较以下两条语句：\n12owed &#x3D; 0.015 * housevalue;owed &#x3D; taxrate * housevalue;如果阅读一个很长的程序，第2条语句所表达的含义更清楚。\n另外，假设程序中的多处使用一个常量，有时需要改变它的值。毕竟，税率通常是浮动的。如果程序使用符号常量，则只需更改符号常量的定义，不用在程序中查找使用常量的地方，然后逐一修改。\n那么，如何创建符号常量？方法之一是声明一个变量，然后将该变量设置为所需的常量。可以这样写：\n123float taxrate;taxrate &#x3D; 0.015;这样做提供了一个符号名，但是taxrate是一个变量，程序可能会无意间改变它的值。C语言还提供了一个更好的方案——C预处理器。第2 章中介绍了预处理器如何使用#include包含其他文件的信息。预处理器也可用来定义常量。只需在程序顶部添加下面一行：\n1#define TAXRATE 0.015编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换（compile-time substitution）。在运行程序时，程序中所有的替换均已完成（见图 4.5）。通常，这样定义的常量也称为明示常量（manifest constant）[1]。\n请注意格式，首先是#define，接着是符号常量名（TAXRATE），然后是符号常量的值（0.015）（注意，其中并没有=符号）。所以，其通用格式如下：\n1#define NAME value实际应用时，用选定的符号常量名和合适的值来替换NAME和value。注意，末尾不用加分号，因为这是一种由预处理器处理的替换机制。为什么 TAXRATE 要用大写？用大写表示符号常量是 C 语言一贯的传统。这样，在程序中看到全大写的名称就立刻明白这是一个符号常量，而非变量。大写常量只是为了提高程序的可读性，即使全用小写来表示符号常量，程序也能照常运行。尽管如此，初学者还是应该养成大写常量的好习惯。\n另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量（如，c_level或k_line）。\n符号常量的命名规则与变量相同。可以使用大小写字母、数字和下划线字符，首字符不能为数字。程序清单4.4演示了一个简单的示例。\n程序清单4.4 pizza.c程序\n1234567891011121314/* pizza.c -- 在比萨饼程序中使用已定义的常量 */#include &lt;stdio.h&gt;#define PI 3.14159int main(void)&#123;    float area, circum, radius;    printf(\"What is the radius of your pizza?\\n\");    scanf(\"%f\", &amp;radius);    area = PI * radius * radius;    circum = 2.0 * PI *radius;    printf(\"Your basic pizza parameters are as follows:\\n\");    printf(\"circumference = %1.2f, area = %1.2f\\n\", circum,area);    return 0;&#125;printf()语句中的%1.2f表明，结果被四舍五入为两位小数输出。下面是一个输出示例：\n1234What is the radius of your pizza?6.0Your basic pizza parameters are as follows:circumference = 37.70, area = 113.10#define指令还可定义字符和字符串常量。前者使用单引号，后者使用双引号。如下所示：\n1234#define BEEP '\\a'#define TEE 'T'#define ESC '\\033'#define OOPS \"Now you have done it!\"记住，符号常量名后面的内容被用来替换符号常量。不要犯这样的常见错误：\n12/* 错误的格式 */#define TOES = 20如果这样做，替换TOES的是= 20，而不是20。这种情况下，下面的语句：\n1digits = fingers + TOES;将被转换成错误的语句：\n1digits = fingers + = 20;const限定符C90标准新增了const关键字，用于限定一个变量为只读（注意，在C语言中，用const类型限定符声明的是变量，不是常量。）\n1const int MONTHS = 12; // MONTHS在程序中不可更改，值为12这使得MONTHS成为一个只读值。也就是说，可以在计算中使用MONTHS，可以打印MONTHS，但是不能更改MONTHS的值。const用起来比#define更灵活，第12章将讨论与const相关的内容。\n明示常量C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息。每个头文件都定义了一系列供实现使用的明示常量 [再次提醒读者注意，本书作者认为“明示常量”相当于“符号常量”，经常在书中混用这两个术语。]。例如，limits.h头文件包含以下类似的代码：\n12#define INT_MAX +32767#define INT_MIN -32768这些明示常量代表int类型可表示的最大值和最小值。如果系统使用32 位的int，该头文件会为这些明示常量提供不同的值。如果在程序中包含limits.h头文件，就可编写下面的代码：\n1printf(\"Maximum int value on this system = %d\\n\", INT_MAX);如果系统使用4字节的int，limits.h头文件会提供符合4字节int的INT_MAX和INT_MIN。表4.1列出了limits.h中能找到的一些明示常量。\n类似地，float.h头文件中也定义一些明示常量，如FLT_DIG和DBL_DIG，分别表示float类型和double类型的有效数字位数。表4.2列出了float.h中的一些明示常量（可以使用文本编辑器打开并查看系统使用的float.h头文件）。表中所列都与float类型相关。把明示常量名中的FLT分别替换成DBL和LDBL，即可分别表示double和long double类型对应的明示常量（表中假设系统使用2的幂来表示浮点数）。\n程序清单4.5演示了如何使用float.h和limits.h中的数据（注意，编译器要完全支持C99标准才能识别LLONG_MIN标识符）。\n程序清单4.5 defines.c程序\n12345678910111213141516// defines.c -- 使用limit.h和float头文件中定义的明示常量#include &lt;stdio.h&gt;#include &lt;limits.h&gt;　 // 整型限制#include &lt;float.h&gt;　　// 浮点型限制int main(void)&#123;    printf(\"Some number limits for this system:\\n\");    printf(\"Biggest int: %d\\n\", INT_MAX);    printf(\"Smallest long long: %lld\\n\", LLONG_MIN);    printf(\"One byte = %d bits on this system.\\n\", CHAR_BIT);    printf(\"Largest double: %e\\n\", DBL_MAX);    printf(\"Smallest normal float: %e\\n\", FLT_MIN);    printf(\"float precision = %d digits\\n\", FLT_DIG);    printf(\"float epsilon = %e\\n\", FLT_EPSILON);    return 0;&#125;该程序的输出示例如下：\n12345678Some number limits for this system:Biggest int: 2147483647Smallest long long: -9223372036854775808One byte = 8 bits on this system.Largest double: 1.797693e+308Smallest normal float: 1.175494e-38float precision = 6 digitsfloat epsilon = 1.192093e-07C预处理器是非常有用的工具，要好好利用它。本书的后面章节中会介绍更多相关应用。\nprintf()和scanf()printf()函数和scanf()函数能让用户可以与程序交流，它们是输入/输出函数，或简称为I/O函数。它们不仅是C语言中的I/O函数，而且是最多才多艺的函数。过去，这些函数和C库的一些其他函数一样，并不是C语言定义的一部分。最初，C把输入/输出的实现留给了编译器的作者，这样可以针对特殊的机器更好地匹配输入/输出。后来，考虑到兼容性的问题，各编译器都提供不同版本的printf()和scanf()。尽管如此，各版本之间偶尔有一些差异。C90 和C99 标准规定了这些函数的标准版本，本书亦遵循这一标准。\n虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎相同。两个函数都使用格式字符串和参数列表。我们先介绍printf()，再介绍scanf()。\nprintf()函数请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如，打印整数时使用%d，打印字符时使用%c。这些符号被称为转换说明（conversion specification），它们指定了如何把数据转换成可显示的形式。我们先列出ANSI C标准为printf()提供的转换说明，然后再示范如何使用一些较常见的转换说明。表4.3列出了一些转换说明和各自对应的输出类型。\n\n使用printf()程序清单4.6的程序中使用了一些转换说明。\n程序清单4.6 printout.c程序\n1234567891011121314/* printout.c -- 使用转换说明 */#include &lt;stdio.h&gt;#define PI 3.141593int main(void)&#123;    int number = 7;    float pies = 12.75;    int cost = 7800;    printf(\"The %d contestants ate %f berry pies.\\n\", number,pies);    printf(\"The value of pi is %f.\\n\", PI);    printf(\"Farewell! thou art too dear for my possessing,\\n\");    printf(\"%c%d\\n\", '$', 2 * cost);    return 0;&#125;该程序的输出如下：\n1234The 7 contestants ate 12.750000 berry pies.The value of pi is 3.141593.Farewell! thou art too dear for my possessing,$15600这是printf()函数的格式：\n1printf( 格式字符串, 待打印项1, 待打印项2,...);待打印项1、待打印项2等都是要打印的项。它们可以是变量、常量，甚至是在打印之前先要计算的表达式。第3章提到过，格式字符串应包含每个待打印项对应的转换说明。例如，考虑下面的语句：\n1printf(\"The %d contestants ate %f berry pies.\\n\", number,pies);格式字符串是双引号括起来的内容。上面语句的格式字符串包含了两个待打印项number和poes对应的两个转换说明。图4.6演示了printf()语句的另一个例子。\n下面是程序清单4.6中的另一行：\n1printf(\"The value of pi is %f.\\n\", PI);该语句中，待打印项列表只有一个项——符号常量PI。\n如图4.7所示，格式字符串包含两种形式不同的信息：实际要打印的字符；转换说明。\n警告\n格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果。千万别写成下面这样：\n1printf(\"The score was Squids %d, Slugs %d.\\n\", score1);这里，第2个%d没有对应任何项。系统不同，导致的结果也不同。不过，出现这种问题最好的状况是得到无意义的值。\n如果只打印短语或句子，就不需要使用任何转换说明。如果只打印数据，也不用加入说明文字。程序清单4.6中的最后两个printf()语句都没问题：\n12printf(\"Farewell! thou art too dear for my possessing,\\n\");printf(\"%c%d\\n\", '$', 2 * cost);注意第2条语句，待打印列表的第1个项是一个字符常量，不是变量；第2个项是一个乘法表达式。这说明printf()使用的是值，无论是变量、常量还是表达式的值。\n由于 printf()函数使用%符号来标识转换说明，因此打印%符号就成了个问题。如果单独使用一个%符号，编译器会认为漏掉了一个转换字符。解决方法很简单，使用两个%符号就行了：\n12pc = 2*6;printf(\"Only %d%% of Sally's gribbles were edible.\\n\", pc);下面是输出结果：\n1Only 12% of Sally's gribbles were edible.printf()的转换说明修饰符在%和转换字符之间插入修饰符可修饰基本的转换说明。表4.4和表4.5列出可作为修饰符的合法字符。如果要插入多个字符，其书写顺序应该与表4.4中列出的顺序相同。不是所有的组合都可行。表中有些字符是C99新增的，如果编译器不支持C99，则可能不支持表中的所有项。\n\n注意 类型可移植性\nsizeof 运算符以字节为单位返回类型或值的大小。这应该是某种形式的整数，但是标准只规定了该值是无符号整数。在不同的实现中，它可以是unsigned int、unsigned long甚至是unsigned long long。因此，如果要用printf()函数显示sizeof表达式，根据不同系统，可能使用%u、%lu或%llu。这意味着要查找你当前系统的用法，如果把程序移植到不同的系统还要进行修改。鉴于此， C提供了可移植性更好的类型。首先，stddef.h头文件（在包含stdio.h头文件时已包含其中）把size_t定义成系统使用sizeof返回的类型，这被称为底层类型（underlying type）。其次，printf()使用z修饰符表示打印相应的类型。同样，C还定义了ptrdiff_t类型和t修饰符来表示系统使用的两个地址差值的底层有符号整数类型。\n注意 float参数的转换对于浮点类型，有用于double和long double类型的转换说明，却没有float类型的。这是因为在K&amp;R C中，表达式或参数中的float类型值会被自动转换成double类型。一般而言，ANSI C不会把float自动转换成double。然而，为保护大量假设float类型的参数被自动转换成double的现有程序，printf()函数中所有float类型的参数（对未使用显式原型的所有C函数都有效）仍自动转换成double类型。因此，无论是K&amp;R C还是ANSI C，都没有显示float类型值专用的转换说明。\n\n使用修饰符和标记的示例接下来，用程序示例演示如何使用这些修饰符和标记。先来看看字段宽度在打印整数时的效果。考虑程序清单4.7中的程序。\n程序清单4.7 width.c程序\n1234567891011/* width.c -- 字段宽度 */#include &lt;stdio.h&gt;#define PAGES 959int main(void)&#123;    printf(\"*%d*\\n\", PAGES);    printf(\"*%2d*\\n\", PAGES);    printf(\"*%10d*\\n\", PAGES);    printf(\"*%-10d*\\n\", PAGES);    return 0;&#125;程序清单4.7通过4种不同的转换说明把相同的值打印了4次。程序中使用星号（*）标出每个字段的开始和结束。其输出结果如下所示：\n1234*959**959**　　 959**959　　 *第1个转换说明%d不带任何修饰符，其对应的输出结果与带整数字段宽度的转换说明的输出结果相同。在默认情况下，没有任何修饰符的转换说明，就是这样的打印结果。\n第2个转换说明是%2d，其对应的输出结果应该是 2 字段宽度。因为待打印的整数有 3 位数字，所以字段宽度自动扩大以符合整数的长度。\n第 3个转换说明是%10d，其对应的输出结果有10个空格宽度，实际上在两个星号之间有7个空格和3位数字，并且数字位于字段的右侧。\n最后一个转换说明是%-10d，其对应的输出结果同样是 10 个空格宽度，-标记说明打印的数字位于字段的左侧。熟悉它们的用法后，能很好地控制输出格式。试着改变PAGES的值，看看编译器如何打印不同位数的数字。\n\n接下来看看浮点型格式。请输入、编译并运行程序清单4.8中的程序。\n\n程序清单4.8 floats.c程序\n123456789101112131415// floats.c -- 一些浮点型修饰符的组合#include &lt;stdio.h&gt;int main(void)&#123;    const double RENT = 3852.99;　// const变量    printf(\"*%f*\\n\", RENT);    printf(\"*%e*\\n\", RENT);    printf(\"*%4.2f*\\n\", RENT);    printf(\"*%3.1f*\\n\", RENT);    printf(\"*%10.3f*\\n\", RENT);    printf(\"*%10.3E*\\n\", RENT);    printf(\"*%+4.2f*\\n\", RENT);    printf(\"*%010.2f*\\n\", RENT);    return 0;&#125;该程序中使用了const关键字，限定变量为只读。该程序的输出如下：\n12345678*3852.990000**3.852990e+03**3852.99**3853.0**　3852.990** 3.853E+03**+3852.99**0003852.99*本例的第1个转换说明是%f。在这种情况下，字段宽度和小数点后面的位数均为系统默认设置，即字段宽度是容纳带打印数字所需的位数和小数点后打印6位数字。\n第2个转换说明是%e。默认情况下，编译器在小数点的左侧打印1个数字，在小数点的右侧打印6个数字。这样打印的数字太多！解决方案是指定小数点右侧显示的位数，程序中接下来的 4 个例子就是这样做的。请注意，第4个和第6个例子对输出结果进行了四舍五入。另外，第6个例子用E代替了e。\n第7个转换说明中包含了+标记，这使得打印的值前面多了一个代数符号（+）。0标记使得打印的值前面以0填充以满足字段要求。注意，转换说明%010.2f的第1个0是标记，句点（.）之前、标记之后的数字（本例为10）是指定的字段宽度。尝试修改RENT的值，看看编译器如何打印不同大小的值。程序清单4.9演示了其他组合。\n程序清单4.9 flags.c程序\n123456789/* flags.c -- 演示一些格式标记 */#include &lt;stdio.h&gt;int main(void)&#123;    printf(\"%x %X %#x\\n\", 31, 31, 31);    printf(\"**%d**% d**% d**\\n\", 42, 42, -42);    printf(\"**%5d**%5.3d**%05d**%05.3d**\\n\", 6, 6, 6, 6);    return 0;&#125;该程序的输出如下：\n1231f 1F 0x1f**42** 42**-42****　 6** 006**00006** 006**第1行输出中，1f是十六进制数，等于十进制数31。第1行printf()语句中，根据%x打印出1f，%F打印出1F，%#x打印出0x1f。\n第 2 行输出演示了如何在转换说明中用空格在输出的正值前面生成前导空格，负值前面不产生前导空格。这样的输出结果比较美观，因为打印出来的正值和负值在相同字段宽度下的有效数字位数相同。\n第3行输出演示了如何在整型格式中使用精度（%5.3d）生成足够的前导0以满足最小位数的要求（本例是3）。然而，使用0标记会使得编译器用前导0填充满整个字段宽度。最后，如果0标记和精度一起出现，0标记会被忽略。\n\n下面来看看字符串格式的示例。考虑程序清单4.10中的程序。\n\n程序清单4.10 stringf.c程序\n1234567891011/* stringf.c -- 字符串格式 */#include &lt;stdio.h&gt;#define BLURB \"Authentic imitation!\"int main(void)&#123;    printf(\"[%2s]\\n\", BLURB);    printf(\"[%24s]\\n\", BLURB);    printf(\"[%24.5s]\\n\", BLURB);    printf(\"[%-24.5s]\\n\", BLURB);    return 0;&#125;该程序的输出如下：\n1234[Authentic imitation!][　　Authentic imitation!][　　　　　　　　　　Authe][Authe　　　　　　　　　　]注意，虽然第1个转换说明是%2s，但是字段被扩大为可容纳字符串中的所有字符。还需注意，精度限制了待打印字符的个数。.5告诉printf()只打印5个字符。另外，-标记使得文本左对齐输出。\n学以致用学习完以上几个示例，试试如何用一个语句打印以下格式的内容：\n1The NAME family just may be $XXX.XX dollars richer!这里，NAME和XXX.XX代表程序中变量（如name[40]和cash）的值。可参考以下代码：\n1printf(\"The %s family just may be $%.2f richer!\\n\",name,cash);转换说明的意义下面深入探讨一下转换说明的意义。转换说明把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。例如，数字76在计算机内部的存储格式是二进制数01001100。%d转换说明将其转换成字符7和6，并显示为76；%x转换说明把相同的值（01001100）转换成十六进制记数法4c；%c转换说明把01001100转换成字符L。\n转换（conversion）可能会误导读者认为原始值被转替换成转换后的值。实际上，转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制整数文本并打印出来”。\n转换不匹配\n前面强调过，转换说明应该与待打印值的类型相匹配。通常都有多种选择。例如，如果要打印一个int类型的值，可以使用%d、%x或%o。这些转换说明都可用于打印int类型的值，其区别在于它们分别表示一个值的形式不同。类似地，打印double类型的值时，可使用%f、%e或%g。\n转换说明与待打印值的类型不匹配会怎样？上一章中介绍过不匹配导致的一些问题。匹配非常重要，一定要牢记于心。程序清单4.11演示了一些不匹配的整型转换示例。\n程序清单4.11 intconv.c程序\n1234567891011121314/* intconv.c -- 一些不匹配的整型转换 */#include &lt;stdio.h&gt;#define PAGES 336#define WORDS 65618int main(void)&#123;    short num = PAGES;    short mnum = -PAGES;    printf(\"num as short and unsigned short:　%hd %hu\\n\", num,num);    printf(\"-num as short and unsigned short: %hd %hu\\n\", mnum,mnum);    printf(\"num as int and char: %d %c\\n\", num, num);    printf(\"WORDS as int, short, and char: %d %hd %c\\n\",WORDS,WORDS, WORDS);    return 0;&#125;在我们的系统中，该程序的输出如下：\n1234num as short and unsigned short: 336 336-num as short and unsigned short: -336 65200num as int and char: 336 PWORDS as int, short, and char: 65618 82 R请看输出的第1行，num变量对应的转换说明%hd和%hu输出的结果都是336。这没有任何问题。\n然而，第2行mnum变量对应的转换说明%u（无符号）输出的结果却为65200，并非期望的336。这是由于有符号short int类型的值在我们的参考系统中的表示方式所致。首先，short int的大小是2字节；其次，系统使用二进制补码来表示有符号整数。这种方法，数字0～32767代表它们本身，而数字32768～65535则表示负数。其中，65535表示-1，65534表示-2，以此类推。因此，-336表示为65200（即， 65536-336）。所以被解释成有符号int时，65200代表-336；而被解释成无符号int时，65200则代表65200。一定要谨慎！一个数字可以被解释成两个不同的值。尽管并非所有的系统都使用这种方法来表示负整数，但要注意一点：别期望用%u转换说明能把数字和符号分开。\n第3行演示了如果把一个大于255的值转换成字符会发生什么情况。在我们的系统中，short int是2字节，char是1字节。当printf()使用%c打印336时，它只会查看储存336的2字节中的后1字节。这种截断（见图4.8）相当于用一个整数除以256，只保留其余数。在这种情况下，余数是80，对应的ASCII值是字符P。用专业术语来说，该数字被解释成“以256为模”（modulo 256），即该数字除以256后取其余数。\n最后，我们在该系统中打印比short int类型最大整数（32767）更大的整数（65618）。这次，计算机也进行了求模运算。在本系统中，应把数字65618储存为4字节的int类型值。用%hd转换说明打印时， printf()只使用最后2个字节。这相当于65618除以65536的余数。这里，余数是82。鉴于负数的储存方法，如果余数在32767～65536范围内会被打印成负数。对于整数大小不同的系统，相应的处理行为类似，但是产生的值可能不同。\n总结\n当遇到溢出问题，为：**该数字模除256后取其余数**混淆整型和浮点型，结果更奇怪。考虑程序清单4.12。\n程序清单4.12 floatcnv.c程序\n12345678910111213/* floatcnv.c -- 不匹配的浮点型转换 */#include &lt;stdio.h&gt;int main(void)&#123;    float n1 = 3.0;    double n2 = 3.0;    long n3 = 2000000000;    long n4 = 1234567890;    printf(\"%.1e %.1e %.1e %.1e\\n\", n1, n2, n3, n4);    printf(\"%ld %ld\\n\", n3, n4);    printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);    return 0;&#125;在我们的系统中，该程序的输出如下：\n1233.0e+00 3.0e+00 3.1e+46 1.7e+2662000000000 12345678900 1074266112 0 1074266112第1行输出显示，%e转换说明没有把整数转换成浮点数。\n考虑一下，如果使用%e转换说明打印n3（long类型）会发生什么情况。首先，%e转换说明让printf()函数认为待打印的值是double类型（本系统中double为8字节）。当printf()查看n3（本系统中是4字节的值）时，除了查看n3的4字节外，还会查看查看n3相邻的4字节，共8字节单元。接着，它将8字节单元中的位组合解释成浮点数（如，把一部分位组合解释成指数）。因此，即使n3的位数正确，根据%e转换说明和%ld转换说明解释出来的值也不同。最终得到的结果是无意义的值。\n第1行也说明了前面提到的内容：float类型的值作为printf()参数时会被转换成double类型。在本系统中，float是4字节，但是为了printf()能正确地显示该值，n1被扩成8字节。\n第2行输出显示，只要使用正确的转换说明，printf()就可以打印n3和n4。\n第3行输出显示，如果printf()语句有其他不匹配的地方，即使用对了转换说明也会生成虚假的结果。用%ld转换说明打印浮点数会失败，但是在这里，用%ld打印long类型的数竟然也失败了！问题出在C如何把信息传递给函数。具体情况因编译器实现而异。“参数传递”框中针对一个有代表性的系统进行了讨论。\n\n参数传递\n\n参数传递机制因实现而异。下面以我们的系统为例，分析参数传递的原理。函数调用如下：\n1printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);该调用告诉计算机把变量n1、n2、n3和n4的值传递给程序。这是一种常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被储存在栈中，占8字节（float类型被转换成double类型）。同样，n2也在栈中占8字节，而n3和n4在栈中分别占4字节。然后，控制转到printf()函数。该函数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明printf()应该读取4字节，所以printf()读取栈中的前4字节作为第1个值。这是n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说明，printf()再读取4字节，这是n1的后半部分，将被解释成第2个long类型的整数（见图4.9）。类似地，根据第3个和第4个%ld，printf()读取n2的前半部分和后半部分，并解释成两个long类型的整数。因此，对于n3和n4，虽然用对了转换说明，但printf()还是读错了字节。\n12345float n1; /* 作为double类型传递 */double n2;long n3, n4;...printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);printf()的返回值第2章提到过，大部分C函数都有一个返回值，这是函数计算并返回给主调程序（calling program）的值。例如，C库包含一个sqrt()函数，接受一个数作为参数，并返回该数的平方根。可以把返回值赋给变量，也可以用于计算，还可以作为参数传递。总之，可以把返回值像其他值一样使用。printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误，printf()则返回一个负值（printf()的旧版本会返回不同的值）。\nprintf()的返回值是其打印输出功能的附带用途，通常很少用到，但在检查输出错误时可能会用到（如，在写入文件时很常用）。如果一张已满的CD或DVD拒绝写入时，程序应该采取相应的行动，例如终端蜂鸣30秒。不过，要实现这种情况必须先了解if语句。程序清单4.13演示了如何确定函数的返回值。\n程序清单4.13 prntval.c程序\n12345678910/* prntval.c -- printf()的返回值 */#include &lt;stdio.h&gt;int main(void)&#123;    int bph2o = 212;    int rv;    rv = printf(\"%d F is water's boiling point.\\n\", bph2o);    printf(\"The printf() function printed %d characters.\\n\",rv);    return 0;&#125;该程序的输出如下：\n12212 F is water's boiling point.The printf() function printed 32 characters.首先，程序用rv = printf(...);的形式把printf()的返回值赋给rv。因此，该语句执行了两项任务：打印信息和给变量赋值。其次，注意计算针对所有字符数，包括空格和不可见的换行符（\\n）。\n打印较长的字符串有时，printf()语句太长，在屏幕上不方便阅读。如果空白（空格、制表符、换行符）仅用于分隔不同的部分，C 编译器会忽略它们。因此，一条语句可以写成多行，只需在不同部分之间输入空白即可。例如，程序清单4.13中的一条printf()语句：\n12printf(\"The printf() function printed %d characters.\\n\",rv);该语句在逗号和 rv之间断行。为了让读者知道该行未完，示例缩进了 rv。C编译器会忽略多余的空白。\n但是，不能在双引号括起来的字符串中间断行。如果这样写：\n12printf(\"The printf() function printed %dcharacters.\\n\", rv);C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\\n来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行符。\n给字符串断行有3种方法，如程序清单4.14所示。\n12345678910111213141516程序清单4.14 longstrg.c程序/* longstrg.c ––打印较长的字符串 */\\#include &lt;stdio.h&gt;int main(void)&#123;    printf(\"Here's one way to print a \");\t//方法1    printf(\"long string.\\n\");        printf(\"Here's another way to print a \\long string.\\n\");\t//方法2        printf(\"Here's the newest way to print a \"\"long string.\\n\");　　/* ANSI C */    return 0;&#125;该程序的输出如下：\n123Here's one way to print a long string.Here's another way to print a long string.Here's the newest way to print a long string.方法1：使用多个printf()语句。因为第1个字符串没有以\\n字符结束，所以第2个字符串紧跟第1个字符串末尾输出。\n方法2：用反斜杠（\\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。\n方法3：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作是一个字符串。因此，以下3种形式是等效的：\n123456printf(\"Hello, young lovers, wherever you are.\");printf(\"Hello, young \"　　 \"lovers\" \", wherever you are.\");printf(\"Hello, young lovers\"\", wherever you are.\");上述方法中，要记得在字符串中包含所需的空格。如，&quot;young&quot;&quot;lovers&quot;会成为&quot;younglovers&quot;，而&quot;young &quot; &quot;lovers&quot;才是&quot;young lovers&quot;。\n使用scanf()刚学完输出，接下来我们转至输入——学习scanf()函数。C库包含了多个输入函数，scanf()是最通用的一个，因为它可以读取不同格式的数据。当然，从键盘输入的都是文本，因为键盘只能生成文本字符：字母、数字和标点符号。如果要输入整数 2014，就要键入字符 2、0、1、4。如果要将其储存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf()要做的。scanf()把输入的字符串转换成整数、浮点数、字符或字符串，而 printf()正好与它相反，把整数、浮点数、字符和字符串转换成显示在屏幕上的文本。\nscanf()和 printf()类似，也使用格式字符串和参数列表。scanf()中的格式字符串表明字符输入流的目标数据类型。两个函数主要的区别在参数列表中。printf()函数使用变量、常量和表达式，而scanf()函数使用指向变量的指针。\n这里，读者不必了解如何使用指针，只需记住以下两条简单的规则：\n如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;；\n如果用scanf()把字符串读入字符数组中，不要使用&amp;。\n程序清单4.15中的小程序演示了这两条规则。\n12345678910111213141516程序清单4.15 input.c程序// input.c -- 何时使用&amp;\\#include &lt;stdio.h&gt;int main(void)&#123;    int age;　　　　　 // 变量    float assets;　　　// 变量    char pet[30];　　　// 字符数组，用于储存字符串    printf(\"Enter your age, assets, and favorite pet.\\n\");    scanf(\"%d %f\", &amp;age, &amp;assets); // 这里要使用&amp;    scanf(\"%s\", pet);　　　　　　　 // 字符数组不使用&amp;    printf(\"%d $%.2f %s\\n\", age, assets, pet);    return 0;&#125;下面是该程序与用户交互的示例：\n1234Enter your age, assets, and favorite pet.3892360.88 llama38 $92360.88 llamascanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。在依次把转换说明和字段匹配时跳过空白。注意，上面示例的输入项（粗体部分是用户的输入）分成了两行。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入：\n12345Enter your age, assets, and favorite pet.422121.45guppy42 $2121.45 guppy唯一例外的是%c转换说明。根据%c，scanf()会读取每个字符，包括空白。我们稍后详述这部分。\nscanf()函数所用的转换说明与printf()函数几乎相同。主要的区别是，对于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说明。而scanf()只把它们用于float类型，对于double类型时要使用l修饰符。表4.6列出了C99标准中常用的转换说明。\n表4.6 ANSI C中scanf()的转换说明\n可以在表4.6所列的转换说明中（百分号和转换字符之间）使用修饰符。如果要使用多个修饰符，必须按表4.7所列的顺序书写。\n表4.7 scanf()转换说明中的修饰符\n\n如你所见，使用转换说明比较复杂，而且这些表中还省略了一些特性。省略的主要特性是，从高度格式化源中读取选定数据，如穿孔卡或其他数据记录。因为在本书中，scanf()主要作为与程序交互的便利工具，所以我们不在书中讨论更复杂的特性。\n1.从scanf()角度看输入\n接下来，我们更详细地研究scanf()怎样读取输入。假设scanf()根据一个%d转换说明读取一个整数。scanf()函数每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取。因为要读取整数，所以 scanf()希望发现一个数字字符或者一个符号（+或-）。如果找到一个数字或符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。scanf()不断地读取和保存字符，直至遇到非数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后，scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。最后，scanf()计算已读取数字（可能还有符号）相应的数值，并将计算后的值放入指定的变量中。\n如果使用字段宽度，scanf()会在字段结尾或第1个空白字符处停止读取（满足两个条件之一便停止）。\n如果第1个非空白字符是A而不是数字，会发生什么情况？scanf()将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明， scanf()就一直无法越过A读下一个字符。另外，如果使用带多个转换说明的scanf()，C规定在第1个出错处停止读取输入。\n用其他数值匹配的转换说明读取输入和用%d 的情况相同。区别在于 scanf()会把更多字符识别成数字的一部分。例如，%x转换说明要求scanf()识别十六进制数a～f和A～F。浮点转换说明要求scanf()识别小数点、e记数法（指数记数法）和新增的p记数法（十六进制指数记数法）。\n如果使用%s 转换说明，scanf()会读取除空白以外的所有字符。scanf()跳过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符串。如果使用字段宽度，scanf()在字段末尾或第1个空白字符处停止读取。无法利用字段宽度让只有一个%s的scanf()读取多个单词。最后要注意一点：当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上&#39;\\0&#39;，让数组中的内容成为一个C字符串。\n实际上，在C语言中scanf()并不是最常用的输入函数。这里重点介绍它是因为它能读取不同类型的数据。C 语言还有其他的输入函数，如 getchar()和 fgets()。这两个函数更适合处理一些特殊情况，如读取单个字符或包含空格的字符串。我们将在第7章、第11章、第13章中讨论这些函数。目前，无论程序中需要读取整数、小数、字符还是字符串，都可以使用scanf()函数。\n格式字符串中的普通字符scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。例如，假设在两个转换说明中添加一个逗号：\n1scanf(\"%d,%d\", &amp;n, &amp;m);scanf()函数将其解释成：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像下面这样进行输入两个整数：\n188,121由于格式字符串中，%d后面紧跟逗号，所以必须在输入88后再输入一个逗号。但是，由于scanf()会跳过整数前面的空白，所以下面两种输入方式都可以：\n188, 121和\n1288,121格式字符串中的空白意味着跳过下一个输入项前面的所有空白。例如，对于下面的语句：\n1scanf(\"%d ,%d\", &amp;n, &amp;m);以下的输入格式都没问题：\n12388,12188 ,12188 , 121请注意，“所有空白”的概念包括没有空格的特殊情况。\n除了%c，其他转换说明都会自动跳过待输入值前面所有的空白。因此，scanf(&quot;%d%d&quot;, &amp;n, &amp;m)与scanf(&quot;%d %d&quot;, &amp;n, &amp;m)的行为相同。对于%c，在格式字符串中添加一个空格字符会有所不同。例如，如果把%c放在格式字符串中的空格前面，scanf()便会跳过空格，从第1个非空白字符开始读取。也就是说，\n🍖scanf(&quot;%c&quot;, &amp;ch)从输入中的第1个字符开始读取，而scanf(&quot; %c&quot;, &amp;ch)则从第1个非空白字符开始读取。\nscanf()的返回值scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0。当scanf()检测到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1）。我们将在第6章中讨论文件结尾的相关内容以及如何利用scanf()的返回值。在读者学会if语句和while语句后，便可使用scanf()的返回值来检测和处理不匹配的输入。\nprintf()和scanf()的*修饰符printf()和scanf()都可以使用*修饰符来修改转换说明的含义。但是，它们的用法不太一样。首先，我们来看printf()的*修饰符。\n如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。也就是说，如果转换说明是%*d，那么参数列表中应包含*和 d对应的值。这个技巧也可用于浮点值指定精度和字段宽度。程序清单4.16演示了相关用法。\n123456789101112131415161718程序清单4.16 varwid.c程序/* varwid.c -- 使用变宽输出字段 */\\#include &lt;stdio.h&gt;int main(void)&#123;    unsigned width, precision;    int number = 256;    double weight = 242.5;    printf(\"Enter a field width:\\n\");    scanf(\"%d\", &amp;width);    printf(\"The number is :%*d:\\n\", width, number);    printf(\"Now enter a width and a precision:\\n\");    scanf(\"%d %d\", &amp;width, &amp;precision);    printf(\"Weight = %*.*f\\n\", width, precision, weight);    printf(\"Done!\\n\");    return 0;&#125;变量width提供字段宽度，number是待打印的数字。因为转换说明中*在d的前面，所以在printf()的参数列表中，width在number的前面。同样，width和precision提供打印weight的格式化信息。下面是一个运行示例：\n1234567Enter a field width:6The number is : 256:Now enter a width and a precision:8 3Weight = 242.500Done!这里，用户首先输入6，因此6是程序使用的字段宽度。类似地，接下来用户输入8和3，说明字段宽度是8，小数点后面显示3位数字。一般而言，程序应根据weight的值来决定这些变量的值。\nscanf()中*的用法与此不同。把*放在%和转换字符之间时，会使得scanf()跳过相应的输出项。程序清单4.17就是一个例子。\n程序清单4.17 skip2.c程序\n1234567891011/* skiptwo.c -- 跳过输入中的前两个整数 */\\#include &lt;stdio.h&gt;int main(void)&#123;    int n;    printf(\"Please enter three integers:\\n\");    scanf(\"%*d %*d %d\", &amp;n);    printf(\"The last integer was %d\\n\", n);    return 0;&#125;程序清单4.17中的scanf()指示：跳过两个整数，把第3个整数拷贝给n。下面是一个运行示例：\n123Please enter three integers:2013 2014 2015The last integer was 2015在程序需要读取文件中特定列的内容时，这项跳过功能很有用。\nprintf()的用法提示想把数据打印成列，指定固定字段宽度很有用。因为默认的字段宽度是待打印数字的宽度，如果同一列中打印的数字位数不同，那么下面的语句：\n1printf(\"%d %d %d\\n\", val1, val2, val3);打印出来的数字可能参差不齐。例如，假设执行3次printf()语句，用户输入不同的变量，其输出可能是这样：\n12312 234 12224 5 2322334 2322 10001使用足够大的固定字段宽度可以让输出整齐美观。例如，若使用下面的语句：\n1printf(\"%9d %9d %9d\\n\", val1, val2, val3);上面的输出将变成：\n123   12　　 　234　　　1222    4　　　 　5　　 　2322334　　  2322　　 10001在两个转换说明中间插入一个空白字符，可以确保即使一个数字溢出了自己的字段，下一个数字也不会紧跟该数字一起输出（这样两个数字看起来像是一个数字）。这是因为格式字符串中的普通字符（包括空格）会被打印出来。\n另一方面，如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便。这样，输出数字的宽度正合适，没有不必要的空白。例如，下面的语句：\n1printf(\"Count Beppo ran %.2f miles in 3 hours.\\n\", distance);其输出如下：\n1Count Beppo ran 10.22 miles in 3 hours.如果把转换说明改为%10.2f，则输出如下：\n1Count Beppo ran　　 10.22 miles in 3 hours.本地化设置\n美国和世界上的许多地区都使用一个点来分隔十进制值的整数部分和小数部分，如3.14159。然而，许多其他地区用逗号来分隔，如 3,14159。读者可能注意到了，printf()和 scanf()都没有提供逗号的转换说明。C语言考虑了这种情况。本书附录B的参考资料V中介绍了C支持的本地化概念，因此C程序可以选择特定的本地化设置。例如，如果指定了荷兰语言环境，printf()和scanf()在显示和读取浮点值时会使用本地惯例（在这种情况下，用逗号代替点分隔浮点值的整数部分和小数部分）。另外，一旦指定了环境，便可在代码的数字中使用逗号：\n1double pi &#x3D; 3,14159; &#x2F;&#x2F; 荷兰本地化设置C标准有两个本地化设置：”C“和” “（空字符串）。默认情况下，程序使用”C”本地化设置，基本上符合美国的用法习惯。而””本地化设置可以替换当前系统中使用的本地语言环境。原则上，这与”C”本地化设置相同。事实上，大部分操作系统（如UNIX、Linux和Windows）都提供本地化设置选项列表，只不过它们提供的列表可能不同。\n关键概念C语言用char类型表示单个字符，用字符串表示字符序列。字符常量是一种字符串形式，即用双引号把字符括起来：”Good luck, my friend”。可以把字符串储存在字符数组（由内存中相邻的字节组成）中。字符串，无论是表示成字符常量还是储存在字符数组中，都以一个叫做空字符的隐藏字符结尾。\n在程序中，最好用#define 定义数值常量，用 const 关键字声明的变量为只读变量。在程序中使用符号常量（明示常量），提高了程序的可读性和可维护性。\nC 语言的标准输入函数（scanf()）和标准输出函数（printf()）都使用一种系统。在该系统中，第1个参数中的转换说明必须与后续参数中的值相匹配。例如，int转换说明%d与一个浮点值匹配会产生奇怪的结果。必须格外小心，确保转换说明的数量和类型与函数的其余参数相匹配。对于scanf()，一定要记得在变量名前加上地址运算符（&amp;）。\n空白字符（制表符、空格和换行符）在 scanf()处理输入时起着至关重要的作用。除了%c 模式（读取下一个字符），scanf()在读取输入时会跳过非空白字符前的所有空白字符，然后一直读取字符，直至遇到空白字符或与正在读取字符不匹配的字符。考虑一下，如果scanf()根据不同的转换说明读取相同的输入行，会发生什么情况。假设有如下输入行：\n1-13.45e12# 0\t//`-`前面有空格如果其对应的转换说明是%d，scanf()会读取3个字符（-13）并停在小数点处，小数点将被留在输入中作为下一次输入的首字符。如果其对应的转换说明是%f，scanf()会读取-13.45e12，并停在#符号处，而#将被留在输入中作为下一次输入的首字符；然后，scanf()把读取的字符序列-13.45e12转换成相应的浮点值，并储存在float类型的目标变量中。如果其对应的转换说明是%s，scanf()会读取-13.45e12#，并停在空格处，空格将被留在输入中作为下一次输入的首字符；然后，scanf()把这 10个字符的字符码储存在目标字符数组中，并在末尾加上一个空字符。如果其对应的转换说明是%c，scanf()只会读取并储存第1个字符，该例中是一个空格 \n本章小结字符串是一系列被视为一个处理单元的字符。在C语言中，字符串是以空字符（ASCII码是0）结尾的一系列字符。可以把字符串储存在字符数组中。数组是一系列同类型的项或元素。下面声明了一个名为name、有30个char类型元素的数组：\n1char name[30];要确保有足够多的元素来储存整个字符串（包括空字符）。\n字符串常量是用双引号括起来的字符序列，如：&quot;This is an example of a string&quot;。\nscanf()函数（声明在string.h头文件中）可用于获得字符串的长度（末尾的空字符不计算在内）。scanf()函数中的转换说明是%s时，可读取一个单词。\nC预处理器为预处理器指令（以#符号开始）查找源代码程序，并在开始编译程序之前处理它们。处理器根据#include指令把另一个文件中的内容添加到该指令所在的位置。#define指令可以创建明示常量（符号常量），即代表常量的符号。limits.h和float.h头文件用#define定义了一组表示整型和浮点型不同属性的符号常量。另外，还可以使用const限定符创建定义后就不能修改的变量。\nprintf()和scanf()函数对输入和输出提供多种支持。两个函数都使用格式字符串，其中包含的转换说明表明待读取或待打印数据项的数量和类型。另外，可以使用转换说明控制输出的外观：字段宽度、小数位和字段内的布局。\n","plink":"https://dxsummer.gitee.io/posts/2a5471de/"},{"title":"英语笔记","date":"2020-04-26T01:22:05.000Z","date_formatted":{"ll":"2020年4月26日","L":"2020/04/26","MM-DD":"04-26"},"updated":"2020-06-08T01:55:31.052Z","content":"及物动词、不及物动词、直接宾语、间接宾语及物动词：后面必须跟宾语意义才完整\n不及物动词：本身意义完整后面不需要跟宾语\n直接宾语：动作的承受者，物\n间接宾语：动作对谁，为谁做\n情态动词+动词原型\n英语中有所谓的助动词。英语中有很多助动词，除了do外，can, may, might, would, will, must也是助动词。例如：\n\n情态动词+动词原型x　You must practiced your English every day.（你必须每天练习英语。）o　You must practice your English every day.\n不及物动词+to+名词若是要表示过去的“习惯性”动作，可用would, used to来表达，例如：He used to go to school by bus.（他过去经常坐公共汽车去上课。）\ngo是不及物动词，后面跟名词则+to不及物动词+to+名词home是副词，所以不用+to\narrive+at/in+名词I often go to school by bike.I go home at 5 o’clock.I arrived in London yesterday.I arrived here just now.\n用be to＋动词原形/be about to＋动词原形 表示将来表示按计划、安排要做的事，具有“必要”的强制性意义。 The meeting is to take place tonight.（今晚召开会议。）\n\n表示约定、责任、命令或注定要发生的动作。Our plan is to be a failure.（我们的计划注定会失败。）  \n\n官方计划或决定（常见于报纸或广播）。The President is to visit USA next week.（总统将于下个星期出访美国。）\n\n用“be about to＋动词原形”表示将来。表示（按计划）即将发生的动作或情况。My grandpa is about to retire.（我祖父就要退休了。）She was about to go out when I arrived.（我来的时候她正准备出门。）\n\n\nHad you ever been to a blind date before you married?（你结婚以前曾经参加相亲吗？）\n\n解析：    在你结婚前，你有过一次相亲    Had you ever been to a blind date before you married，结婚之前你相亲过吗？    have gone to 不能代替这个意思    have been to 表示去过某地，经常和表示次数的次连用    have gone to 表示去了某地，还没有回来\n形容词修饰不定代词时置于其后：当形容词修饰由some-, any-, no-, every-这些字首所构成的不定代词时，形容词要放在这些不定代词之后。例如：\nThere must be something wrong with my computer.（我的电脑出了点问题。）\n形容词的比较级、最高级单音节词在字尾加-er / -est：单音节形容词在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：clean→cleaner→cleanest。\n\n单音节词以–e结尾在字尾加-r / -st：以–e结尾的单音节形容词，转变为比较级和最高级时，规则是在字尾加–r和–st。例如：wide→wider→widest。\n\n双音节词以-y, -er, -ow, -ble结尾在字尾加-er / -est：少数以-y, -er, -ow, -ble结尾的双音节形容词，在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：slow→slower→slowest。\n\n以-y结尾的形容词，去掉字尾-y加-ier / -iest：以–y结尾，但–y前是辅音字母的形容词的比较级和最高级是把-y去掉，加上–ier和-iest。例如：lonely→lonelier→loneliest。\n\n形容词字尾“辅元辅”重复字尾再加–er：当形容词或其字尾出现“辅音＋元音＋辅音”现象，也就是最后三个字母和音标的排列是“辅元辅”，在转变为比较级和最高级时，规则是要重复字尾，再加-er。例如：big→bigger→biggest。\n\n好句好句We should look after the old and love the young.（我们应该尊老爱幼。）\n\nI have a beautiful little new white Chinese wooden table.（我有一张新的白色中式木桌，漂亮且小巧。）\n\n\n两个以上的形容词的顺序,（冠词＋数量＋性质＋大小＋形状＋新旧＋颜色＋国籍）＋名词。可背诵例句2辅助记忆\n\nThere must be something wrong with my computer.（我的电脑出了点问题。）\n","plink":"https://dxsummer.gitee.io/posts/4e70975/"},{"title":"C语言菜鸟笔记","date":"2020-04-23T05:18:11.000Z","date_formatted":{"ll":"2020年4月23日","L":"2020/04/23","MM-DD":"04-23"},"updated":"2020-06-12T02:38:41.813Z","content":"此帖记录C语言学习笔记，整合从最初学习C语言遇到的问题到一步步成长数据C 语言中 main()、void main() 和 int main(void) 有什么区别？main()是K&amp;R C的语法，也就是C89，现在可以使用，但是不推荐。int main(void)是c99的语法。void main()不是任何标准定义的，根据维基百科 C语言 的说法，这个是微软自己定义的。\n\nint main(void)表示返回一个整数值，不接收任何参数。main()按照老的C语言标准，不写返回值的函数默认返回类型为整形。空的括号表示可以接收任意个数任意类型的参数。\n\nvoid main() 的空括号表示可以接收任意个数任意类型的参数。在一般函数里void表示没有返回值。但是这个在main函数里面有点特殊,按照C99标准的5.1.2.2.3节描述，程序依然会返回一个unspecified的值。(实际上这一节的内容也隐喻了main函数可以不是int main(void)的形式)\n\n1void pound(int n)如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。由于该函数接受一个 int 类型的参数，所以圆括号中包含一个int类型变量n的声明。\n\nC 标识符只能由字母.下划线和数字组成 且不能以数字开头。int(常量)是求不大于括号内数字 的最大整数1int(3.5)=3float在计算机中存储类型默认为double精度char为1字符，8位\nshort 2字节 16位\nshort int 2字节 16位 输出格式：%hd\nint为2字符或4字符，16位或32位\nfloat实际为4字符，即32位,C语言，float类型值会被自动转换成double类型,即64位\nlong浮点数要占用4字节，32位\ndouble 八字节，64位\nlong long 八字节，64位\nlong double 十六位，128位\n\n默认情况下，编译器假定浮点型float常量是double类型的精度。例如，假设some是float类型的变量，编写下面的语句：\n1some = 4.0 * 2.0; 通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。\n\n在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类型，如54.3l和4.32L。注意，建议使用L后缀，因为字母l和数字1很容易混淆。没有后缀的浮点型常量是double类型。\n\n123456Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 4 bytes.Type long long has a size of 8 bytes.Type double has a size of 8 bytes.Type long double has a size of 16 bytes.\nfloatfloat类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。\n12345678910/* floaterr.c--演示舍入错误 */#include　&lt;stdio.h&gt;int　main(void)&#123;    float　a,b;    b　=　2.0e20　+　1.0;    a　=　b　-　2.0e20;    printf(\"%f　\\n\",　a);    return　0;&#125;该程序的输出如下\n得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。\n字符串常量用双引号(“”)括起来的0个或者多个字符组成的序列存储：每个字符串尾自动加一个 ‘\\0’ 作为字符串结束标志\n字符串常量是百一对双引号括起来的字符序列。字符常量可以赋值给字符变量，如char b=&#39;a&#39;;,但不能把一个字符串常量赋给一个字符变量，同时也不能对字符串常量赋值。\n优先级\n算数运算符&gt;关系运算符&gt;赋值运算符\n\n关系运算符的优先级比算术运算符低（包括+和-），比赋值运算符高。这意味着x &gt; y + 2和x &gt; (y+ 2)相同，x = y &gt; 2和x = (y &gt; 2)相同。换言之，如果y大于2，则给x赋值1，否则赋值0。y的值不会赋给x。\n关系运算符比赋值运算符的优先级高，因此，x_bigger=x&gt;y;相当于x_bigger=(x &gt; y);。\n关系运算符之间有两种不同的优先级。\n高优先级组： &lt;&lt;= &gt;&gt;=\n低优先级组： == !=\n与其他大多数运算符一样，关系运算符的结合律也是从左往右。因此：\nex!=wye==zee与(ex != wye) == zee相同\n首先，C判断ex与wye是否相等；然后，用得出的值1或0（真或假）再与zee比较。我们并不推荐这样写，但是在这里有必要说明一下。\n表6.2列出了目前我们学过的运算符的性质。附录B的参考资料II“C运算符”中列出了全部运算符的完整优先级表。\n\n格式化输入字符串%s如果使用%s 转换说明，scanf()会读取除空白以外的所有字符。scanf()跳过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符串\n12scanf(\"%s\",s);printf(\"\\n输出%s\",s);123输出abc123 123输出abc123格式输出符%hu hd%hd表示短整数(short int)。\n\n%hu用于输出一个unsigned short int类型的数值百，此类型占两个字节，度范围问为0到65535（2^16-1）\n\n%hhu用于输出一个unsigned short类型答的数值，此类型占一个字节，范围为0到255（2^8-1）\n\n%m.ne、%e%e是按指数的形式输出，比如 4.22e5\ne表示10的N次方，5.2 长度为5，小数点精确度为2，这个本身和复%e没有关系，C语言的输出就是标准就这样。\n%hd：short int 16位\n详细点的说明就是 %m.ne 指定输出的数值共占m位，其中有n位小数制。若数值长度小于m，则左端补空格。若数值长度大于m，则按实际数值输出，小数位保留n位。\n123456#include &lt;stdio.h&gt;main()&#123;\tfloat i=1777777;\tprintf(\"%3.2f\",i); &#125;输出结果：\n11777777.00这是ptintf()的格式。\n\n带格式输出 %#x%#x是带格zd式输出, 效果为在输出前加0x.\n1printf(\"%x %X %#x\\n\", 31, 31, 31); 输出\n11f 1F 0x1f\n输出演示了如何在整型格式中使用精度（%5.3d）生成足够的前导0以满足最小位数的要求（本例是3）。然而，使用0标记会使得编译器用前导0填充满整个字段宽度。最后，如果0标记和精度一起出现，0标记会被忽略。\n1printf(\"**%5d**%5.3d**%05d**%05.3d**\\n\", 6, 6, 6, 6); 输出：  \n1**    6**  006**00006**  006**\n带格式输出 %*s123int a;char b[10];scanf(\"%d%*s\",&amp;a,b);输入为：\n112 abc那么12将会读取到变量a中，但是后面的abc将在读取之后抛弃，不赋予任何变量(例如这里的字符数组b）用*和扫描集配合，可以从输入中只选出需要的内容，而忽略其余的东西。另外，也常用于清空缓冲区。\n1printf(\"%*s\",10,s);意思是输出字符串s，但至少占10个位置，不足的在字符串s左边补空格，这里等同于\n1printf(\"%10s\",s);printf()和scanf()的修饰符 %*d如果转换说明是%*d，那么参数列表中应包含*和 d对应的值\n\n例一 printf()\n\n12scanf(\"%d\", &amp;width);printf(\"The number is :%*d:\\n\", width, number);输出\n126The number is :      256:\n例二 printf()\n\n12scanf(\"%d %d\", &amp;width, &amp;precision);printf(\"Weight = %*.*f\\n\", width, precision, weight);输出\n128 3Weight = 242.500\n例三 scanf()\n\n12scanf(\"%*d %*d %d\", &amp;n);printf(\"The last integer was %d\\n\", n);scanf()指示：跳过两个整数，把第3个整数拷贝给n。下面是一个运行示例：\n122013 2014 2015The last integer was 2015在程序需要读取文件中特定列的内容时，这项跳过功能很有用。\nstrlen()和 sizeof()的区别C语言中没有字符串类型，字符串在内存中是用字符数组表示的。\nstrlen( )：strlen( )求得的是字符串的长度 %u、%lu、%zd\nsizeof( )：sizeof( )计算字符串占的总内存空间 %u、%lu、%zd\n例如字符串  \n1str[20]&#x3D; &#123;“abcdef”&#125;;strlen(str),结果为6\nsizeof(str),结果为20\nx-=y x+=y12x+=y\t/*x=x+y*/x-=y\t/*x=x-y*/scanf（） 的返回值C=scanf() 返回值赋给C\nC表示scanf（）成功收到赋值的个数\n12345678void main()&#123;int a,b,c;    c=scanf(\"%d %d\",&amp;a,&amp;b);    printf(\"%d\",c);&#125;为什么我    输入a 1\tc的值就为0，    输入1 a\tc的值为112345scanf返回接收到的变量值的个数。 int  a,b,c。a 1进去时，试图用字符‘a’对a赋值，肯定是错的，于是退出，返回成功接收到赋值的个数 0.1 a进去时，首先a能获取1.但b不能获取'a',于是返回只是1 如果是  1 1的话，那就都成功，返回2","plink":"https://dxsummer.gitee.io/posts/4f274412/"},{"title":"加油吧！少年——社会还在逼他们继续奋斗","date":"2020-04-22T05:18:50.000Z","date_formatted":{"ll":"2020年4月22日","L":"2020/04/22","MM-DD":"04-22"},"updated":"2020-06-08T01:56:19.516Z","content":"文章引用知乎，视频源于B站\n问题想的有点多，但以目前能力解决不掉。\n观点不代表大多数。\n不喜欢的直接喷！\n以下是从男方的角度写的。\n一:社会风气\n【也不能说是被当下社会风气影响吧】\n举个身边的例子吧。 \n1、男方自身经济实力不足（没钱）\n  我大致粗略算了算，假设我有一个喜欢我，而且我也喜欢的女孩子，两个人三观还都合得来，那么即使他们家的要求，按照我个人感觉的最低……  \n  我需要大概56万的一笔费用。  也就是在老家桐城结个婚的所有花销。  仅仅是结婚而已。  房子30万首付得自己出吧（后续的贷款两人慢慢还。没毛病吧）  车子最低10万吧？难道面包车也可以么？  还有16万，彩礼+三金+婚宴（婚纱照司仪等等）+烟酒等等一系列所谓的看不见的花销……  16万不过分吧？我感觉。  这还是仅仅只是结婚，结完婚一年内要不要孩子呢？  \n2、这是个现实问题哦。    要的话，媳妇一怀孕最低一年半至两年，所有的花销压力基本上男方负担了吧。  媳妇如果有嫁妆垫一垫也可以，可我是按照最坏的打算准备的。    万一媳妇那边不随嫁妆呢？  \n3、小孩子不生病还好，一生病那钱花的……我大哥家的孩子一个月去医院两三次，一个月光在医院就一两千之多。这让人均工资在5.6000的家庭咋整？\n第二：责任问题  \n如果结婚真是那种到点就上班的活儿，那还好了，关键不是呀。  \n只是因为年轻人感觉到了，结婚对于一个男人/女人来说需要承担什么。  一种极重的责任感。牵一发动全身的感觉。双方父母，老婆孩子，大人还好啦，相对于小孩子来说，家庭条件不好的，从一开始他就落后别人一步了。大多数普通人结了婚，娃娃一生，扔给爷爷奶奶带，自己出去打工。对吧。当然啦，这是没办法的事情，陪伴和赚钱只能二选一。我从道德上表示理解，但个人情感上无法理解。这些在我看来，这是一种极其不负责任的表现。孩子在他小时候的大部分性格形成是需要父母的陪伴的，需要父母言传身教的。父母和爷爷奶奶本质上是不同的，再开明的爷爷奶奶，对待小孩子从情感上就不同于父母。另外没有父母陪伴，孩子没有底气，没有自信，当别的小朋友上学放学有爸妈接送，时间长了他会自己感觉和别人不一样。心里种下了种子，等待的就是若干年后的矛盾和恶性后果。我经常会听到有些家长说:那家小孩不是这样过来的，我们小时候都这样过来的，不也活的好好的，就你不行？我想说的是：你愿意赌那万分之一，那是你的事，我不愿意。重要的是我们90后长大了，有一大部分人都有过这样的经历，那个时候我们被称为“留守儿童”。  我们是经历过的，亲身体验到被留守是什么感觉。可家长们看到的大多数”幸存者”都是有一点点运气在里面的，后面死掉的不知道多少。他们喜欢拿特例当典范，好比人家买彩票中一千万，我买怎么就不中？你看看别人家如何如何，你怎么就不行？或许也因为年轻人怕自己给不了孩子想要的生活，所以宁愿单着。从某方面来说，也可以算是一种逃避和懦弱。万一……我像我父母那样怎么办？我的孩子要重复我的一生么？明知问题在哪儿，可就是无法解决。人们叫嚣着让他们去努力，拼搏，积极向上……一堆堆的大道理扑面而来。可年轻人现在接触的信息比以往更加的激烈和冲突。他们深知这个世界没道理可言。某些人说的都是建立在道德上的道理，现实中，只能精神慰藉。就像我们都知道的“拾金不昧”“见义勇为”这种道德体系的东西，在我看来，这是社会结构的“大纲，骨架”。但流通的血液是权利和金钱。可现如今……人心却不是以前的心了。\n三：认识自己穷，怕给不了她幸福大多数男生认识到自己穷了，这是真的，当今的社会，太过于物质化。谁不希望能有一个童话般的爱情故事？现实就是，柴米油盐酱醋茶会不断的用同一个招式把你从左边捶到右边。再从右边捶到左边。没有物质滋养的爱情，没有光泽，没有保鲜期，古话说的好：贫贱夫妻百事哀。我知道贫贱夫妻百事哀的原译文不是这个意思，但现在来形容另一种也不为过。没有这个赚钱的能力，结了婚说白了:害人害己。害了父母，害了媳妇，害了孩子，害了自己。我希望的是男方可以在结婚前就有一定经济基础，或者工作稳定，有可观的稳定的收入来源，有一笔相对来说能够应付两到三年的花销存款，这是对家人也是对另一半和孩子的一种保障吧。为什么这么说？时代不一样了，过去父母那辈儿结婚，物质条件的需求是啥？冰箱，收音机，摩托车。可以说人人通过努力都能达到，它的可得性要比现在大的多的多。现在呢？我有时回想起父辈们常说的一句:努力奋斗，肯吃苦，就可以把日子过好。现在想想……不以为然。难道那些父辈们的吃苦耐劳，流血流汗还是算不上努力么？或者说他们的努力还不够？那为什么他们努力一辈子，却还要两代人合力都买不起一套房子了？还要绑定下一代二三十年的时间和收入，才能勉强有个“家”？那这样努力，不就是个笑话呢？我不是说努力无用，努力是有用的，可你的努力追不上社会经济发展。这不是笑话，这是活生生的现实。网络上有一句话:你不努力下，你都不知道什么是绝望。年前看上一套房，拼死拼活干一年，攒个十几万去交首付，结果房价涨了。只够买半个房子了。\n【笑哭】社会高速发展所带来的弊端，高房价，高物价，时时刻刻都在冲击着年轻人的三观和对社会美好的期待。\n混迹这么久 我一直在踏步 没有进步，还是会陷入最后的死结 如我所愿 我不是解决 我只是在逃避，最后还是想告诉你 如果当下很难 不要压抑自己 找一个信赖的人 哭一哭诉说一下真的很解压 然后在打起精神面对 多去做一些事情充实自己 看书 或者学一中乐器 给自己找点爱好 因为我们的生活里不能只有责任和义务  活的通透一些自私一些真的很好。\n不管如何，现在年轻人的压力是很大的，无论哪个城市都一样。买房、买车要花钱，结婚要花钱，照顾父母要花钱，抚养小孩要花钱……到处都要钱，然而现在的环境，物价房价飞涨的厉害，以现在大多数年轻人的收入，怎么能实现房车以及稳定情感的目标？很难。\n说句实在话，倘若没有父母的帮扶，绝大多数的人是不可能买车买房的，光靠自己个人打拼，起码得打拼十多年，才能够实现自己的生活愿景。但是又有多少人能够忍得住十多年的时间，等到自己35岁以后再去实现这些事？\n在合适的年纪，做不了符合内心想做的事，这是现代年轻人觉得焦虑、感觉压力大的根本原因。\n现在是越年轻越轻松不了，只有奋斗，才能创造自己想要的生活。但是，当这种生活通过奋斗都还实现不了呢？就只能丧了。\n如果重来一次，你还会读计算机专业吗？\n","plink":"https://dxsummer.gitee.io/posts/ca5d3c1d/"},{"title":"PS简单的抠图方法","date":"2020-04-20T10:45:49.000Z","date_formatted":{"ll":"2020年4月20日","L":"2020/04/20","MM-DD":"04-20"},"updated":"2020-06-08T01:56:26.970Z","content":"魔棒与快速选项工具首先把需要抠图的素材拖入PS里，然后对背景图层执行CTRL+J复制。（提示：无论你要做什么，都要先解锁背景图层在对背景图层执行CTRL+J复制）\n\n点击左侧工具栏的魔棒工具，在副本里需要删除的地方，单击鼠标左键，之后会出现蚂蚁线按Delele清除（快速选项工具同理）  \n\n\n最终效果图与对比图\n（提示：用魔棒工具抠图还留有白边，这是我们要用橡皮擦细心的擦去白边，为了看起来不生硬，按住CTRL+鼠标左键单击图层生成选区，然后在选区里右键→羽化【1-2值】→Delele清除）\n通道抠图法首先把需要抠图的素材拖入PS里，然后对背景图层执行CTRL+J复制。（提示：无论你要做什么，都要先解锁背景图层在对背景图层执行CTRL+J复制）\n\n点击来到通道面板下，观察一下那个通道的明暗反差大一些，在抠图的时候，要在反差较大的那个通道来进行操作。通道比较发现，绿色和红色通道都还可以，不过绿色要更好一些，这里我们就选择绿色来进行通道抠图了。\n\n右键复制绿色通道\n\n选中绿色通道，按CTRL+L色阶处理，这能使图片反差更明显\n\n然后用画笔工具把需要清除的地方涂黑（提示：如看不清边缘，请点击RGB图层进行选区，然后再换回绿色通道，用油漆桶涂黑）\n\n之后，用画笔工具，把颜色调成白色，然后我们就可以大胆的把需要保留的地方涂成白色\n\n复制后，还有发现有一些边缘和头发没弄好，如图所示\n\n是不是还发现有一处头发没弄好呢，别急，我们先复制一层原图+蒙版，PNG图层也是。擦完之后要 向下合拼图层 抠图工具及方法\n\n是不是觉得好有点生硬呢，不怕，我们按住CTRL+鼠标左键，点击PNG图层，建立选区。然后在选区里右键羽化【1-2值】，反向选择，Delele清除。如果还觉得生硬就再次羽化。（提示：PNG图层就是指你抠出来的图像）\n\n钢笔与套索工具先用钢笔或套索工具，抠出不要的地方，如果看到有瑕疵的地方就用橡皮擦慢慢调整好。\n","plink":"https://dxsummer.gitee.io/posts/164adefb/"},{"title":"Step 1　先搞懂概念与时态","date":"2020-04-20T02:16:27.000Z","date_formatted":{"ll":"2020年4月20日","L":"2020/04/20","MM-DD":"04-20"},"updated":"2020-06-10T04:42:56.523Z","content":"Day01什么是英语语法？\n\n什么是英语语法？\n\n英语语法，指英语中语言的结构规律，主要包括“单词、短语、句型和语法”四个要素。以下就根据这四个要素做细节说明：\n单词英语单词依据在句子中的作用，可分为八大词类，分别为名词、代词、形容词、动词、副词、介词、连词和感叹词。以下为详细说明：\n名词：表示人、地、事、物等的词。名词分为可数名词和不可数名词，可数名词前要加冠词a / an，不可数名词前要加定冠词the，例如：a book, an apple, the air。\n\n代名：表示代替名词或名词短语的形式用词。代名词可以分为：\n\n形容词：用来修饰名词或代词的词。形容词可分为：\n\n动词：是用以表示动作或状态的词，例如：be, go, get, have, run, send等。另外，动词在使用上，要特别注意时态和语态的变化。\n\n副词：可用来修饰动词、形容词和其他副词，也可以用来修饰短语。副词分为：\n\n介词：通常放在名词和代词之前，用来表示名词或代词和其前面词的关系。介词从形式上来分有四种：\n\n连词：用来连接单词、短语、从句和句子的词。连词分为：\n\n感叹词：用以表示强烈的情绪和感情的一种声音或叫喊。例如：Hello! Hurrah! Hi! Oh！等等。\n\n短语短语是由两个或两个以上的英语单词所组合的词语，不包含主语和动词，可以构成句子的一部分，也可以用来当名词、形容词和副词使用。短语主要分为以下五大种类：\n句型句子是按照一定的语法规律组成的，表达一个完整的意义。一个句子一般由两部分构成，即主语部分和动词部分，这两部分也是句子中最主要的成分。而句子的次要成分包括宾语，形容词，副词，主语补语等。首先介绍一下，在一般语法说明中容易使用到的英语缩写：\n及物动词：后面必须跟宾语意义才完整\n\n不及物动词：本身意义完整后面不需要跟宾语\n\n直接宾语：动作的承受者，物\n\n间接宾语：动作对谁，为谁做\n\n\n以下为英语五大基本句型：\n\n句型01：S＋V（主语＋不及物动词）\n\n句型02：S＋V＋SC（主语＋系动词＋表语）此结构中的动词常为系动词，例如：look, seem, appear, prove, become, turn, sound, taste, keep, stay… 等。\n\n句型03：S＋V＋O（主语＋及物动词＋宾语）\n\n句型04：S＋V＋O1＋O2（主语＋双宾动词＋间接宾语＋直接宾语）间接宾语通常会是“人”，直接宾语通常会是“物品”。\n\n句型05：S＋V＋O＋OC（主语＋使役动词＋宾语＋宾语补语）\n\n语法英语语法有一定的规则，它是客观存在的，而不是语言学家规定的。语言学家只是对其进行归纳、整理，并选择恰当的方式把它们描述出来。学习英语语法得注意如下基本规则：\n规则01：两个动词是不能连在一起的。x　I like play piano.（我喜欢弹钢琴。）o　I like to play piano.\n\n规则02：如果一定要同时用两个动词，第二个动词的前面必须加“to”，或是加上“-ing”。例如：x　I like swim.（我喜欢游泳。）o　I like to swim. / I like swimming.\n\n规则03：主语如果是第三人称单数，现在时中的动词必须加“s”，例如：x　She sing very well.（她歌唱得很好。）o　She sings very well.\n\n规则04：绝大多数的否定句，不能直接加not，必须加上助动词或使役动词。例如：x　I not want to go.（我不想离开。）o　I don’t want to go.\n\n规则05：在不定式“to”的后面，必须用动词原形，例如：x　She wants to becomes a good teacher.（她想要变成一位好老师。）o　She wants to become a good teacher.\n\n规则06：英语中有所谓的助动词。英语中有很多助动词，除了do外，can, may, might, would, will, must也是助动词。例如：情态动词+动词原型x　You must practiced your English every day.（你必须每天练习英语。）o　You must practice your English every day.\n\n规则07：大部分的英语问句都要包含助动词，例如：Do you like playing basketball?（你喜欢打篮球吗？）How many books do you have?（你有多少本书？）\n\n规则08：特殊动词随主语变化，另外，英语中有些动词因主语不同而有所变形，例如be动词。I am a good student.（我是一位好学生。）She has a big heart.（她有宽大的胸襟。）They have been to Paris.（他们去过巴黎。）\n\n一般现在时vs．一般过去时\n一般现在时表示经常性、习惯性的动作、行为或者现在的某种状况；一般过去时表示过去某一时间内发生的动作或存在的状态，常与表示过去的时间副词连用，例如：yesterday, last night / week, a month ago, in 1990’s等。\n现在时使用时机与现在时动词连用，依照使用时机分为：\n现在时刻发生的动作或状态。It’s five o’clock now.（现在五点钟了。）\n\n经常性或习惯性的动作，常与always, usually, often, sometimes等频率副词连用。We have three meals every day.（我们每天吃三顿饭。）\n\n主语具备的性格、能力和本质特征等。He likes playing soccer.（他喜欢踢足球。）  \n喜欢某事物，以前就喜欢，还可能持续 like doing  \n表示想要，欲做某事 like to do\n\n客观事实、普遍真理、名言、警句或谚语等。The earth goes around the sun.（地球绕着太阳转。）\n\n按规定、时刻表、计划或安排要发生的动作。通常会用一般现在时表示将来的状态。常用的动词有：begin, start, stop, arrive, come, go, leave, return, open, close, be等。例如：School begins the day after tomorrow.（学校后天开学。）\n\n在由when, before, after, until, as soon as等连接的时间副词从句和if引导的条件副词从句，以一般现在时表示将来的动作。Remember to turn off the light before you leave.（离开之前记得关上电灯。）\n\n在由here、there引导的倒装句中，表示此刻正在发生的动作。There goes the bell.（铃响了。）\n\n过去时使用时机表示过去特定时间发生的动作或状态。My dad won the music award last year.（我爸去年赢得了一项音乐奖。）\n\n表示过去经常或反复发生的动作。She often came to help me when I was in trouble.（我遇到麻烦的时候她总是来帮助我。）  \n\n另外，若是要表示过去的“习惯性”动作，可用would, used to来表达，例如：He used to go to school by bus.（他过去经常坐公共汽车去上课。）\n\ngo是不及物动词，后面跟名词则+to  不及物动词+to+名词  home是副词，所以不用+to\n\narrive+at/in+名词  I often go to school by bike.\n  I go home at 5 o’clock.\n  I arrived in London yesterday.\n  I arrived here just now.\n\n延伸用法，事半功倍！\nLearning Plus!\n\n一般现在时vs．一般过去时的“相同点”两者均可表示人的性格、特征、爱好以及习惯，常与频率副词often, sometimes, seldom, usually, always, once a week等连用。  \nI often play basketball.（我常常打篮球。）  \nI often played basketball when I was at school.（我以前在学校的时候常常打篮球。）\n\n一般现在时vs．一般过去时的“不同点”  \n\n一般现在时表示现阶段发生的动作或状态，以及永恒不变的事实、自然规律，常与时间副词today, every day, every morning, on Sunday等连用。  \n- I ride bike to school every day.（我每天都骑自行车上学。）  \n- Springs return in March.（春天会在三月到来。）\n\n一般过去时表示过去阶段发生的动作或状态，常与时间副词yesterday, last year, last night, the day before yesterday, this morning, two days ago等连用。\n- I lost my mobile phone yesterday.（我昨天弄丟了我的手机。）  \n- She met her ex-boyfriend on the street the day before yesterday.\n  （她前天在路上遇到了她的前男友。）\n\n语法观念例句示范Shelly is my best friend since 10 years ago. 雪莉从10年前开始就是我最好的朋友。\n\nI get up at seven every day. 我每天都七点钟起床。\n\nShe speaks English very well. 她英语说得很好。\n\nWe lived in Thailand ten years ago. 我们十年前住在泰国。\n\nIt was very hot yesterday. 昨天天气很热。\n\nWhen I was a child, I often read comic books. 我小的时候经常看漫画书。\n\nDid you have a good time last night? 你昨天晚上玩得开心吗？\n\nShe stayed in Paris for almost a month. 她在巴黎待了将近一个月。\n\nWendy comes from Canada and speaks good French. 温蒂来自加拿大，而且说得一口好法语。\n\nMandy doesn’t know how to read the map.曼蒂不会看地图。\n\n语法观念辨析练习\n请填入正确时态的动词。\n\n01．I often________(go) to school by bus.\n02．He________(play) basketball every day.\n03．I________(be) hungry now.\n04．They________(go) to the ZOO yesterday.\n05．Mr. Smith________(come) to Hong Kong last Sunday.\n06．His mother________(watch) TV for 8 hours last night.\n07．There________(be) a shop not long ago.\n08．I________(need) a glass of water.\n09．She________(be) a student two years ago.\n10．The river________(run) to the ocean.\n\n正确答案及题目译文：\n\n\n将来时\n将来时表示将来某个时间要发生的动作或存在的状态，也表示将来经常或者重复发生的动作，常与表示将来的时间副词连用，例如：tomorrow, soon, next week, this afternoon…。We will graduate next year.　我们明年毕业。\n将来时的句型构成陈述句：S＋will / shall＋V原形第一人称I, we用shall或will，其余人称都用will。I will call you this afternoon.（我下午会打电话给你。）He believes that he will win the Best Sales of the Year.（他深信他会赢得年度最佳业务员奖。）\n\n否定句：S＋will / shall＋not＋V原形Because John failed his final exam, so his parents will not let him join the band.（约翰的父母不会让他参加乐团，因为他的期末考试考得太差了。）\n\n疑问句：Will / Shall＋S＋V原形？Shall we dance?（我们来跳舞吧？）\n\n\nOf    1. （属于）···的 The wood of this desk is cracked.    2. 某某市 The city of London.    3. 数量 a kind of、a piece of、a bottle of    4. 部分/全部 all of us、most of all    5. 时间  of the year 本年度的 、of year每年的、for the year本年度\n\n将来时使用时机表示将来某个时间点要发生的事She will go to visit the British Museum tomorrow.（她明天会去参观大英博物馆。）\n\n表示不以人意志为转移的自然发展的事。Jack will be 20 next year.（杰克明年将满20岁。）\n\n在疑问句中用来征询听话人意图或愿望。Will you go shopping with me?（你要和我一起逛街吗？）\n\n表示说话时马上要做的事，也就是临时决定要做的动作。A：Tom is in hospital now. He is serious ill.（汤姆现在在医院。他病得很严重。）B：Oh, I’m sorry to hear that, I will go and see him.（太不幸了，我马上就去探望他。）\n\n延伸用法，事半功倍！用“be going to＋动词原形”表示将来  \n表示打算或计划在最近或将来要做的事。  My friend and I are going to travel together this summer.  （我和我朋友打算今年夏天一起去旅游。）\n表示根据某种迹象，在最近或将来将要发生的事情。  Dark clouds are gathering. It is going to rain.（乌云在聚集，看来要下雨了。）\n\n用“be to＋动词原形”表示将来  \n表示按计划、安排要做的事，具有“必要”的强制性意义。  The meeting is to take place tonight.（今晚召开会议。）\n表示约定、责任、命令或注定要发生的动作。  Our plan is to be a failure.（我们的计划注定会失败。）\n官方计划或决定（常见于报纸或广播）。  The President is to visit USA next week.（总统将于下个星期出访美国。）\n用”be about to＋动词原形”表示将来。表示（按计划）即将发生的动作或情况。  My grandpa is about to retire.（我祖父就要退休了。）  She was about to go out when I arrived.（我来的时候她正准备出门。）\n\n用“一般现在时”表示将来 表示一个按照规定、计划、安排或时刻表而即将要发生的情况。通常句中都会包含一个表示将来的时间副词。 The train leaves at three this afternoon.（火车将在下午3点出发。） The film begins in ten minutes.（电影十分钟后开始放映。）  \n\nTIPS! 时间副词、条件副词从句中，从句一般用现在时表示将来，而主句则用将来时。 I will go shopping when I am free. （我空闲的時候就去逛街。）\n\n\n用“现在进行时”表示将来 表示即将发生的将来，多与表示移动的动词come, go, arrive, leave, start, take off等连用。 The doctor is coming to check you in 5 minutes. （医生5分钟之内就会为你做检查。） The train is leaving.（火车离开了。）\n\n用“There will＋be”表示将来 There will be＋名词＋其他补语，但无论后面的是单数名词还是复数名词，be动词必须用原形。 There will be a conference call at 3 p.m. tomorrow.（明天下午3点有个电话会议。）\n\n祈使句＋将来时 句型：祈使句＋and / or＋将来时＋（will） Work hard or you will fail.（努力工作否则你就会失败。） Work hard and you will succeed.（努力工作你就会成功。）\n\n语法观念例句示范My sister will go to Paris on vacation. 我姐姐要去巴黎度假。\n\nI’ll be a good teacher as long as I can pass this test. 只要我能通过这个测验，我就能成为一名优秀的教师。\n\nHe is going to work next week. 下星期他要去工作。\n\nI am going to have a picnic with my co-workers in a few weeks. 几星期后我要和我的同事们一起野餐。\n\nWill you leave for Hong Kong tomorrow? 你明天要去香港吗？\n\nHe is to come to see me at four this afternoon. 他今天下午4点会来见我。\n\nI will meet you at 10 a.m. in the airport tomorrow, Ok? 我们明天早上10点在机场见面，好吗？\n\nShe was about to leave when the phone rang. 她正准备出门的时候，电话响了。\n\nWe are about to finish this project. Don’t give up now. 我们快要完成这个项目了，千万不要现在放弃！\n\nIf it rains tomorrow, the picnic will postpone to next weekend.如果明天下雨，野餐就延期到下个周末举行。\n\n语法观念辨析练习01．He will write to his father as soon as he________Italy.A arrivedB arrivesC is arrivingD will arrive  \n02．My father________fifty years old next year.A is going to beB shall beC is to beD will be  \n03．He said, “Look at these black clouds.____.”A It is to rainB It’ll be rainingC It’s going to rainD It’ll rain  \n04．I hope that you________a good time this evening.A haveB are havingC will haveD has  \n05．There________a basketball match this afternoon.A will haveB will beC hasD have  \n06．We________to the park if the weather is nice tomorrow.A will goB goC goesD to go  \n07．Don’t be late, Lily.The test________at 10 a.m.A is startingB has startedC would startD starts\n08．I don’t know if it________or not tomorrow.A will snowB snowsC has snowedD is snowing\n09．She has bought some cloth. She________herself a dress.A makesB is going to makeC would makeD has made\n10．There________a birthday party for Kevin this Sunday.A shall beB will beC shall going to beD will going to be\n\n正确答案及题目译文：\n\n\nDay02现在进行时vs．过去进行时vs．将来进行时进行时的句型构成\n现在进行时陈述句型：S＋be（is / am /are）＋现在分词（V-ing）I am playing piano with my brother now.（我和我哥哥正在一起弹钢琴。）\n\n否定句型：S＋be（is / am /are）＋not＋现在分词（V-ing）Tony is totally not listening.（汤尼根本就没在听。）\n\n疑问句型：be（is / am /are）＋S＋现在分词（V-ing）?Are you reading now?（你在读书吗？）\n\n过去进行时一般句型：S＋be（was / were）＋现在分词（V-ing）She was trying on a piece of new clothes when her phone rang.（电话响时候她正在试穿一件新衣服。）\n\na piece of 既可以加可数名词，也可以加不可数名词\n\n\n否定句型：S＋be（was / were）＋not＋现在分词（V-ing）I was not speeding!（我当时并没有超速！）\n\n疑问句型：be（was / were）＋S＋现在分词（V-ing）?Were you talking to Tom on the phone at 8 p.m. last night?（你昨晚八点是否在跟汤姆打电话？）\n\n将来进行时一般句型：S＋will be＋现在分词（V-ing）If I continue to go out with you, my mother will soon be very pissing off.（如果我继续跟你出去，我妈妈很快就会非常生气。）\n\n否定句型：S＋will be＋not＋现在分词（V-ing）I hope it won’t still be raining when I have to go to work.（我希望我要上班的时候不要还在下雨。）\n\nwon’t = will not\n\n\n一般句型：Will＋S＋be＋现在分词（V-ing）?Will you be using your notebook tomorrow morning?（你明天早上还会用你的笔记本电脑吗？）\n\n进行时的使用时机\n现在进行时表示现阶段正在进行的动作。常与\n now right now：现在；马上；立刻 at the moment=right now：此刻；现在；目前 for a moment： “一会儿”表示时间的延续，一个段时间。 in a moment = very soon “很快，立即，马上，不久”,一般用于将来时的句子 at present：现在；当今；眼下 for the time being：暂且；眼下；now暂且，就现在来说\n 等时间副词连用，例如： I am looking for someone to talk with now.（我现在想找个人来说说话。）\n\n表示一个在最近按计划要进行的动作。常与一个表示将来的时间副词连用，这种情况仅限于少量动词，如go, come, leave, start, arrive, work, have, stay, play, return等。I am coming to pick you up.（我马上就来接你。）\n\n表示反复发生或持续存在的状态。常与always, constantly, forever等词连用，往往带有说话人的主观色彩，多含抱怨意味。You are always changing your mind with no reason.（你老是毫无理由地改变主意。）\n\n表示强调逐渐变化或改变的过程。常与get, grow, change, become, turn, go, run, begin等动词搭配。My parents are getting old.（我的父母越来越老了。）\n\n过去进行时表示过去的某个时刻或时间正在进行的动作。常与表示过去的时间副词then, at that time, this time yesterday, at six yesterday等连用。 I was reading a novel this morning.（上午我在看小说。）\n\n表示某种强烈感情。常与always, constantly, forever等副词连用。 She was always complaining.（她老是抱怨。）\n\n表示过去某个事件发生时，另一个正在进行的动作。此时，延续性动作用过去进行时，瞬间动作用一般过去时。 I met Ann when I was shopping this morning.（我早上逛街时遇到了安。）\n\nTIPS!\n\n 如果表示的是两个延续性的动作，都用过去进行时。 Some students were playing football,while others were running around the track. （一些学生在踢足球，另一些学生在跑步。）\n\n过去进行时可以表达委婉语气，例如：I was wondering if you can give me a lift.（不知我可否顺便搭你的车。）\n\n表示过去某个时间认为“将来”要发生的事。When his son arrived, the old man is dying.（当他的儿子抵达的时候，这位老人已经奄奄一息。）\n\n将来进行时表示在将来某个时间正在进行的动作。At this time tomorrow, I will be sleeping at home.（明天这个时候我将会在家睡觉。）\n\n表示按计划或安排，将来要发生的动作。We will be spending our summer vacation in Hawaii.（我们将在夏威夷过暑假。）\n\n表示不含意图又未发生的动作。Lucy won’t pay this bill.（露西不肯付这笔钱。）→表意愿Lucy won’t be paying this bill.（不会要求露西来付钱的。）→单纯谈将来情况\n\n表示委婉语气。Will you be having a cup of coffee?（要来杯咖啡吗？）\n\n延伸用法，事半功倍！表示状态或感觉的动词，如果指现在的情况的话，一般不用进行时，而要用一般现在时，这样的动词有：love, like, hate, want, hope, need, wish, know, understand, remember, belong, hear, see, seem, have, sound, taste等，但如果它们的词义改变，也可以用进行时态。\nShe looks pale. What’s wrong with her?（她看起来很苍白。她怎么了吗？）→look此为系动词，意为“看起来，显得”。\nShe is looking for her books.（她在找她的书。）→look在此为实义动词，意为“寻找”。\n语法观念例句示范I was reading the newspaper when the doorbell rang.我正在看报，突然门铃响了。\n\nI’ll be taking holidays soon.不久后我将在度假了。\n\nIt’s raining outside now.现在外面在下雨。\n\nWe are having a meeting now.我们现在正在开会。\n\nI was doing my homework while she is listening music.我在做作业的时候，她正在听音乐。\n\nThis time next week I will be lying on the beach.下个星期的这个时候我就会躺在沙滩上了。\n\nWhen I got to the top of the mountain, the sun was rising.当我到达山顶的时候，太阳正在升起。\n\nThe train is leaving soon.火车马上要开了。\n\nShe will be coming home soon.她不久后就会回家了。\n\nThe leaves are turning yellow.树叶变黄了。\n\n语法观念辨析练习用所给动词的正确形式填空。\n01．I________(clean) my room now.\n02．Jessie________(do) her homework when I called her last night.\n03．What________you________(do) now? I________(sing).\n04．My father________(read) newspaper at ten yesterday.\n05．It________(rain) when I went out yesterday.\n06．David________(play) chess with his grandfather now.\n07．He________(mend) a car now.\n08．This time next day they________(sit) in the cinema.\n09．I________(have) a meeting at 3 o’clock tomorrow afternoon.\n10．What do you think you________(do) at this time next year?\n正确答案及题目译文：\n现在完成时vs．过去完成时vs．将来完成时完成时的句型构成\n现在完成时陈述句型：S＋has / have＋过去分词（p.p.）I have already finished my homework.（我已经完成了我的作业。）\n\n否定句型：S＋has / have＋not＋过去分词（p.p.）Sandy has been a nurse in this hospital for 15 years.（珊蒂已经在这间医院担任护士长达15年了。）\n\n疑问句型：Has / Have＋S＋过去分词（p.p.）?Have you ever seen Peter in past 3 months?（过去3个月内，你看见过彼得吗？）\n\n过去完成时陈述句型：S＋had＋过去分词（p.p.）This proposal had been delivered by Eva before Aaron finished it.（这个计划在艾伦完成以前，伊娃就已经提交出去了。）\n\n否定句型：S＋had＋not＋过去分词（p.p.）I had not finished my work when he visited me last week.（上周他来拜访我以前，我还没有完成工作。）\n\n疑问句型：Had＋S＋过去分词（p.p.）?Had you ever been to a blind date before you married?（你结婚以前曾经参加相亲吗？）\n\n将来完成时陈述句型：S＋shall / will＋have＋过去分词（p.p.）They will have finished the meeting by now.（他们现在应该已经开完会了。）\n\n否定句型：S＋shall / will＋have＋not＋过去分词（p.p.）We will have not made 10 apple pies by the end of today.（我们在今天结束之前不能做完10个苹果派。）\n\n疑问句型：Shall / Will＋S＋have＋过去分词（p.p.）?Will they have already left by the time we get there?（我们到的时候，他们会不会已经离开了？）\n\n完成时的使用时机\n现在完成时表示过去发生的动作对现在所造成的影响。常与just, already, yet, recently, before, twice, three times等时间副词连用，例如：Luckily, I have seen the questions before.（很幸运，我之前就已经看过这些问题。）\n\n表示从过去某一时刻开始一直延续到现在的动作或状态，常与“since＋时间点”、“for＋时间段”，及how long, (ever) since, ever, before, so far, in the last / past few years, up to now, till now等时间副词连用。例如：She has been a PE teacher for five years.（她已经当了五年的体育老师了。）\n\n表示从过去某个时间直到现在的这个时间范围内，不断重复发生的动作或情况，并且这个不断重复的动作可能继续下去，也可能到现在就结束。He has always gone to school by bus.（他总是坐公共汽车上学。）\n\n有时可用于时间或条件副词从句中代替一般现在时，表将来意义。例如：You can have a rest if you have finished your work.（如果你完成了工作就可以休息一下。）\n\n过去完成时表示在过去某一时刻或某一动作之前已经完成了的动作，即“过去的过去”。例如：The train had left before she got to the station.（在她抵达车站之前，火车已经开走了。）\n\n表示从过去某一时刻开始一直延续到另一过去时刻的动作或状态。常与how long, for three days, before等表示一段时间的状语连用。例如：By twelve o’clock, I had worked ten hours.到12点钟时我已经工作了10个小时。\n\n表示未曾实现的希望或打算，即“本来希望或打算做某事（但却没有做）”。常与wish, hope, want, expect, think, suppose, plan, mean, intend, desire等动词连用，例如：I had meant to take a good holiday this year, but I wasn’t able to get away from this job.（本来打算今年好好度假的，但我还是没办法从工作中脱身。）\n\n将来完成时表示在将来某一时刻或某一时刻之前已经完成的动作，往往对将来某一时间产生影响，常与表示将来的时间副词及条件或时间副词从句连用。例如：They will have arrived by now.（她们现在应该已经到了。）If you come at six o’clock, I shall not yet have finished dinner.（你若六点钟可以到，我应该还没吃完晚饭。）When we get there, he will have gone to work.（我们到那里时，他应该已经去上班了。）\n\n 将来时只有have\n\n\n表示一种推测，主语要用第二、第三人称。例如：You will have finished your homework by now.（这时候你应该已经完成了你的作业。）She will have watched this film already.（她恐怕已经看过这场电影了。）\n\n延伸用法，事半功倍！主句与从句中完成时的运用：\n 如果主句中的谓语动词为一般现在时，从句中谓语动词就用现在完成时； 如果主句中谓语动词是一般过去时，从句谓语动词用过去完成时。例如：\n\n\n过去完成时常用于以下固定句型：\n (a) hardly, scarcely, barely＋过去完成时＋when＋一般过去时 Hardly had I got on the bus when it started to move. （公共汽车开车前，我差一点就赶不上了。）\n (b) no sooner＋过去完成时＋than＋一般过去时 No sooner had I got in the office than the manager started to yell at me. （我一到办公室，经理就开始对我吼叫。）\n (c) by (the end of)＋过去时间副词→主语的谓语动词用过去完成时 The experiment had been finished by 4 o’clock yesterday afternoon. （这个实验在昨天下午四点结束。）\n\n语法观念例句示范01．I have just received a letter from my mother.我正好收到一封来自我妈妈的信。\n02．As soon as the sun had set we returned to our hotel.太阳一下山我们就回到了旅馆。\n03．I had not understood the problem until she explained it.直到她给我解释我才明白问题出在哪。\n04．They have seen the film several times.这部电影她们已经看了好几次。\n05．I have lived here for ten years.我已经在这里住了十年了。\n06．Next Monday, I shall have been in this company for a year.到下周一，我到这家公司就满一年了。\n07．He will have gone back to Paris.他想必已经回巴黎去了。\n08．I had meant to go to your party, but something happened.我本打算去你的派对，但突然发生了一点事。\n语法观念辨析练习请选出题目中最适合的选项。\n01．No sooner________than the accident happened.A he had goneB had he goneC his goingD he went.\n02．We have been friends since________.A five yearB five yearsC five years agoD five years before\n03．You________that question three times.A already askedB have already askedC already have askedD asked already\n04．All the machines________by the end of the following week.A were repairedB will be repairedC have been repairedD will have been repaired  \n05．His grandfather________for thirty years.A diedB was deadC has been deadD has died\n06．”Are Alice and Tom still living in London?””No, they________to New York.”A are just movedB have just movedC had just movedD will just move\n07．I lost the dictionary I________.A have boughtB boughtC had boughtD had been bought\n08．I________800 English words by the time I was ten.A learnedB was learningC had learnedD learnt\n正确答案及题目译文：\n完成进行时（现在vs．过去vs．将来）完成时的句型构成\n现在完成进行时基本句型：S＋has / have＋been＋V-ingThe Smith Family has been making sports car for 200 years.（史密斯家族有200年制作跑车的历史。）\n\n否定句型：S＋has / have＋been＋not＋V-ingI have been not dancing for three months.（我已经三个月不跳舞了。）\n\n疑问句型：Has / Have＋S＋been＋V-ing ?Has Enzo been learing English since three years ago?（恩佐从三年前就开始学英语了吗？）\n\n过去完成进行时基本句型：S＋had been＋V-ingEli had been playing games before you got home.（伊莱在你回家之前一直都在玩游戏。）\n\n否定句型：S＋had been＋not＋V-ingAmy had been not working for ten years before I met her.（艾米在我遇到她的十年前就没在工作了。）\n\n疑问句型：Had＋S＋been＋V-ing ?Had your father been driving all day before he went to sleep?（你爸爸在睡觉之前开了一整天的车吗？）\n\n将来完成进行时基本句型：S＋will / shall＋have been＋V-ingWhen Mrs. Wang retires next year, she will have been teaching for 40 years.（当王太太下个月退休时，她就已经教书教了四十年。）\n\n否定句型：S＋will / shall＋not＋have been＋V-ingI won’t have been waiting for you since you keep talking to me like this.（如果你继续这样对我说话，我就不会一直等着你的。）\n\n疑问句型：Will / Shall＋S＋have been＋V-ing ?When Leo goes out tonight, it will have been raining.（当里奥今天晚上出门的时候，外头应该正下着雨。）\n\n完成时的使用时机？\n完成进行时是完成时的强调形式，分为现在完成进行时、过去完成进行时及将来完成进行时。\n现在完成进行时表示从过去某个时候开始一直延续到现在的动作，强调现在仍然在进行，并还可能继续延续下去；\n过去完成进行时表示从过去某一时间开始一直延续到另外一个过去时间的动作，这个动作在当时仍在进行并可能继续延续下去；\n未来完成进行时表示在未来某一时间以前已经完成，或一直持续的动作。\n现在完成进行时表示从过去某个时候开始一直延续到现在的动作。强调现在依然在进行，并还可能继续延续下去。例如： I have been looking for my lost book for two days, but I still haven’t found it. （我已经找我弄丢的书找了两天了，但我仍然没有找到。）\n\n表示根据直接或间接的证据得出的结论。Her eyes are red. She has been crying.（她眼睛红了。她一直在哭。）\n\n过去完成进行时表示从过去某一时间开始一直延续到另外一个过去时间的动作，这个动作在当时仍在进行并可能继续延续下去，例如：We had been waiting for her before she came in.（在她进来之前，我们一直在等她。）\n未来完成进行时表示在将来某一时刻之前开始的一个动作或状态一直延续到将来某一时刻，常与一个以by开头的时间短语连用。例如：By the end of this month, she will have been learning piano for half a year.（到这个月底，她就学钢琴半年了。）\n\n表示一种经常性反复进行的持续性动作。例如：By the end of this month, he will have been climbing mountains for ten years.（到了这个月底他的登山资历就满10年了。）\n\n语法观念例句示范01．We have been living here since 2000.从2000年起我们就住在这里了。\n02．He was out of breath. He had been running.他气喘吁吁。他一直在跑着。\n03．I heard you had been looking for me.我听说你一直在找我。\n04．I have been looking forward to meeting you.我一直盼望着见到你。\n05．Without doubt you have been working very hard.毫无疑问，你工作一向非常努力。\n06．By the end of this year, she will have been teaching for five years.到今年年底，她就当了五年老师了。\n07．On December we will have living here for two years.到12月1日，我们住在这儿就满两年了。\n08．She had been suffering from a bad cold when she took the exam.她在考试之前一直患重感冒。\n09．By the time you arrive tomorrow, she will have been typing for hours.到明天你抵达的时候，她将已经打了数小时的字。\n10．He had been mentioning your name to me.他总是向我提起你的名字。\n语法观念辨析练习请填入正确时态的动词。\n01．We________(wait) for her for two hours.\n02．They________(build) the bridge for six months.\n03．He________(study) abroad for one year.\n04．By the end of this month, I________(work) here for three months.\n05．He________(prepare) his exam till one o’clock this morning.\n06．Up to直到 that time he________(translate) those books.\n07．I wanted to know what________(go) on.\n08．She________(have) treatment治疗 all her life.\n09．By this time next year, we________(do) business with each other for 20 years.\n10．He gave up smoking last year. He________(smoke) for thirty years.\n正确答案及题目译文：\n","plink":"https://dxsummer.gitee.io/posts/8206f3bb/"},{"title":"原子弹制造从入门到精通","date":"2020-04-19T12:27:46.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:56:10.642Z","content":"原子弹制造从入门到精通\n在家闲来无事，于是与圈内大佬谈论了一下原子弹的原理，文章写作参考于谷歌、百度、必应和各位大佬，此文章仅供参考。\n\n准备工作 :我们大约需要３０磅的铀２３５，体积差不多有一个棒球的大小，再配合一些很容易到手的材料，这种炸弹就能使１／３哩以内任何东西化为乌有；２／３哩以内的东西严重受损；在１.２５哩半径内的人都会受到致命的辐射线；辐射尘随风飘扬，能使４０哩内的人都致病。如果它在纽约市引爆，大概有２５万人会死亡，还有４０万人会受伤。这种效果恐怖份子应该会很满意；这种原子弹甚至在战场上也都能派上用场。\n不过，要提醒各位：铀２３５的分量不要超过４５磅，因为对这样多的铀，其引爆的技巧相当困难，单凭业余的机槭工匠，大概是无法适时且有效地把这些东西凑在一起。挺有可能你还没做一半，它就在你面前 BOOM了，那可就真浪费感情。\n\n我个人的偏好是用３６磅或３７磅的铀２３５，因为这样效果不差，而且，如果设计上出点小差错，也不致于有太严重的后果。一旦把足够的材料紧聚在一起，我们最棘手的技术就是得使它们能紧聚在一起维持约半秒钟，这半秒钟的延迟就是技术上最主要的问题。\n\n原因是这样的：当这两堆物质靠太近时，会发生剧烈的反应而产生大量的能量，在瞬间（比一秒钟小很多）迫使这两堆物质分开。这样的结果和爆竹的效果差不多，几百尺外的人根本不知道有这回事。\n\n对一个稍有「自尊」的恐怖份子而言，是不会以此为满足的，对吗？所以，当务之急就是要设计出一套办法，使两堆铀２３５能聚得久一点，好让一些比较惊人的「大事」发生。如果你这位恐怖份子有栋两层楼房（含地下室）、两根火药、１５包水泥、２０立方码的沙石，那么大约只要一个礼拜就可以完工了。全部的费用，除去房租不算，大概只要３，０００美元就够了。根据当前汇率，折合成人民币大概就是 25000元。最后的问题是怎样把铀２３５或钸弄到手，这留待后面再谈。\n\n开始动工：准备妥当后，第一件事就是把分批弄来的铀２３５分成二等分，用一对半球容器装起来，你或可用乙炔喷灯（AcetyleneTorch）来作。\n铀的熔点是４１４。２℃，而乙炔喷灯的燃点是５２６。４℃，因此理论土来说，乙炔喷灯足以熔化铀２３５。也许你应该花几十块耐火砖作个窑，加上一个风箱，效果会此较好；不过如果你有耐心再加上一些运气（因为铀这东西燃烧会 BOOM），乙炔喷灯应该是够用的了。铀熔成液体后，流到半球状的洼槽（制陶瓷用的耐火泥就可派上用场），则第一个半球型作好冷却了，再移开作第二个。\n\n有件事要注意：这时候，在这区域附近不能有人。因为，铀有对人不利的特性。如果铀熔化时你就在现场，那么，你总会吸进一点，嘿嘿…，其结果不是说你会少活几年，而是你只剩下几个钟头好活了！如果你这个恐怖份子确能置个人生死于度外，那当然就不必计较这些了，否则我建议你采用自动控制装置。\n\n当铀熔化时，和它相隔５０尺，再用５吨铅隔离，这样应该足够安全了。将铀２３５分成两堆的工作完成后，你就应分别用铅箱装好。再从二楼挖个洞通到地下室，用一对黑铁管接起来，使总长约２０尺左右。若能用６寸厚的水泥敷于管外可能稍好，不过如果地板够坚实，而且房子是建在岩石上，也可以不必这么麻烦。在放下管子之前，先把装铀的半球形容器的平面朝上放在水泥上，再把管子放置妥当，原子弹就已完工一半了。\n\n为了不使铀散逸，地下室应该用沙、石、水泥和水混合填好，但因为这只要用一次就达到目的了，做得好不好看也无所谓啦。真正要注意的是，管子外面有足够的阻挡力量，使原子弹在 BOOM前铀不致漏出。其实只要半液体状的沙泥混合物，就足以担当大任了。如此这般，原子弹的接收部分就完工了。\n\n引爆部分比较难做，构想之一是将另一个半球容器放在管子的上端，引爆时，让它倒向下面的接收部分就可以了。原理上虽很简单，但有些技术上的困难不易解决，比如说，如果引爆用的半球容器放歪了一点，它就会沿着管子滑下来，这样你想成为恐怖份子的美梦就落空了，因为这种死法不会让人觉得恐怖，只会成为茶余饭后的笑料罢了。\n\n目前可能是最简单而有效的设计，把一个细线织成的罩子（就像夏天防苍蝇的那种），放在管子的上端，再塞进管内，留约３～４寸在外面；这时再把另一段４尺长的管子焊在原来的管子上。若要使连接的部分更牢，可以在此部分钻几个洞，把铁钉插进去。然后拿３尺长的２。５寸铜管，里面装熔化的铅，将引爆的半球容器安在铅底座中一个吻合的凹槽里；另一根铁棍则凿入管子的另一端约一尺，这装置总重量是８０～９５磅。最后，把有螺纹的盖子套在管子上头，等到它能旋得松紧自如时，再将它拿下来，在它上面钻一个洞，使能容得下引爆的装置杆；装置杆则留下６～８寸长露出洞口，杆上并恰留钻一个钉孔。将各种大小不同的钉子试着去配合，最恰当的大小是能合于整个引爆装置（当然，试着配合时暂不在接受管上端作，以免危险）。然后，将 TNT或炸药涂在一个碟子上（最好是咖啡壶中过滤器的底座），再塞进去，并插进一两个雷管。这放在引爆装置杆的四周，再由一两条引线连出来到外面，然后把它旋紧，原子弹就大功告成了。\n\n剩下的工作只是把引线接到定时器上，再把下端的安全针拔掉，然后离开这城市，约１２小时后，这城市就离开这个世界了。定时器一旦引爆，其力量足使另一个安全针脱落，引爆装置就掉到接收部分去，即使不考虑 BOOM产生的加速度，光是重力就足使９５磅的物体由２０尺高空掉下，产生８Ｘ１０的十次方耳格／秒的动能。把 BOOM所生的冲力考虑进去，则接触点有１０的十二次方耳格／秒的动能，可使两个半球容器接触的时间够长，而产生令人满意的效果。\n\n防辐设备：为了要将所有重要的步骤交代清楚，应该再将几个小问题说明一下。例如，前文曾经简略地谈到，用乙炔喷灯时要考虑铀有发火燃烧的可能性。其实，应该说整个机械操作都要在「乳状液槽」中进行。对不太熟悉机械技术操作的人而言，所谓乳状液就是一种看来像牛乳一样的液体，和油有许多相似之处，可是不会发火燃烧。这种乳状液在一般机械工厂供货商处都很容易买到，而且不会有入问你买这种东西干什么？用了这种乳状液，可以使危险降到最低程度。\n事实上，若我们要溶解铀或对铀作机械处理，最好在纯氮的大气中才安全。可是如果你够小心，而且运气又好的话，那么也不必用这种极端安全的方法。辐射的问题是比较麻烦的一点，镭的辐射量和重量成正比，但铀的辐射量和重量却是成指数关系（也是这种性质使它具有 BOOM性）。因为每个半球所装的质量都超过了临界值的一半，所以和它们同在一间房子里非常地危险。只吸进去一点点含放射性尘埃的空气，就意味着你马上要离开这个世界。因此我建议所有的工作人员应有其它的氧气供应，每人口中含个氧气管或可解决这个问题。但要通盘解决辐射的问题可能比较麻烦，不过只要有决心，加上智能和运气，这问题还是可以克服的。\n\n我还要建议采用一种用铅作成外壳而且有动力的轮椅，让操作员坐在里面可以安全地作业。上面只要开个小缝，用铅作的玻璃当窗户，操作员就可以看到外面。铅作的袖子和手套，可以用来作一些需要和铀碰触的机械动作。为了防止辐射外逸，整栋房子的墙壁、地板都需覆盖上一层铅；地下室的天花板也要加上一层铅板，以免接收部分产生辐射的问题。算起来起码要用上６～８吨的铅，以维持基本的安全问题。这么一来，又得多花工夫支撑地板，免得垮下来。\n\n这些工作都作好了，就可以开始动手制造原子弹。如果你想作一道「红烧兔子」大餐，打开食谱第一步就是要抓一只兔子来！同理，现在你也会问：「怎样把铀２３５弄到手？」（铀２３５通常此钸容易拿到。）其实，你只要平时注意看报纸，应该不难知道，核能发电厂里就有。只要由电厂里偷根控制棒出来，把它熔了，再把其中没有用的铀２３８分离出来就成了。\n\n要潜入一个核子反应炉，说起来并不是什么太难的事，尤其大学校园中的核子反应炉，都只有些马马虎虎的安全设施。一般设施就是些带刺铁丝网围墙，门口站了一两个警卫。事前可以作出误闯的样子来几次投石问路，看看有没有什么电子安全装置，大概结果都是根本没有的。可是我们偷偷摸摸的潜进去并没有什么用，因为铀非常的重，不要讲是一个人，就算是一队人马开进去，也搬不到足够的分量出来。尤其这批人马又身装铅甲以防辐射，就更不管用了。\n\n依我之见，干脆偷辆卡车和拖车（要那种特重型的，就是运三峡电站转子的那种），干掉警卫，代以自己人，然后就直闯进去拿你要的东西，很干脆，效率又高。不过，反应器都是装在一个镍－铁合金的球状容器里，容器再浸在水中，通常，旁边会有千斤顶，以便修护时用，所以也可以顺便用来把整个反应炉心起出来放到卡车里。不过要注意一件事，搬动反应器时要拔出一些燃料棒，或是插进一些节制棒，否则你和整个反应器都要化为灰烬。\n\n建议你或可向当时被你挟制的人质请教这方面的技术，以便搬动炉心。此外，整个反应器重约５０吨，加上拖车需要６寸厚的铅板作防护，所以拖车如何拖动６５吨的重量，还是颇伤脑筋的（所以前面要用特重型的拖车，要不然到了地，炉子也搬上车了，却发现拖不动，那不是面子都丢尽了）。或者，你觉得搬走整个反应器不切实际，也可以只带走约１，２００磅的备用燃料棒。\n\n不过千万也要带着石墨或铅，免得燃料棒因不断地反应生热而熔化了。如果你忘了这步骤，回家打开盖子，只会看到一堆熔化了的铀，而且四处散射，可能你当场就一命呜呼而遗笑万年。性命是小，这脸咱可丢不起，所以别忘记拿了１，２００磅的燃料棒之后，要和１５，０００磅的石墨或铅混合。反应器的铀大约含３％的铀２３５（自然界铀则只含０．５％的铀２３５），做原子弹的铀则需要９７％的铀２３５，否则根本不 BOOM。到手的１，２００磅燃料棒，可以提炼出所需要约 36磅的铀２３５，不过要有耐心和经验去分离它。如果你自知无法全部把铀２３５分离出来，就得多弄点燃料棒。\n\n一般说来，以目前的技术，要达到每次增加纯度２５％并没有什么问题，所以你最少要弄到４，８００磅的燃料棒，若能弄到９，６００磅最好。把这些加上去，你总共要带１５万磅（７５吨）的东西。\n\n其次还要找个地方放这些东西，我建议你租间仓库，如用原来那两层楼的建筑来分离铀似乎不太实际，因为这至少需要２万平方尺的空间。\n\n分离高招：下面就要考虑用什么方法来分离铀２３５。对恐怖份子来说，气体扩散法是好方法之一，这也是早期制造原子弹时所采用的，不但可靠又不必太复杂的技术。不过花费较多，而且所用的化学药品更是吓人。\n首先，你要有约１２哩长的特殊玻璃线钢管，并以６０吨的氢氟酸（ＨＦ）形成六氟化铀，然后吹向一具有特殊小孔的膜。因为六氟化铀２３８较重，在经过这层膜时会被陷住而不易透过。每过一次可使铀２３５的成分增加０。５％，如此程序只要反复操作，所得六氟化铀２３５的成分就愈大，最后只要把六氟化铀中的氟分离出来就行了。因为氢氟酸很贵，而且不易取得所以最好是去偷一点来，要不然就先去偷个几百万美金也行。\n\n如果你觉得此路不通，还有其它的办法。你可以在树林里建个滋生反应器（BreederReactor），用铀来作钸，再用化学上的技术分离即可。至于如何建滋生反应器，也不是难事，随便一本大学教科书，都可以告诉你好几种方法。虽然在理论上没有困难，但是也有它实际上的难处。不过如果你刚好有私人用的小河，又有几火车的钠，数量可观的不锈钢管，一百亩与外界隔离的土地，那就没有间题。\n\n如果对这两种方法你都没有兴趣，还有一些有趣的新技术可供参考。你可以先用一块低温磁铁（CryogenicMagnet），它在液态氦的温度（约零下２７０℃）下能保持 20,000高斯的磁扬…不过，唔，不过下面的程序太复杂了… \n\n还有一法是用雷射，因为铀２３８较重，被激光束照射后，运动的偏离角比铀２３５小。所以若在和雷射光垂直的平面上洒上一层铀，则铀２３５、铀２３８可藉其偏离角来分离。此法原理上简单可行，但时间上太慢。一天大概只能处理 20磅的铀（含２３５和２３８），而分离的效率约１２。５％，每处理一次可以产生约１０％的铀２３５，所以要处理９次才能达到原子弹的标准。\n\n如此算来，从９，６００磅磅的燃料棒中分离出３６磅纯度９７％的铀２３５，约需费时四年、。然而，它的辐射量又使你根本没有四年好活，所以还得找三两个志愿者来完成你的未竟之志。因此，若能有愚公移山之志，或可成功，祝你好运 ! \n\n\n","plink":"https://dxsummer.gitee.io/posts/a1b9e5e4/"},{"title":"Page and Post Front-matter","date":"2020-04-19T08:45:59.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:50:57.862Z","content":"Page Front-matter123456789title:date:type: comments: description:top_img:mathjax:katex:aside:\n写法解释\n\ntitle【必需】页面标题\n\ndate【必需】页面创建时间\n\ntype【必需】标签、分类和友情链接三个頁面需要配置\n\ndescription【可选】页面描述\n\ncomments【可选】显示页面评论模块（默认 true)\n\ntop_img【可选】页面顶部图片\n\nmathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)\n\nkatex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)\n\naside【可选】显示侧边栏 （默认 true)\nPost Front-matter1234567891011121314title:date:tags:categories:keywords:description:top_img:comments：cover:  toc:  toc_number: copyright: mathjax:katex:\n写法解释\n\ntitle【必需】文章标题\n\ndate【必需】文章创建日期\n\ntags【可选】文章标签\n\ncategories【可选】文章分类\n\nkeywords【可选】文章关键字\n\ndescription【可选】文章描述\n\ntop_img【可选】文章顶部图片\n\ncover【可选】文章缩略图（如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空）\n\ncomments【可选】显示文章评论模块（默认 true)\n\ntoc【可选】显示文章TOC（默认为设置中toc的enable配置）\n\ntoc_number【可选】显示toc_number（默认为设置中toc的number配置）\n\ncopyright【可选】显示文章版权模块（默认 true)\n\nmathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)\n\nkatex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)\n","plink":"https://dxsummer.gitee.io/posts/67dd97ac/"},{"title":"字体、颜色常用代码","date":"2020-04-19T05:17:09.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:50:26.486Z","content":"字体、颜色常用代码常用字体名称中文字体：黑体：SimHei\n宋体：SimSun\n新宋体：NSimSun\n仿宋：FangSong\n楷体：KaiTi\n仿宋_GB2312：FangSong_GB2312\n楷体_GB2312：KaiTi_GB2312\n微软雅黑：Microsoft YaHei\n英文字体：PmingLiu\nImpact\nGeorgia\nTahoma\n- Arial\nBook Antiqua\nCentury Gothic\nCourier New\nTimes New Roman\nVerdana\n其他字体：仿宋：FangSong\n华文细黑：STHeiti Light [STXihei]\n华文黑体：STHeiti\n华文楷体：STKaiti\n华文宋体：STSong\n华文仿宋：STFangsong\n隶书：LiSu\n幼圆：YouYuan\n华文细黑：STXihei\n华文楷体：STKaiti\n华文宋体：STSong\n华文中宋：STZhongsong\n华文仿宋：STFangsong\n方正舒体：FZShuTi\n方正姚体：FZYaoti\n华文彩云：STCaiyun\n华文琥珀：STHupo\n华文隶书：STLiti\n华文行楷：STXingkai\n华文新魏：STXinwei\n常用颜色代码color=maroon\ncolor=grey\ncolor=silver\ncolor=lightgrey\ncolor=HotPink\ncolor=DeepPink\ncolor=VioletRed\ncolor=Purple\ncolor=navy\ncolor=Blue\ncolor=DeepSkyBlue\ncolor=LightSkyBlue\ncolor=aqua\ncolor=DarkTurquoise\ncolor=LightSeaGreen\ncolor=YellowGreen\ncolor=LawnGreen\ncolor=GreenYellow\ncolor=Yellow\ncolor=Tomato\ncolor=red\ncolor=fuchsia\ncolor=MediumOrchid\ncolor=DarkViolet\n颜色表\n颜色名十六进制颜色值颜色\n\nAliceBlue#F0F8FFrgb(240, 248, 255)\n\nAntiqueWhite#FAEBD7rgb(250, 235, 215)\n\nAqua#00FFFFrgb(0, 255, 255)\n\nAquamarine#7FFFD4rgb(127, 255, 212)\n\nAzure#F0FFFFrgb(240, 255, 255)\n\nBeige#F5F5DCrgb(245, 245, 220)\n\nBisque#FFE4C4rgb(255, 228, 196)\n\nBlack#000000rgb(0, 0, 0)\n\nBlanchedAlmond#FFEBCDrgb(255, 235, 205)\n\nBlue#0000FFrgb(0, 0, 255)\n\nBlueViolet#8A2BE2rgb(138, 43, 226)\n\nBrown#A52A2Argb(165, 42, 42)\n\nBurlyWood#DEB887rgb(222, 184, 135)\n\nCadetBlue#5F9EA0rgb(95, 158, 160)\n\nChartreuse#7FFF00rgb(127, 255, 0)\n\nChocolate#D2691Ergb(210, 105, 30)\n\nCoral#FF7F50rgb(255, 127, 80)\n\nCornflowerBlue#6495EDrgb(100, 149, 237)\n\nCornsilk#FFF8DCrgb(255, 248, 220)\n\nCrimson#DC143Crgb(220, 20, 60)\n\nCyan#00FFFFrgb(0, 255, 255)\n\nDarkBlue#00008Brgb(0, 0, 139)\n\nDarkCyan#008B8Brgb(0, 139, 139)\n\nDarkGoldenRod#B8860Brgb(184, 134, 11)\n\nDarkGray#A9A9A9rgb(169, 169, 169)\n\nDarkGreen#006400rgb(0, 100, 0)\n\nDarkKhaki#BDB76Brgb(189, 183, 107)\n\nDarkMagenta#8B008Brgb(139, 0, 139)\n\nDarkOliveGreen#556B2Frgb(85, 107, 47)\n\nDarkorange#FF8C00rgb(255, 140, 0)\n\nDarkOrchid#9932CCrgb(153, 50, 204)\n\nDarkRed#8B0000rgb(139, 0, 0)\n\nDarkSalmon#E9967Argb(233, 150, 122)\n\nDarkSeaGreen#8FBC8Frgb(143, 188, 143)\n\nDarkSlateBlue#483D8Brgb(72, 61, 139)\n\nDarkSlateGray#2F4F4Frgb(47, 79, 79)\n\nDarkTurquoise#00CED1rgb(0, 206, 209)\n\nDarkViolet#9400D3rgb(148, 0, 211)\n\nDeepPink#FF1493rgb(255, 20, 147)\n\nDeepSkyBlue#00BFFFrgb(0, 191, 255)\n\nDimGray#696969rgb(105, 105, 105)\n\nDodgerBlue#1E90FFrgb(30, 144, 255)\n\nFeldspar#D19275rgb(209, 146, 117)\n\nFireBrick#B22222rgb(178, 34, 34)\n\nFloralWhite#FFFAF0rgb(255, 250, 240)\n\nForestGreen#228B22rgb(34, 139, 34)\n\nFuchsia#FF00FFrgb(255, 0, 255)\n\nGainsboro#DCDCDCrgb(220, 220, 220)\n\nGhostWhite#F8F8FFrgb(248, 248, 255)\n\nGold#FFD700rgb(255, 215, 0)\n\nGoldenRod#DAA520rgb(218, 165, 32)\n\nGray#808080rgb(128, 128, 128)\n\nGreen#008000rgb(0, 128, 0)\n\nGreenYellow#ADFF2Frgb(173, 255, 47)\n\nHoneyDew#F0FFF0rgb(240, 255, 240)\n\nHotPink#FF69B4rgb(255, 105, 180)\n\nIndianRed#CD5C5Crgb(205, 92, 92)\n\nIndigo#4B0082rgb(75, 0, 130)\n\nIvory#FFFFF0rgb(255, 255, 240)\n\nKhaki#F0E68Crgb(240, 230, 140)\n\nLavender#E6E6FArgb(230, 230, 250)\n\nLavenderBlush#FFF0F5rgb(255, 240, 245)\n\nLawnGreen#7CFC00rgb(124, 252, 0)\n\nLemonChiffon#FFFACDrgb(255, 250, 205)\n\nLightBlue#ADD8E6rgb(173, 216, 230)\n\nLightCoral#F08080rgb(240, 128, 128)\n\nLightCyan#E0FFFFrgb(224, 255, 255)\n\nLightGoldenRodYellow#FAFAD2rgb(250, 250, 210)\n\nLightGrey#D3D3D3rgb(211, 211, 211)\n\nLightGreen#90EE90rgb(144, 238, 144)\n\nLightPink#FFB6C1rgb(255, 182, 193)\n\nLightSalmon#FFA07Argb(255, 160, 122)\n\nLightSeaGreen#20B2AArgb(32, 178, 170)\n\nLightSkyBlue#87CEFArgb(135, 206, 250)\n\nLightSlateBlue#8470FFrgb(132, 112, 255)\n\nLightSlateGray#778899rgb(119, 136, 153)\n\nLightSteelBlue#B0C4DErgb(176, 196, 222)\n\nLightYellow#FFFFE0rgb(255, 255, 224)\n\nLime#00FF00rgb(0, 255, 0)\n\nLimeGreen#32CD32rgb(50, 205, 50)\n\nLinen#FAF0E6rgb(250, 240, 230)\n\nMagenta#FF00FFrgb(255, 0, 255)\n\nMaroon#800000rgb(128, 0, 0)\n\nMediumAquaMarine#66CDAArgb(102, 205, 170)\n\nMediumBlue#0000CDrgb(0, 0, 205)\n\nMediumOrchid#BA55D3rgb(186, 85, 211)\n\nMediumPurple#9370D8rgb(147, 112, 216)\n\nMediumSeaGreen#3CB371rgb(60, 179, 113)\n\nMediumSlateBlue#7B68EErgb(123, 104, 238)\n\nMediumSpringGreen#00FA9Argb(0, 250, 154)\n\nMediumTurquoise#48D1CCrgb(72, 209, 204)\n\nMediumVioletRed#C71585rgb(199, 21, 133)\n\nMidnightBlue#191970rgb(25, 25, 112)\n\nMintCream#F5FFFArgb(245, 255, 250)\n\nMistyRose#FFE4E1rgb(255, 228, 225)\n\nMoccasin#FFE4B5rgb(255, 228, 181)\n\nNavajoWhite#FFDEADrgb(255, 222, 173)\n\nNavy#000080rgb(0, 0, 128)\n\nOldLace#FDF5E6rgb(253, 245, 230)\n\nOlive#808000rgb(128, 128, 0)\n\nOliveDrab#6B8E23rgb(107, 142, 35)\n\nOrange#FFA500rgb(255, 165, 0)\n\nOrangeRed#FF4500rgb(255, 69, 0)\n\nOrchid#DA70D6rgb(218, 112, 214)\n\nPaleGoldenRod#EEE8AArgb(238, 232, 170)\n\nPaleGreen#98FB98rgb(152, 251, 152)\n\nPaleTurquoise#AFEEEErgb(175, 238, 238)\n\nPaleVioletRed#D87093rgb(216, 112, 147)\n\nPapayaWhip#FFEFD5rgb(255, 239, 213)\n\nPeachPuff#FFDAB9rgb(255, 218, 185)\n\nPeru#CD853Frgb(205, 133, 63)\n\nPink#FFC0CBrgb(255, 192, 203)\n\nPlum#DDA0DDrgb(221, 160, 221)\n\nPowderBlue#B0E0E6rgb(176, 224, 230)\n\nPurple#800080rgb(128, 0, 128)\n\nRed#FF0000rgb(255, 0, 0)\n\nRosyBrown#BC8F8Frgb(188, 143, 143)\n\nRoyalBlue#4169E1rgb(65, 105, 225)\n\nSaddleBrown#8B4513rgb(139, 69, 19)\n\nSalmon#FA8072rgb(250, 128, 114)\n\nSandyBrown#F4A460rgb(244, 164, 96)\n\nSeaGreen#2E8B57rgb(46, 139, 87)\n\nSeaShell#FFF5EErgb(255, 245, 238)\n\nSienna#A0522Drgb(160, 82, 45)\n\nSilver#C0C0C0rgb(192, 192, 192)\n\nSkyBlue#87CEEBrgb(135, 206, 235)\n\nSlateBlue#6A5ACDrgb(106, 90, 205)\n\nSlateGray#708090rgb(112, 128, 144)\n\nSnow#FFFAFArgb(255, 250, 250)\n\nSpringGreen#00FF7Frgb(0, 255, 127)\n\nSteelBlue#4682B4rgb(70, 130, 180)\n\nTan#D2B48Crgb(210, 180, 140)\n\nTeal#008080rgb(0, 128, 128)\n\nThistle#D8BFD8rgb(216, 191, 216)\n\nTomato#FF6347rgb(255, 99, 71)\n\nTurquoise#40E0D0rgb(64, 224, 208)\n\nViolet#EE82EErgb(238, 130, 238)\n\nVioletRed#D02090rgb(208, 32, 144)\n\nWheat#F5DEB3rgb(245, 222, 179)\n\nWhite#FFFFFFrgb(255, 255, 255)\n\nWhiteSmoke#F5F5F5rgb(245, 245, 245)\n\nYellow#FFFF00rgb(255, 255, 0)\n\nYellowGreen#9ACD32rgb(154, 205, 50)\n颜色块配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245&#x2F;&#x2F; 颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FFD700;&#125;&#x2F;&#x2F; 颜色块-绿span#inline-green &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #5cb85c;&#125;&#x2F;&#x2F; 颜色块-蓝span#inline-blue &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #2780e3;&#125;&#x2F;&#x2F; 颜色块-灰span#inline-grey &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #4F4F4F;&#125;&#x2F;&#x2F; 颜色块-红span#inline-red &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FF3030;&#125;&#x2F;&#x2F; 颜色块-紫span#inline-purple &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #9954bb;&#125;&#x2F;&#x2F; 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;&#x2F;&#x2F; 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;&#x2F;&#x2F; 左侧边框绿色块级p#div-border-left-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #5cb85c;&#125;&#x2F;&#x2F; 左侧边框灰色块级p#div-border-left-grey &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #4F4F4F;&#125;&#x2F;&#x2F; 左侧边框蓝色块级p#div-border-left-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #2780e3;&#125;&#x2F;&#x2F; 左侧边框紫色块级p#div-border-left-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #9954bb;&#125;&#x2F;&#x2F; 右侧边框红色块级p#div-border-right-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #df3e3e;&#125;&#x2F;&#x2F; 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;&#x2F;&#x2F; 右侧边框绿色块级p#div-border-right-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #5cb85c;&#125;&#x2F;&#x2F; 右侧边框蓝色块级p#div-border-right-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #2780e3;&#125;&#x2F;&#x2F; 右侧边框紫色块级p#div-border-right-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #9954bb;&#125;&#x2F;&#x2F; 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;&#x2F;&#x2F; 上侧边框黄色p#div-border-top-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #f0ad4e;&#125;&#x2F;&#x2F; 上侧边框绿色p#div-border-top-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #5cb85c;&#125;&#x2F;&#x2F; 上侧边框蓝色p#div-border-top-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#125;&#x2F;&#x2F; 上侧边框紫色p#div-border-top-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#125;","plink":"https://dxsummer.gitee.io/posts/964fa96f/"},{"title":"Step1 数据和C","date":"2020-04-18T10:35:51.000Z","date_formatted":{"ll":"2020年4月18日","L":"2020/04/18","MM-DD":"04-18"},"updated":"2020-06-08T01:45:04.177Z","content":"此经验基于C Primer Plus\n\n一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。\n\n本章介绍以下内容：关键字：int 、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary运算符：sizeof()函数：scanf()整数类型和浮点数类型的区别如何书写整型和浮点型常数，如何声明这些类型的变量如何使用printf()和scanf()函数读写不同类型的值\nC 语言提供两大系列的多种数据类型。本章详细介绍两大数据类型：整数类型和浮点数类型，除此之外，还将介绍常量和变量的区别。\n示例程序12345678910111213141516#include　&lt;stdio.h&gt;int　main(void)&#123;float weight;　 &#x2F;* 你的体重　　　　　　　*&#x2F;float value;　　&#x2F;* 相等重量的白金价值　　　*&#x2F;printf(&quot;Are　you　worth　your　weight　in　platinum?\\n&quot;);printf(&quot;Let&#39;s　check　it　out.\\n&quot;);printf(&quot;Please　enter　your　weight　in　pounds:　&quot;);   &#x2F;* 获取用户的输入*&#x2F;scanf(&quot;%f&quot;,　&amp;weight);  &#x2F;* 假设白金的价格是每盎司$1700　　　　　*&#x2F;                        &#x2F;* 14.5833用于把英镑常衡盎司转换为金衡盎司[1]*&#x2F;value &#x3D; 1700.0 * weight * 14.5833;printf(&quot;Your　weight　in　platinum　is　worth　$%.2f.\\n&quot;,　value);printf(&quot;You　are　easily　worth　that!　If　platinum　prices　drop,\\n&quot;);printf(&quot;eat　more　to　maintain　your　value.\\n&quot;);return　0;&#125;提示 错误与警告如果输入程序时打错（如，漏了一个分号），编译器会报告语法错误消息。然而，即使输入正确无误，编译器也可能给出一些警告，如“警告：从double类型转换成float类型可能会丢失数据”。错误消息表明程序中有错，不能进行编译。而警告则表明，尽管编写的代码有效，但可能不是程序员想要的。警告并不终止编译。特殊的警告与C如何处理1700.0这样的值有关。\n输入该程序时，可以把1700.0改成贵金属白金当前的市价，但是不要改动14.5833，该数是1英镑的金衡盎司数（金衡盎司用于衡量贵金属，而英镑常衡盎司用于衡量人的体重）。\n注意，“enter your weight”的意思是输入你的体重，然后按下Enter或Return键（不要键入体重后就一直等着）。按下Enter键是告知计算机，你已完成输入数据。该程序需要你输入一个数字（如，155），而不是单词（如，too much）。如果输入字母而不是数字，会导致程序出问题。这个问题要用if语句来解决，因此请先输入数字。下面是程序的输出示例：\n123456Are　you　worth　your　weight　in　platinum?Let&#39;s　check　it　out.Please　enter　your　weight　in　pounds:　156Your　weight　in　platinum　is　worth　$3867491.25.You　are　easily　worth　that!　If　platinum　prices　drop,eat　more　to　maintain　your　value.程序调整即使在程序中添加下面一行代码：\n1getchar();程序的输出是否依旧在屏幕上一闪而过？本例，需要调用两次getchar()函数：\n12getchar();getchar();\ngetchar()函数读取下一个输入字符，因此程序会等待用户输入。在这种情况下，键入 156 并按下Enter（或Return）键（发送一个换行符），然后scanf()读取键入的数字，第1个getchar()读取换行符，第2个getchar()让程序暂停，等待输入。\n\n程序中的新元素注意，代码中使用了一种新的变量声明。前面的例子中只使用了整数类型的变量（int），但是本例使用了浮点数类型（float）的变量，以便处理更大范围的数据。float 类型可以储存带小数的数字。\n\n为了打印新类型的变量，在printf()中使用%f来处理浮点值。%.2f中的.2用于精确控制输出，指定输出的浮点数只显示小数点后面两位。\n\nscanf()函数用于读取键盘的输入。%f说明scanf()要读取用户从键盘输入的浮点数，&amp;weight告诉 scanf()把输入的值赋给名为 weight 的变量。scanf()函数使用&amp;符号表明找到 weight变量的地点。\n\n变量与常量数据有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量（constant）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量（variable）。\n在示例程序中，weight 是一个变量，14.5833 是一个常量。那么，1700.0 是常量还是变量？在现实生活中，白金的价格不会是常量，但是在程序中，像1700.0这样的价格被视为常量。\n数据：数据类型关键字不仅变量和常量不同，不同的数据类型之间也有差异。一些数据类型表示数字，一些数据类型表示字母（更普遍地说是字符）。C通过识别一些基本的数据类型来区分和使用这些不同的数据类型。如果数据是常量，编译器一般通过用户书写的形式来识别类型（如，42是整数，42.100是浮点数）。但是，对变量而言，要在声明时指定其类型。\n现在，我们先来了解一下 C语言的基本类型关键字。K&amp;C给出了7个与类型相关的关键字。C90标准添加了2个关键字，C99标准又添加了3个关键字。\n\n在C语言中，用int关键字来表示基本的整数类型。后3个关键字（long、short和unsigned）和C90新增的signed用于提供基本整数类型的变式，例如unsigned short int和long long int。char关键字用于指定字母和其他字符（如，#、$、%和*）。\n\n另外，char类型也可以表示较小的整数。float、double和long double表示带小数点的数。_Bool类型表示布尔值（true或false），_complex和_Imaginary分别表示复数和虚数。\n\n通过这些关键字创建的类型，按计算机的储存方式可分为两大基本类型：整数类型和浮点数类型。\n位、字节和字位、字节和字是描述计算机数据单元或存储单元的术语。这里主要指存储单元。\n\n最小的存储单元是位（bit），可以储存0或1（或者说，位用于设置“开”或“关”）。虽然1位储存的信息有限，但是计算机中位的数量十分庞大。位是计算机内存的基本构建块。\n\n字节（byte）是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。这是字节的标准定义，至少在衡量存储单位时是这样（但是，C语言对此有不同的定义，请参阅baidu）。既然1位可以表示0或1，那么8位字节就有256（2的8次方）种可能的0、1的组合。通过二进制编码（仅用0和1便可表示数字），便可表示0～255的整数或一组字符（后面将详细讨论二进制编码，如果感兴趣可以现在浏览一下该章的内容）。\n\n字（word）是设计计算机时给定的自然存储单位。对于8位的微型计算机（如，最初的苹果机）， 1个字长只有8位。从那以后，个人计算机字长增至16位、32位，直到目前的64位。计算机的字长越大，其数据转移越快，允许的内存访问也更多。\n\n整数\n和数学的概念一样，在C语言中，整数是没有小数部分的数。例如，2、−23和2456都是整数。而3.14、0.22和2.000都不是整数。计算机以二进制数字储存整数，例如，整数7以二进制写是111。因此，要在8位字节中储存该数字，需要把前5位都设置成0，后3位设置成1\n\n\n浮点数浮点数与数学中实数的概念差不多。2.75、3.16E7、7.00 和 2e-8 都是浮点数。注意，在一个值后面加上一个小数点，该值就成为一个浮点值。所以，7是整数，7.00是浮点数。显然，书写浮点数有多种形式。稍后将详细介绍e记数法，这里先做简要介绍：3.16E7 表示3.16×107（3.16 乘以10 的7次方）。其中， 107=10000000，7被称为10的指数。\n\n这里关键要理解浮点数和整数的储存方案不同。计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分。因此，虽然7.00和7在数值上相同，但是它们的储存方式不同。在十进制下，可以把7.0写成0.7E1。这里，0.7是小数部分，1是指数部分。\n\n\n\n上图演示了一个储存浮点数的例子。当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂。后面位操作将详述相关内容。现在，我们着重讲解这两种类型的实际区别。\n\n整数没有小数部分，浮点数有小数部分。浮点数可以表示的范围比整数大。对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。因为在任何区间内（如，1.0 到 2.0 之间）都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。\n过去，浮点运算比整数运算慢。不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距。\nC语言基本数据类型int类型int类型是有符号整型，即int类型的值必须是整数，可以是正整数、负整数或零。其取值范围依计算机系统而异。一般而言，储存一个int要占用一个机器字长。因此，早期的16位IBM PC兼容机使用16位来储存一个int值，其取值范围（即int值的取值范围）是-32768～32767。目前的个人计算机一般是32位，因此用32位储存一个int值。现在，个人计算机产业正逐步向着64位处理器发展，自然能储存更大的整数。ISO C规定int的取值范围最小为-32768～32767。一般而言，系统用一个特殊位的值表示有符号整数的正负号。\n初始化变量初始化（initialize）变量就是为变量赋一个初始值。在C语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符（=）和待赋给变量的值即可。如下所示：\n123int hogs &#x3D; 21;int cows &#x3D; 32, goats &#x3D; 14;int dogs, cats &#x3D; 94; &#x2F;* 有效，但是这种格式很糟糕 *&#x2F;以上示例的最后一行，只初始化了cats，并未初始化dogs。这种写法很容易让人误认为dogs也被初始化为94，所以最好不要把初始化的变量和未初始化的变量放在同一条声明中。\n简而言之，声明为变量创建和标记存储空间，并为其指定初始值\n\nint类型常量上面示例中出现的整数（21、32、14和94）都是整型常量或整型字面量。C语言把不含小数点和指数的数作为整数。因此，22和-44都是整型常量，但是22.0和2.2E1则不是。C语言把大多数整型常量视为int类型，但是非常大的整数除外。详见后面“long常量和long long常量”小节对long int类型的讨论。\n打印int值可以使用printf()函数打印int类型的值。%d指明了在一行中打印整数的位置。%d称为转换说明，它指定了printf()应使用什么格式来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型的表达式。作为程序员，要确保转换说明的数量与待打印值的数量相同，编译器不会捕获这类型的错误。下面演示了一个简单的程序，程序中初始化了一个变量，并打印该变量的值、一个常量值和一个简单表达式的值。另外，程序还演示了如果粗心犯错会导致什么结果。\n1234567891011#include　&lt;stdio.h&gt;int　main(void)&#123;    int　ten　&#x3D;　10;    int　two　&#x3D;　2;    printf(&quot;Doing　it　right:　&quot;);    printf(&quot;%d　minus　%d　is　%d\\n&quot;,ten,2,ten-two);    printf(&quot;Doing　it　wrong:　&quot;);    printf(&quot;%d minus %d is %d\\n&quot;,ten);　&#x2F;&#x2F; 遗漏2个参数    return　0;&#125;编译并运行该程序，输出如下：\n12Doing it right: 10 minus 2 is 8Doing it wrong: 10 minus 16 is 1650287143在第一行输出中，第1个%d对应int类型变量ten；第2个%d对应int类型常量2；第3个%d对应int类型表达式ten - two的值。\n在第二行输出中，第1个%d对应ten的值，但是由于没有给后两个%d提供任何值，所以打印出的值是内存中的任意值（读者在运行该程序时显示的这两个数值会与输出示例中的数值不同，因为内存中储存的数据不同，而且编译器管理内存的位置也不同）。\n你可能会抱怨编译器为何不能捕获这种明显的错误，但实际上问题出在 printf()不寻常的设计。大部分函数都需要指定数目的参数，编译器会检查参数的数目是否正确。但是，printf()函数的参数数目不定，可以有1个、2个、3个或更多，编译器也爱莫能助。记住，使用printf()函数时，要确保转换说明的数量与待打印值的数量相等。\n\n当printf没有为%d提供对应的值时，打印出的值是内存中的任意值\n\n八进制和十六进制通常，C语言都假定整型常量是十进制数。然而，许多程序员很喜欢使用八进制和十六进制数。因为8和16都是2的幂，而10却不是。显然，八进制和十六进制记数系统在表达与计算机相关的值时很方便。\n例如，十进制数65536经常出现在16位机中，用十六进制表示正好是10000。另外，十六进制数的每一位的数恰好由4位二进制数表示。例如，十六进制数3是0011，十六进制数5是0101。因此，十六进制数35的位组合（bit pattern）是00110101，十六进制数53的位组合是01010011。这种对应关系使得十六进制和二进制的转换非常方便。但是，计算机如何知道10000是十进制、十六进制还是二进制？在C语言中，用特定的前缀表示使用哪种进制。\n0x或0X前缀表示十六进制值，所以十进制数16表示成十六进制是0x10或0X10。与此类似，0前缀表示八进制。例如，十进制数16表示成八进制是020。第15章将更全面地介绍进制相关的内容。\n要清楚，使用不同的进制数是为了方便，不会影响数被储存的方式。也就是说，无论把数字写成16、020或0x10，储存该数的方式都相同，因为计算机内部都以二进制进行编码。\n显示八进制和十六进制在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用%d；以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。下面程序演示了一个小程序。回忆一下，在某些集成开发环境（IDE）下编写的代码中插入getchar();语句，程序在执行完毕后不会立即关闭执行窗口。\n123456789&#x2F;* bases.c--以十进制、八进制、十六进制打印十进制数100 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    int　x　&#x3D;　100;    printf(&quot;dec&#x3D;%d;octal&#x3D;%o;hex&#x3D;%x\\n&quot;,x,x,x);    printf(&quot;dec&#x3D;%d;octal&#x3D;%#o;hex&#x3D;%#x\\n&quot;,x,x,x);    return　0;&#125;编译并运行该程序，输出如下：\n12dec &#x3D; 100; octal &#x3D; 144; hex &#x3D; 64dec &#x3D; 100; octal &#x3D; 0144; hex &#x3D; 0x64该程序以3种不同记数系统显示同一个值。printf()函数做了相应的转换。注意，如果要在八进制和十六进制值前显示0和0x前缀，要分别在转换说明中加入#。\n其他整数类型C语言提供3个附属关键字修饰基本整数类型：short、long和unsigned。应记住以下几点。\nshort int类型（或者简写为short）占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。与int类似，short是有符号类型。\n\nlong int或long占用的存储空间可能比int多，适用于较大数值的场合。与int类似，long是有符号类型。\n\nlong long int或long long（C99标准加入）占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。与int类似，long long是有符号类型。\n\nunsigned int或unsigned只用于非负值的场合。这种类型与有符号类型表示的范围不同。例如，16位unsigned int允许的取值范围是0～65535，而不是-32768～32767。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。\n\n在C90标准中，添加了unsigned long int或unsigned long和unsigned int或unsigned short类型。C99标准又添加了unsigned long long int或unsigned long long。\n\n在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意图。例如，short、short int、signed short、signed short int都表示同一种类型。\n\n声明其他整数类型其他整数类型的声明方式与int类型相同，下面列出了一些例子。不是所有的C编译器都能识别最后3条声明，最后一个例子所有的类型是C99标准新增的。\n123456789long int　estine;long johns;short int　erns;short　ribs;unsigned int　s_count;unsigned　players;unsigned long　headcount;unsigned short　yesvotes;long long　ago;使用多种整数类型的原因为什么说short类型“可能”比int类型占用的空间少，long类型“可能”比int类型占用的空间多？因为C语言只规定了short占用的存储空间不能多于int，long占用的存储空间不能少于int。这样规定是为了适应不同的机器。\n例如，过去的一台运行Windows 3的机器上，int类型和short类型都占16位，long类型占32位。后来，Windows和苹果系统都使用16位储存short类型，32位储存int类型和long类型（使用32位可以表示的整数数值超过20亿）。现在，计算机普遍使用64位处理器，为了储存64位的整数，才引入了long long类型。\n现在，个人计算机上最常见的设置是，long long占64位，long占32位，short占16位，int占16位或32位（依计算机的自然字长而定）。原则上，这4种类型代表4种不同的大小，但是在实际使用中，有些类型之间通常有重叠。\nC 标准对基本数据类型只规定了允许的最小大小。对于 16 位机，short 和 int 的最小取值范围是[−32767,32767]；对于32位机，long的最小取值范围是[−2147483647,2147483647]。对于unsigned short和unsigned int，最小取值范围是[0,65535]；对于unsigned long，最小取值范围是[0,4294967295]。long long类型是为了支持64位的需求，最小取值范围是[−9223372036854775807,9223372036854775807]；unsigned long long的最小取值范围是[0,18446744073709551615]。如果要开支票，这个数是一千八百亿亿（兆）六千七百四十四万亿零七百三十七亿零九百五十五万一千六百一十五。但是，谁会去数？\nint类型那么多，应该如何选择？首先，考虑unsigned类型。这种类型的数常用于计数，因为计数不用负数。而且，unsigned类型可以表示更大的正数。\n如果一个数超出了int类型的取值范围，且在long类型的取值范围内时，使用long类型。然而，对于那些long占用的空间比int大的系统，使用long类型会减慢运算速度。因此，如非必要，请不要使用long类型。另外要注意一点：如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要32位的整数时，应使用long类型而不是int类型，以便把程序移植到16位机后仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long类型。\n如果在int设置为32位的系统中要使用16位的值，应使用short类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。\nlong常量和long long常量通常，程序代码中使用的数字（如，2345）都被储存为int类型。如果使用1000000这样的大数字，超出了int类型能表示的范围，编译器会将其视为long int类型（假设这种类型可以表示该数字）。如果数字超出long可表示的最大值，编译器则将其视为unsigned long类型。如果还不够大，编译器则将其视为long long或unsigned long long类型（前提是编译器能识别这些类型）。\n八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long long和unsigned long long类型。\n有些情况下，需要编译器以long类型储存一个小数字。例如，编程时要显式使用IBM PC上的内存地址时。另外，一些C标准函数也要求使用long类型的值。要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小写的L）或L后缀。使用L后缀更好，因为l看上去和数字1很像。因此，在int为16位、long为32位的系统中，会把7作为16位储存，把7L作为32位储存。l或L后缀也可用于八进制和十六进制整数，如020L和0x10L。\n类似地，在支持long long类型的系统中，也可以使用ll或LL后缀来表示long long类型的值，如3LL。另外，u或U后缀表示unsigned long long，如5ull、10LLU、6LLU或9Ull。\n整数溢出如果整数超出了相应类型的取值范围会怎样？下面分别将有符号类型和无符号类型的整数设置为比最大值略大，看看会发生什么（printf()函数使用%u说明显示unsigned int类型的值）。\n12345678910&#x2F;* toobig.c-- 超出系统允许的最大int值*&#x2F;#include &lt;stdio.h&gt;int main(void)&#123;    int i&#x3D;2147483647;    unsigned int j&#x3D;4294967295;    printf(&quot;%d %d %d\\n&quot;,i,i+1,i+2);    printf(&quot;%u %u %u\\n&quot;,j,j+1,j+2);    return 0;&#125;在我们的系统下输出的结果是：\n122147483647　　　-2147483648　 -21474836474294967295　　　0　　 1可以把无符号整数j看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始。整数 i 也是类似的情况。它们主要的区别是，在超过最大值时，unsigned int 类型的变量 j 从 0开始；而int类型的变量i则从−2147483648开始。注意，当i超出（溢出）其相应类型所能表示的最大值时，系统并未通知用户。因此，在编程时必须自己注意这类问题。\n溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则。以上描述的溢出行为比较有代表性，但是也可能会出现其他情况。\n打印short、long、long long和unsigned类型打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。\nC语言有多种printf()格式。对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，%lu表示打印unsigned long类型的值。下面程序演示了一些例子。对于支持long long类型的系统，%lld和%llu分别表示有符号和无符号类型。《字符串和格式化输入/输出》将详细介绍转换说明。\n1234567891011121314&#x2F;* print2.c--更多printf()的特性 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    unsigned int un&#x3D;3000000000;     &#x2F;* int为32位和short为16位的系统 *&#x2F;    short　end&#x3D;200;    long　big&#x3D;65537;    long　long　verybig　&#x3D;　12345678908642;    printf(&quot;un&#x3D;%u　and　not　%d\\n&quot;,　un,　un);    printf(&quot;end&#x3D;%hd　and　%d\\n&quot;,　end,　end);    printf(&quot;big&#x3D;%ld　and　not　%hd\\n&quot;,　big,　big);    printf(&quot;verybig&#x3D;%lld　and　not　%ld\\n&quot;,verybig,verybig);    return　0;&#125;在特定的系统中输出如下（输出的结果可能不同）：\n1234un &#x3D; 3000000000 and not -1294967296end &#x3D; 200 and 200big &#x3D; 65537 and not 1verybig&#x3D; 12345678908642 and not 1942899938该例表明，使用错误的转换说明会得到意想不到的结果。第 1 行输出，对于无符号变量 un，使用%d会生成负值！其原因是，无符号值 3000000000 和有符号值−129496296 在系统内存中的内部表示完全相同（详见位操作）。\n因此，如果告诉printf()该数是无符号数，它打印一个值；如果告诉它该数是有符号数，它将打印另一个值。在待打印的值大于有符号值的最大值时，会发生这种情况。对于较小的正数（如96），有符号和无符号类型的存储、显示都相同。\n第2行输出，对于short类型的变量end，在printf()中无论指定以short类型（%hd）还是int类型（%d）打印，打印出来的值都相同。这是因为在给函数传递参数时，C编译器把short类型的值自动转换成int类型的值。你可能会提出疑问：为什么要进行转换？h修饰符有什么用？第1个问题的答案是， int类型被认为是计算机处理整数类型时最高效的类型。因此，在short和int类型的大小不同的计算机中，用int类型的参数传递速度更快。第2个问题的答案是，使用h修饰符可以显示较大整数被截断成 short 类型值的情况。\n第 3 行输出就演示了这种情况。把 65537 以二进制格式写成一个 32 位数是00000000000000010000000000000001。使用%hd，printf()只会查看后 16 位，所以显示的值是 1。\n与此类似，输出的最后一行先显示了verybig的完整值，然后由于使用了%ld，printf()只显示了储存在后32位的值。\n本章前面介绍过，程序员必须确保转换说明的数量和待打印值的数量相同。以上内容也提醒读者，程序员还必须根据待打印值的类型使用正确的转换说明。\n\n提示 匹配printf()说明符的类型\n\n在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。\n使用字符：char类型char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。美国最常用的编码是ASCII编码，本书也使用此编码。例如，在ASCII码中，整数65代表大写字母A。因此，储存字母A实际上储存的是整数65（许多IBM的大型主机使用另一种编码——EBCDIC，其原理相同。另外，其他国家的计算机系统可能使用完全不同的编码）。\n标准ASCII码的范围是0～127，只需7位二进制数即可表示。通常，char类型被定义为8位的存储单元，因此容纳标准ASCII码绰绰有余。许多其他系统（如IMB PC和苹果Macs）还提供扩展ASCII码，也在8位的表示范围之内。一般而言，C语言会保证char类型足够大，以储存系统（实现C语言的系统）的基本字符集。\n许多字符集都超过了127，甚至多于255。例如，日本汉字（kanji）字符集。商用的统一码（Unicode）创建了一个能表示世界范围内多种字符集的系统，目前包含的字符已超过110000个。国际标准化组织（ISO）和国际电工技术委员会（IEC）为字符集开发了ISO/IEC 10646标准。统一码标准也与ISO/IEC 10646标准兼容。\nC语言把1字节定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。\n声明char类型变量char类型变量的声明方式与其他类型变量的声明方式相同。下面是一些例子：\n12char response;char itable, latan;以上声明创建了3个char类型的变量：response、itable和latan。\n字符常量和初始化如果要把一个字符常量初始化为字母 A，不必背下 ASCII 码，用计算机语言很容易做到。通过以下初始化把字母A赋给grade即可：\n1char grade &#x3D; &#39;A&#39;;在C语言中，用单引号括起来的单个字符被称为字符常量（character constant）。编译器一发现’A’，就会将其转换成相应的代码值。单引号必不可少。下面还有一些其他的例子：\n1234char broiled;　　 &#x2F;* 声明一个char类型的变量 *&#x2F;broiled &#x3D; &#39;T&#39;;　　&#x2F;* 为其赋值，正确 *&#x2F;broiled &#x3D; T;　　　&#x2F;* 错误！此时T是一个变量 *&#x2F;broiled &#x3D; &quot;T&quot;;　　&#x2F;* 错误！此时&quot;T&quot;是一个字符串 *&#x2F;如上所示，如果省略单引号，编译器认为T是一个变量名；如果把T用双引号括起来，编译器则认为”T”是一个字符串。字符串的内容将在《字符串和格式化输入/输出》中介绍。\n实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值：\n1char grade &#x3D; 65; &#x2F;* 对于ASCII，这样做没问题，但这是一种不好的编程风格 *&#x2F;在本例中，虽然65是int类型，但是它在char类型能表示的范围内，所以将其赋值给grade没问题。由于65是字母A对应的ASCII码，因此本例是把A赋给grade。注意，能这样做的前提是系统使用ASCII码。其实，用’A’代替65才是较为妥当的做法，这样在任何系统中都不会出问题。因此，最好使用字符常量，而不是数字代码值。\n奇怪的是，C语言将字符常量视为int类型而非char类型。例如，在int为32位、char为8位的ASCII系统中，有下面的代码：\n1char grade &#x3D; &#39;B&#39;;本来’B’对应的数值66储存在32位的存储单元中，现在却可以储存在8位的存储单元中（grade）。利用字符常量的这种特性，可以定义一个字符常量’FATE’，即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。因此，grade的值是’E’。\n非打印字符单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）。C语言提供了3种方法表示这些字符。\n第1种方法前面介绍过——使用ASCII码。例如，蜂鸣字符的ASCII值是7，因此可以这样写：1char beep &#x3D; 7;\n第2种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列（escape sequence）。图列出了转义序列及其含义。把转义序列赋给字符变量时，必须用单引号把转义序列括起来。例如，假设有下面一行代码：1char nerf &#x3D; &#39;\\n&#39;;稍后打印变量nerf的效果是，在打印机或屏幕上另起一行。\n\n现在，我们来仔细分析一下转义序列。使用C90新增的警报字符（\\a）是否能产生听到或看到的警报，取决于计算机的硬件，蜂鸣是最常见的警报（在一些系统中，警报字符不起作用）。C标准规定警报字符不得改变活跃位置。标准中的活跃位置（active position）指的是显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕光标位置就是活跃位置。在程序中把警报字符输出在屏幕上的效果是，发出一声蜂鸣，但不会移动屏幕光标。\n接下来的转义字符\\b、\\f、\\n、\\r、\\t和\\v是常用的输出设备控制字符。了解它们最好的方式是查看它们对活跃位置的影响。\n换页符（\\f）把活跃位置移至下一页的开始处；\n\n换行符（\\n）把活跃位置移至下一行的开始处；\n\n回车符（\\r）把活跃位置移动到当前行的开始处；\n\n水平制表符（\\t）将活跃位置移至下一个水平制表点（通常是第1个、第9个、第17个、第25个等字符位置）；\n\n垂直制表符（\\v）把活跃位置移至下一个垂直制表点。\n\n这些转义序列字符不一定在所有的显示设备上都起作用。例如，换页符和垂直制表符在PC屏幕上会生成奇怪的符号，光标并不会移动。只有将其输出到打印机上时才会产生前面描述的效果。\n接下来的3个转义序列（\\\\、\\‘、\\“）用于打印\\、&#39;、&quot;字符（由于这些字符用于定义字符常量，是printf()函数的一部分，若直接使用它们会造成混乱）。如果打印下面一行内容：\n1Gramps sez, &quot;a \\ is a backslash.&quot;应这样编写代码：\n1printf(&quot;Gramps sez, \\&quot;a \\\\ is a backslash.\\&quot;\\n&quot;);表中的最后两个转义序列（\\0oo和\\xhh）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\\）并用单引号括起来。八进制表示格式为/000，可写1～3位八进制进制数字，每位数最大值为7\n例如，如果编译器不识别警报字符（\\a），可以使用ASCII码来代替：\n1beep &#x3D; &#39;\\007&#39;;可以省略前面的 0，’\\07’甚至’\\7’都可以。即使没有前缀 0，编译器在处理这种写法时，仍会解释为八进制。\n从C90开始，不仅可以用十进制、八进制形式表示字符常量，C语言还提供了第3种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个x或X。十六进制数表示格式为/xhh，前面的x表示是十六进制，再加上1～2位十六进制数字，所以后面的两个h可以表示两位数，每位数最大值为f\n例如，Ctrl+P字符的ASCII十六进制码是10（相当于十进制的16），可表示为’\\x10’或’\\x010’。下图列出了一些整数类型的不同进制形式。\n\n使用ASCII码时，注意数字和数字字符的区别。例如，字符4对应的ASCII码是52。&#39;4&#39;表示字符4，而不是数值4。\n关于转义序列，读者可能有下面3个问题。\n上面最后一个例子（printf(&quot;Gramps sez, \\&quot;a \\\\ is a backslash\\&quot;\\&quot;n&quot;），  为何没有用单引号把转义序列括起来？ 无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。双引号中的字符集合叫作字符串（详见字符串和格式化输入输出）。注意，该例中的其他字符（G、r、a、m、p、s等）都没有用单引号括起来。与此类似，printf(&quot;Hello!\\007\\n&quot;);将打印Hello!并发出一声蜂鸣，而 printf(&quot;Hello!7\\n&quot;);则打印 Hello!7。不是转义序列中的数字将作为普通字符被打印出来。\n\n何时使用ASCII码？何时使用转义序列？如果要在转义序列（假设使用’\\f’）和ASCII码（’\\014’）之间选择，请选择前者（即’\\f’）。这样的写法不仅更好记，而且可移植性更高。’\\f’在不使用ASCII码的系统中，仍然有效。\n\n如果要使用ASCII码，为何要写成’\\032’而不是032？首先，’\\032’能更清晰地表达程序员使用字符编码的意图。其次，类似\\032这样的转义序列可以嵌入C的字符串中，如printf(“Hello!\\007\\n”);中就嵌入了\\007。\n\n打印字符printf()函数用%c指明待打印的字符。前面介绍过，一个字符变量实际上被储存为1字节的整数值。因此，如果用%d转换说明打印 char类型变量的值，打印的是一个整数。而%c转换说明告诉printf()打印该整数值对应的字符。程序清单3.5演示了打印char类型变量的两种方式。\n程序清单3.5 charcode.c程序\n12345678910&#x2F;* charcode.c-显示字符的代码编号 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;char　ch;printf(&quot;Please　enter　a　character.\\n&quot;);scanf(&quot;%c&quot;, &amp;ch);　&#x2F;* 用户输入字符 *&#x2F;printf(&quot;The　code　for　%c　is　%d.\\n&quot;,　ch,　ch);return　0;&#125;运行该程序后，输出示例如下：\n123Please　enter　a　character.CThe　code　for　C　is　67.运行该程序时，在输入字母后不要忘记按下Enter或Return键。随后，scanf()函数会读取用户输入的字符，&amp;符号表示把输入的字符赋给变量ch。接着，printf()函数打印ch的值两次，第1次打印一个字符（对应代码中的%c），第2次打印一个十进制整数值（对应代码中的%d）。注意，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式。\n\n有符号还是无符号有些C编译器把char实现为有符号类型，这意味着char可表示的范围是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的范围是0～255。请查阅相应的编译器手册，确定正在使用的编译器如何实现char类型。或者，可以查阅limits.h头文件。下一章将详细介绍头文件的内容。\n根据C90标准，C语言允许在关键字char前面使用signed或unsigned。这样，无论编译器默认char是什么类型，signed char表示有符号类型，而unsigned char表示无符号类型。这在用char类型处理小整数时很有用。如果只用char处理字符，那么char前面无需使用任何修饰符。\nBool类型C99标准添加了_Bool类型，用于表示布尔值，即逻辑值true和false。因为C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。但原则上它仅间占用1位存储空，因为对0和1而言，1位的存储空间足够了。\n程序通过布尔值可选择执行哪部分代码。\n可移植类型：stdint.h和inttypes.hC 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的功能不一样。C99 新增了两个头文件stdint.h和inttypes.h，以确保C语言的类型在各系统中的功能相同。\n C语言为现有类型创建了更多类型名。这些新的类型名定义在stdint.h头文件中。  \n例如，int32_t表示32位的有符号整数类型。在使用32位int的系统中，头文件会把int32_t作为int的别名。  \n不同的系统也可以定义相同的类型名。\n\n例如，int为16位、long为32位的系统会把int32_t作为long的别名。然后，使用int32_t类型编写程序，并包含stdint.h头文件时，编译器会把int或long替换成与当前系统匹配的类型。\n上面讨论的类型别名是精确宽度整数类型（exact-width integer type）的示例。int32_t表示整数类型的宽度正好是32位。但是，计算机的底层系统可能不支持。因此，精确宽度整数类型是可选项。\n\n\n如果系统不支持精确宽度整数类型怎么办？ C99和C11提供了第2类别名集合。一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型。这组类型集合被称为最小宽度类型（minimum width type）。\n 例如，int_least8_t是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是16位，可能不会定义int8_t类型。尽管如此，该系统仍可使用int_least8_t类型，但可能把该类型实现为16位的整数类型。\n 当然，一些程序员更关心速度而非空间。为此，C99和C11定义了一组可使计算达到最快的类型集合。这组类型集合被称为最快最小宽度类型（fastst minimum width type）。\n\n例如，int_fast8_t被定义为系统中对8位有符号值而言运算最快的整数类型的别名。\n另外，有些程序员需要系统的最大整数类型。为此，C99定义了最大的有符号整数类型intmax_t，可储存任何有效的有符号整数值。类似地，unintmax_t表示最大的无符号整数类型。顺带一提，这些类型有可能比long long和unsigned long类型更大，因为C编译器除了实现标准规定的类型以外，还可利用C语言实现其他类型。例如，一些编译器在标准引入 long long 类型之前，已提前实现了该类型。\nC99 和C11 不仅提供可移植的类型名，还提供相应的输入和输出。\n例如，printf()打印特定类型时要求与相应的转换说明匹配。\n\n如果要打印int32_t类型的值，有些定义使用%d，而有些定义使用%ld，怎么办？\n\nC 标准针对这一情况，提供了一些字符串宏（下章中详细介绍）来显示可移植类型。例如， inttypes.h头文件中定义了PRId32字符串宏，代表打印32位有符号值的合适转换说明（如d或l）。程序清单3.6演示了一种可移植类型和相应转换说明的用法。\n程序清单3.6 altnames.c程序\n1234567891011121314&#x2F;* altnames.c -- 可移植整数类型名 *&#x2F;#include　&lt;stdio.h&gt;#include &lt;inttypes.h&gt; &#x2F;&#x2F; 支持可移植类型int　main(void)&#123;\tint32_t me32;　　 &#x2F;&#x2F; me32是一个32位有符号整型变量\tme32&#x3D;45933945;\tprintf(&quot;First,assume int32_t is int: &quot;);\tprintf(&quot;me32&#x3D;%d\\n&quot;,me32);\tprintf(&quot;Next,let&#39;s not make any assumptions.\\n&quot;);\tprintf(&quot;Instead,use a \\&quot;macro\\&quot; from　inttypes.h:　&quot;);\tprintf(&quot;me32&#x3D;%&quot; PRId32 &quot;\\n&quot;,　me32);\treturn　0;&#125;该程序最后一个printf()中，参数PRId32被定义在inttypes.h中的”d”替换，因而这条语句等价于：\n1printf(&quot;me16 &#x3D; %&quot; &quot;d&quot; &quot;\\n&quot;, me16);在C语言中，可以把多个连续的字符串组合成一个字符串，所以这条语句又等价于：\n1printf(&quot;me16 &#x3D; %d\\n&quot;, me16);下面是该程序的输出，注意，程序中使用了&quot;转义序列来显示双引号：\n123First, assume int32_t is int: me32 &#x3D; 45933945Next, let&#39;s not make any assumptions.Instead, use a &quot;macro&quot; from inttypes.h: me32 &#x3D; 45933945篇幅有限，无法介绍扩展的所有整数类型。本节主要是为了让读者知道，在需要时可进行这种级别的类型控制。附录B中的参考资料VI“扩展的整数类型”介绍了完整的inttypes.h和stdint.h头文件。\n注意 对C99/C11的支持\nC语言发展至今，虽然ISO已发布了C11标准，但是编译器供应商对C99的实现程度却各不相同。在本书第6版的编写过程中，一些编译器仍未实现inttypes.h头文件及其相关功能。\nfloat、double和long double各种整数类型对大多数软件开发项目而言够用了。然而，面向金融和数学的程序经常使用浮点数。C语言中的浮点类型有float、double和long double类型。它们与FORTRAN和Pascal中的real类型一致。前面提到过，浮点类型能表示包括小数在内更大范围的数。浮点数的表示类似于科学记数法（即用小数乘以10的幂来表示数字）。该记数系统常用于表示非常大或非常小的数。表3.3列出了一些示例。\n表3.3 记数法示例\n\n第1列是一般记数法；第2列是科学记数法；第3列是指数记数法（或称为e记数法），这是科学记数法在计算机中的写法，e后面的数字代表10的指数。图3.7演示了更多的浮点数写法。\nC标准规定，float类型必须至少能表示6位有效数字，且取值范围至少是10-37～10+37。前一项规定指float类型必须至少精确表示小数点后的6位有效数字，如33.333333。后一项规定用于方便地表示诸如太阳质量（2.0e30千克）、一个质子的电荷量（1.6e-19库仑）或国家债务之类的数字。通常，系统储存一个long浮点数要占用32位。其中8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫作尾数或有效数）及其符号。\n\nC语言提供的另一种浮点类型是double（意为双精度）。double类型和float类型的最小取值范围相同，但至少必须能表示10位有效数字。一般情况下，double占用64位而不是32位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，double类型的值至少有13位有效数字，超过了标准的最低位数规定。\nC语言的第3种浮点类型是long double，以满足比double类型更高的精度要求。不过，C只保证long double类型至少与double类型的精度相同。\n声明浮点型变量 浮点型变量的声明和初始化方式与整型变量相同，下面是一些例子：\n1234float　noah,　jonah;double　trouble;float　planck　&#x3D;　6.63e-34;long　double　gnp;\n浮点型常量 在代码中，可以用多种形式书写浮点型常量。浮点型常量的基本形式是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。下面是两个有效的浮点型常量：\n12-1.56E+122.87e-3 正号可以省略。可以没有小数点（如，2E5）或指数部分（如，19.28），但是不能同时省略两者。可以省略小数部分（如，3.E16）或整数部分（如，.45E-6），但是不能同时省略两者。下面是更多的有效浮点型常量示例：\n123453.14159.24e16.8E-5100.不要在浮点型常量中间加空格：1.56 E+12（错误！）\n\n默认情况下，编译器假定浮点型常量是double类型的精度。例如，假设some是float类型的变量，编写下面的语句：\n1some &#x3D; 4.0 * 2.0;通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。\n在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类型，如54.3l和4.32L。注意，建议使用L后缀，因为字母l和数字1很容易混淆。没有后缀的浮点型常量是double类型。\n\nC99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂（即，p计数法）。如下所示：\n\n10xa.1fp10十六进制a等于十进制10，.1f是1/16加上15/256（十六进制f等于十进制15），p10是210或1024。0xa.1fp10表示的值是(10 + 1/16 + 15/256)×1024（即，十进制10364.0）。\n注意，并非所有的编译器都支持C99的这一特性。\n打印浮点值printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点数，用%e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La转换说明。给那些未在函数原型中显式说明参数类型的函数（如，printf()）传递参数时，C编译器会把float类型的值自动转换成double类型。程序清单3.7演示了这些特性。\n程序清单3.7 showf_pt.c程序\n1234567891011121314&#x2F;* showf_pt.c -- 以两种方式显示float类型的值 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　aboat　&#x3D;　32000.0;    double　abet　&#x3D;　2.14e9;    long　double　dip　&#x3D;　5.32e-5;    printf(&quot;%f　can　be　written　%e\\n&quot;,　aboat,　aboat);    &#x2F;&#x2F; 下一行要求编译器支持C99或其中的相关特性    printf(&quot;And　it&#39;s　%a　in　hexadecimal,　powers　of　2　notation\\n&quot;,　aboat);    printf(&quot;%f　can　be　written　%e\\n&quot;,　abet,　abet);    printf(&quot;%Lf　can　be　written　%Le\\n&quot;,　dip,　dip);    return　0;&#125;该程序的输出如下，前提是编译器支持C99/C11：\n123432000.000000　can　be　written　3.200000e+04And　it&#39;s　0x1.f4p+14　in　hexadecimal,　powers　of　2　notation2140000000.000000　can　be　written　2.140000e+090.000053　can　be　written　5.320000e-05该程序示例演示了默认的输出效果。下一章将介绍如何通过设置字段宽度和小数位数来控制输出格式。\n浮点值的上溢和下溢假设系统的最大float类型值是3.4E38，编写如下代码：\n12float toobig &#x3D; 3.4E38 * 100.0f;printf(&quot;%e\\n&quot;, toobig);会发生什么？这是一个上溢（overflow）的示例。当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定义的，不过现在C语言规定，在这种情况下会给toobig赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内容）。\n当除以一个很小的数时，情况更为复杂。回忆一下，float类型的数以指数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数字。现在把它除以 2。通常，这个操作会减小指数部分，但是假设的情况中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫作下溢（underflow）。C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0。现在，C库已提供了用于检查计算是否会产生低于正常值的函数。\n还有另一个特殊的浮点值NaN（not a number的缩写）。例如，给asin()函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的值。但是正弦值不能大于1，因此，如果传入的参数大于1，该函数的行为是未定义的。在这种情况下，该函数将返回NaN值，printf()函数可将其显示为nan、NaN或其他类似的内容。\n浮点数舍入错误给定一个数，加上1，再减去原来给定的数，结果是多少？你一定认为是1。但是，下面的浮点运算给出了不同的答案：\n12345678910&#x2F;* floaterr.c--演示舍入错误 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　a,b;    b　&#x3D;　2.0e20　+　1.0;    a　&#x3D;　b　-　2.0e20;    printf(&quot;%f　\\n&quot;,　a);    return　0;&#125;该程序的输出如下：\n得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。\n浮点数表示法上一个方框中列出了由于计算机使用的系统不同，一个程序有不同的输出。原因是，根据前面介绍的知识，实现浮点数表示法的方法有多种。为了尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示法开发了一套标准。现在，许多硬件浮点单元都采用该标准。2011年，该标准被ISO/IEC/IEEE 60559:2011标准收录。该标准作为C99和C11的可选项，符合硬件要求的平台可开启。floaterr.c程序的第3个输出示例即是支持该浮点标准的系统显示的结果。支持C标准的编译器还包含捕获异常问题的工具。详见附录B.5，参考资料V。\n复数和虚数类型许多科学和工程计算都要用到复数和虚数。C99 标准支持复数类型和虚数类型，但是有所保留。一些独立实现，如嵌入式处理器的实现，就不需要使用复数和虚数（VCR芯片就不需要复数）。一般而言，虚数类型都是可选项。C11标准把整个复数软件包都作为可选项。\n简而言之，C语言有3种复数类型：float_Complex、double_Complex和long double _Complex。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型是float _Imaginary、double _Imaginary和long double _Imaginary。\n如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。\n\n为何 C 标准不直接用 complex 作为关键字来代替_Complex，而要添加一个头文件（该头文件中把complex定义为_Complex）？\n\n因为标准委员会考虑到，如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部失效。例如，之前的 C99，许多程序员已经使用 struct complex 定义一个结构来表示复数或者心理学程序中的心理状况（关键字struct用于定义能储存多个值的结构，详见第14章）。让complex成为关键字会导致之前的这些代码出现语法错误。但是，使用struct _Complex的人很少，特别是标准使用首字母是下划线的标识符作为预留字以后。因此，标准委员会选定_Complex作为关键字，在不用考虑名称冲突的情况下可选择使用complex。\n其他类型现在已经介绍完C语言的所有基本数据类型。有些人认为这些类型实在太多了，但有些人觉得还不够用。注意，虽然C语言没有字符串类型，但也能很好地处理字符串。第4章将详细介绍相关内容。\nC语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合。尽管后面章节中会详细介绍这些类型，但是本章的程序示例中已经用到了指针〔指针（pointer）指向变量或其他数据对象位置〕。例如，在 scanf()函数中用到的前缀&amp;，便创建了一个指针，告诉 scanf()把数据放在何处。\n小结：基本数据类型关键字：基本数据类型由11个关键字组成：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。\n\n有符号整型：  有符号整型可用于表示正整数和负整数。\n  int——系统给定的基本整数类型。C语言规定int类型不小于16位。\n  short或short int ——最大的short类型整数小于或等于最大的int类型整数。C语言规定short类型至少占16位。\n  long或long int ——该类型可表示的整数大于或等于最大的int类型整数。C语言规定long类型至少占32位。\n  long long或long long int ——该类型可表示的整数大于或等于最大的long类型整数。Long long类型至少占64位。\n  一般而言，long类型占用的内存比short类型大，int类型的宽度要么和long类型相同，要么和short类型相同。例如，旧DOS系统的PC提供16位的short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long。\n\n无符号整型：\n  无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数比有符号整型的大。在整型类型前加上关键字unsigned表明该类型是无符号整型：unsignedint、unsigned long、unsigned short。单独的unsigned相当于unsigned int。\n\n字符类型：\n  可打印出来的符号（如A、&amp;和+）都是字符。根据定义，char类型表示一个字符要占用1字节内存。出于历史原因，1字节通常是8位，但是如果要表示基本字符集，也可以是16位或更大。\n  char ——字符类型的关键字。有些编译器使用有符号的char，而有些则使用无符号的char。在需要时，可在char前面加上关键字signed或unsigned来指明具体使用哪一种类型。\n\n布尔类型：\n  布尔值表示true和false。C语言用1表示true，0表示false。\n  _Bool ——布尔类型的关键字。布尔类型是无符号 int类型，所占用的空间只要能储存0或1即可。\n\n实浮点类型：\n  实浮点类型可表示正浮点数和负浮点数。\n  float ——系统的基本浮点类型，可精确表示至少-6位有效数字。\n  double ——储存浮点数的范围（可能）更大，能表示比 float 类型更多的有效数字（至少 10位，通常会更多）和更大的指数。\n  long long ——储存浮点数的范围（可能）比double更大，能表示比double更多的有效数字和更大的指数。\n\n复数和虚数浮点数：\n  虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构成：\n123456float _Complexdouble _Complexlong double _Complexfloat _Imaginarydouble _Imaginarylong long _Imaginary\n小结：如何声明简单变量\n\n\n选择需要的类型。\n\n使用有效的字符给变量起一个变量名。\n\n按以下格式进行声明：\n 类型说明符 变量名;\n 类型说明符由一个或多个关键字组成。下面是一些示例：\n12int erest;unsigned short cash;\n可以同时声明相同类型的多个变量，用逗号分隔各变量名，如下所示：\n1char ch, init, ans;\n在声明的同时还可以初始化变量：\n1float mass &#x3D; 6.0E24;\n类型大小如何知道当前系统的指定类型的大小是多少？运行程序清单3.8，会列出当前系统的各类型的大小。\n123456789101112131415161718程序清单3.8 typesize.c程序&#x2F;&#x2F;* typesize.c -- 打印类型大小 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    &#x2F;* C99为类型大小提供%zd转换说明 *&#x2F;    printf(&quot;Type　int　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(int));    printf(&quot;Type　char　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(char));    printf(&quot;Type　long　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(long));    printf(&quot;Type　long　long　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(long　long));    printf(&quot;Type　double　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(double));    printf(&quot;Type　long　double　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(long　double));    return　0;&#125;sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。\n该程序的输出如下：\n123456Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 8 bytes.Type long long has a size of 8 bytes.Type double has a size of 8 bytes.Type long double has a size of 16 bytes.该程序列出了6种类型的大小，你也可以把程序中的类型更换成感兴趣的其他类型。注意，因为C语言定义了char类型是1字节，所以char类型的大小一定是1字节。而在char类型为16位、double类型为64位的系统中，sizeof给出的double是4字节。在limits.h和float.h头文件中有类型限制的相关信息（下一章将详细介绍这两个头文件）。\n顺带一提，注意该程序最后几行 printf()语句都被分为两行，只要不在引号内部或一个单词中间断行，就可以这样写。\n使用数据类型编写程序时，应注意合理选择所需的变量及其类型。通常，用int或float类型表示数字，char类型表示字符。在使用变量之前必须先声明，并选择有意义的变量名。初始化变量应使用与变量类型匹配的常数类型。例如：\n12int apples &#x3D; 3;　　　 &#x2F;* 正确 *&#x2F;int oranges &#x3D; 3.0;　　&#x2F;* 不好的形式 *&#x2F;与Pascal相比，C在检查类型匹配方面不太严格。C编译器甚至允许二次初始化，但在激活了较高级别警告时，会给出警告。最好不要养成这样的习惯。\n把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。例如，下面的初始化：\n12int cost &#x3D; 12.99;　　 &#x2F;* 用double类型的值初始化int类型的变量 *&#x2F;float pi &#x3D; 3.1415926536;　 &#x2F;* 用double类型的值初始化float类型的变量 *&#x2F;第1个声明，cost的值是12。C编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。第2个声明会损失一些精度，因为C只保证了float类型前6位的精度。编译器对这样的初始化可能给出警告。读者在编译程序清单3.1时可能就遇到了这种警告。\n许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。例如，用 i_前缀表示 int类型，us_前缀表示 unsigned short 类型。这样，一眼就能看出来i_smart 是 int 类型的变量， us_versmart是unsigned short类型的变量。\n参数和陷阱有必要再次提醒读者注意 printf()函数的用法。读者应该还记得，传递给函数的信息被称为参数。例如，printf(&quot;Hello, pal.&quot;)函数调用有一个参数：&quot;Hello,pal.&quot;。双引号中的字符序列（如，”Hello,pal.“）被称为字符串（string），第4章将详细讲解相关内容。现在，关键是要理解无论双引号中包含多少个字符和标点符号，一个字符串就是一个参数。\n与此类似，scanf(&quot;%d&quot;, &amp;weight)函数调用有两个参数：&quot;%d&quot;和&amp;weight。C语言用逗号分隔函数中的参数。printf()和scanf()函数与一般函数不同，它们的参数个数是可变的。例如，前面的程序示例中调用过带一个、两个，甚至三个参数的 printf()函数。程序要知道函数的参数个数才能正常工作。printf()和scanf()函数用第1个参数表明后续有多少个参数，即第1个字符串中的转换说明与后面的参数一一对应。例如，下面的语句有两个%d转换说明，说明后面还有两个参数：\n1printf(&quot;%d cats ate %d cans of tuna\\n&quot;, cats, cans);后面的确还有两个参数：cats和cans。\n程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配。现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确。但是，该机制对printf()和scanf()不起作用，因为这两个函数的参数个数可变。如果参数在匹配上有问题，会出现什么情况？假设你编写了程序清单 3.9中的程序。\n程序清单3.9 badcount.c程序\n12345678910111213&#x2F;* badcount.c -- 参数错误的情况 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    int　n　&#x3D;　4;    int　m　&#x3D;　5;    float　f　&#x3D;　7.0f;    float　g　&#x3D;　8.0f;    printf(&quot;%d\\n&quot;, n, m);　 &#x2F;* 参数太多　*&#x2F;    printf(&quot;%d %d %d\\n&quot;, n); &#x2F;* 参数太少　*&#x2F;    printf(&quot;%d %d\\n&quot;, f, g); &#x2F;* 值的类型不匹配 *&#x2F;    return　0;&#125;XCode 4.6（OS 10.8）的输出如下：\n12344　1　-7063378361606414344　1Microsoft Visual Studio Express 2012（Windows 7）的输出如下：\n12344　0　00　1075576832\n注意，用%d显示float类型的值，其值不会被转换成int类型。在不同的平台下，缺少参数或参数类型不匹配导致的结果不同。\n\n所有编译器都能顺利编译并运行该程序，但其中大部分会给出警告。的确，有些编译器会捕获到这类问题，然而C标准对此未作要求。因此，计算机在运行时可能不会捕获这类错误。如果程序正常运行，很难觉察出来。如果程序没有打印出期望值或打印出意想不到的值，你才会检查 printf()函数中的参数个数和类型是否得当。\n转义序列示例再来看一个程序示例，该程序使用了一些特殊的转义序列。程序清单 3.10 演示了退格（\\b）、水平制表符（\\t）和回车（\\r）的工作方式。这些概念在计算机使用电传打字机作为输出设备时就有了，但是它们不一定能与现代的图形接口兼容。例如，程序清单3.10在某些Macintosh的实现中就无法正常运行。\n程序清单3.10 escape.c程序\n12345678910111213&#x2F;* escape.c -- 使用转移序列 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　salary;    printf(&quot;\\aEnter your desired monthly salary:&quot;);　&#x2F;* 1 *&#x2F;    printf(&quot; $_______\\b\\b\\b\\b\\b\\b\\b&quot;);　　　　　　　 &#x2F;* 2 *&#x2F;    scanf(&quot;%f&quot;,　&amp;salary);    printf(&quot;\\n\\t$%.2f　a　month　is　$%.2f　a　year.&quot;,　salary,    salary * 12.0);　　　　　　　　　　　　　　&#x2F;* 3 *&#x2F;    printf(&quot;\\rGee!\\n&quot;);　　　　　　　　　　　　　　　 &#x2F;* 4 *&#x2F;    return　0;&#125;程序运行情况假设在系统中运行的转义序列行为与本章描述的行为一致（实际行为可能不同。例如，XCode 4.6把\\a、\\b和\\r显示为颠倒的问号），下面我们来分析这个程序。\n第1条printf()语句（注释中标为1）发出一声警报（因为使用了\\a），然后打印下面的内容：\n1Enter your desired monthly salary:因为printf()中的字符串末尾没有\\n，所以光标停留在冒号后面。\n第2条printf()语句在光标处接着打印，屏幕上显示的内容是：\n1Enter your desired monthly salary: $_______冒号和美元符号之间有一个空格，这是因为第2条printf()语句中的字符串以一个空格开始。7个退格字符使得光标左移7个位置，即把光标移至7个下划线字符的前面，紧跟在美元符号后面。通常，退格不会擦除退回所经过的字符，但有些实现是擦除的，这和本例不同。\n假设键入的数据是4000.00（并按下Enter键），屏幕显示的内容应该是：\n1Enter your desired monthly salary: $4000.00键入的字符替换了下划线字符。按下Enter键后，光标移至下一行的起始处。\n第3条printf()语句中的字符串以\\n``\\t开始。换行字符使光标移至下一行起始处。水平制表符使光标移至该行的下一个制表点，一般是第9列（但不一定）。然后打印字符串中的其他内容。执行完该语句后，此时屏幕显示的内容应该是：\n12Enter　your　desired　monthly　salary:　$4000.00$4000.00　a　month　is　$48000.00　a　year.因为这条printf()语句中没有使用换行字符，所以光标停留在最后的点号后面。\n第4条printf()语句以\\r开始。这使得光标回到当前行的起始处。然后打印Gee!，接着\\n使光标移至下一行的起始处。屏幕最后显示的内容应该是：\n12Enter　your　desired　monthly　salary:　$4000.00Gee!　$4000.00　a　month　is　$48000.00　a　year.刷新输出printf()何时把输出发送到屏幕上？最初，printf()语句把输出发送到一个叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。C 标准明确规定了何时把缓冲区中的内容发送到屏幕：  \n当缓冲区满、遇到换行字符或需要输入的时候（从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区）。\n\n例如，前两个 printf()语句既没有填满缓冲区，也没有换行符，但是下一条 scanf()语句要求用户输入，这迫使printf()的输出被发送到屏幕上。\n\n旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新缓冲区。代码应改为：1printf(&quot;Enter your desired monthly salary:\\n&quot;);\nscanf(&quot;%f&quot;, &amp;salary);无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光标移至下一行起始处，用户无法在提示内容同一行输入数据。还有一种刷新缓冲区的方法是使用fflush()函数，详见其他章。\n关键概念C语言提供了大量的数值类型，目的是为程序员提供方便。那以整数类型为例，C认为一种整型不够，提供了有符号、无符号，以及大小不同的整型，以满足不同程序的需求。\n计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别。即使两个32位存储单元储存的位组合完全相同，但是一个解释为float类型，另一个解释为long类型，这两个相同的位组合表示的值也完全不同。\n例如，在PC中，假设一个位组合表示float类型的数256.0，如果将其解释为long类型，得到的值是113246208。C语言允许编写混合数据类型的表达式，但是会进行自动类型转换，以便在实际运算时统一使用一种类型。\n计算机在内存中用数值编码来表示字符。美国最常用的是ASCII码，除此之外C也支持其他编码。字符常量是计算机系统使用的数值编码的符号表示，它表示为单引号括起来的字符，如&#39;A&#39;。\n本章小结C 有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类型。通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。最小的整数类型是char，因实现不同，可以是有符号的char或无符号的char，即unsigned char或signed char。但是，通常用char类型表示小整数时才这样显示说明。其他整数类型有short、int、long和long long类型。\nC规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用unsigned关键字创建相应的无符号类型：unsigned short、unsigned int、unsigned long和unsigned long long。或者，在类型名前加上signed修饰符显式表明该类型是有符号类型。最后，_Bool类型是一种无符号类型，可储存0或1，分别代表false和true。\n浮点类型有3种：float、double和C90新增的long double。后面的类型应大于或等于前面的类型。有些实现可选择支持复数类型和虚数类型，通过关键字_Complex和_Imaginary与浮点类型的关键字组合（如，double _Complex类型和float _Imaginary类型）来表示这些类型。\n整数可以表示为十进制、八进制或十六进制。0前缀表示八进制数，0x或0X前缀表示十六进制数。例如，32、040、0x20分别以十进制、八进制、十六进制表示同一个值。l或L前缀表明该值是long类型， ll或LL前缀表明该值是long long类型。\n在C语言中，直接表示一个字符常量的方法是：把该字符用单引号括起来，如&#39;Q&#39;、&#39;8&#39;和&#39;$&#39;。C语言的转义序列（如，&#39;\\n&#39;）表示某些非打印字符。另外，还可以在八进制或十六进制数前加上一个反斜杠（如，&#39;\\007&#39;），表示ASCII码中的一个字符。\n浮点数可写成固定小数点的形式（如，9393.912）或指数形式（如，7.38E10）。C99和C11提供了第3种指数表示法，即用十六进制数和2的幂来表示（如，0xa.1fp10）。\nprintf()函数根据转换说明打印各种类型的值。转换说明最简单的形式由一个百分号（%）和一个转换字符组成，如%d或%f。\n","plink":"https://dxsummer.gitee.io/posts/e51e6bb3/"},{"title":"hexo详解","date":"2020-04-17T07:40:55.000Z","date_formatted":{"ll":"2020年4月17日","L":"2020/04/17","MM-DD":"04-17"},"updated":"2020-06-08T01:50:39.837Z","content":"hexo你的博客 待修改一直纠结于哪里写博客，曾用过新浪博客，百度空间，JavaEye，LOFTER，OSChina，cnblogs，CSDN，自搭WordPress，都不满意。再后来也弄过Jekyll和Octopress，觉累不爱。\n直到多看了一眼hexo，这个逼格极高的程序猿写作方式，我喜欢。就连hexo的发音都像是黑客哦！如果你跟我一样纠结哪里写博，那就来到GitHub吧，让我们一起hexo！H人希绝对不会让你失望，相信很快hexo就会流行起来。\nhexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ Hexo颯爽登場。\n如果你对默认配置满意，只需几个命令便可秒搭一个hexo。如果你跟我一样喜欢折腾下，30分钟也足够个性化。如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。搭建过程你或许觉得有那么点小繁琐，但一旦搭建完成，写文章是极简单，极舒服的。\n只需要几个简单命令，你就可以完成一切。\nhexo n #写文章hexo g #生成hexo d #部署 # 可与hexo g合并为 hexo d -g\n下面逐步介绍，进入正题。\n环境准备安装Node到Node.js官网下载相应平台的最新版本，一路安装即可。我用的是node-v0.10.22-x86.msi\n安装GitGit的客户端很多，我用的是msysgit，喜欢用绿色版本Portable application for official Git for Windows 1.8.4，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n安装Sublime（可选）Sublime Text 2在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的Sublime Text 3。我用绿色版本Portable Sublime Text 2.0.2.zip。\n本屌是穷码畜，对于高大上的Mac码帅用户请移步：hexo installation\nGitHubGitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。\n首先注册一个『GitHub』帐号，已有的默认默认请忽略建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』my GitHub Pagesmy GitHub Pages\n前两步忽略，只说第三步，添加SSH-Key。\n首先设置你的用户名密码：\ngit config –global user.email “bu.ru@qq.com“git config –global user.name “bruce-sha”\n生成密钥：\nssh-keygen -t rsa -C “bu.ru@qq.com“\n输入文件路径：\nH:\\hexo\\blog&gt;ssh-keygen -t rsa -C “bu.ru@qq.com“Generating public/private rsa key pair.Enter file in which to save the key (//.ssh/id_rsa): H:\\git\\myssh\\sshEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in H:\\git\\myssh\\ssh.Your public key has been saved in H:\\git\\myssh\\ssh.pub.The key fingerprint is:b0:0c:2e:67:33:ab:c1:50:10:40:0a:ba:c1:80:59:22 bu.ru@qq.com\n有个bug，文件路径中的盘符H必须大写，否则会报错。\n上述命令若执行成功，会在H:\\git\\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步：\n用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key将id_rsa和id_rsa.pub拷贝至你Git安装目录下的.ssh目录，如H:\\PortableGit-1.8.4.sshAdd SSH KeysAdd SSH Keys\n最后可以验证一下：\nssh -T git@github.com\n若有问题，请重新设置。常见错误请参考：GitHub Help - Generating SSH KeysGitHub Help - Error Permission denied (publickey)\n安装Node和Git都安装好后，可执行如下命令安装hexo：\nnpm install -g hexo\n初始化然后，执行init命令初始化hexo到你指定的目录：\nhexo init 也可以cd到目标目录，执行hexo init。\n好啦，至此，全部安装工作已经完成！\n生成静态页面cd 到你的init目录，执行如下命令，生成静态页面至hexo\\public\\目录。\nhexo generate\n命令必须在init目录下执行，否则不成功，但是也不报错。当你修改文章Tag或内容，不能正确重新生成内容，可以删除hexo\\db.json后重试，还不行就到public目录删除对应的文件，重新生成。\n本地启动执行如下命令，启动本地服务，进行文章预览调试。\nhexo server\n浏览器输入http://localhost:4000就可以看到效果。\n请使用高级浏览器，否则可能…你懂的！\n写文章执行new命令，生成指定名称的文章至hexo\\source_posts\\postName.md。\nhexo new [layout] “postName” #新建文章\n其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md\ntitle: { { title } }date: { { date } }tags:\n\n请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：\ntitle: { { title } }date: { { date } }categories:tags: \n\npostName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。\n注意，所有文件：后面都必须有个空格，不然会报错。\n看一下刚才生成的文件hexo\\source_posts\\postName.md，内容如下：\ntitle: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格\n\n这里开始使用markdown格式输入你的正文。\n接下来，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章Markdown简明语法。\nfancybox可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：\nlayout: phototitle: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:\nhttp://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\nhttp://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n经过测试，文件头上的layout: photo可以省略。\n不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md\nlayout: { { layout } }title: { { title } }date: { { date } }tags:photos: \n\n–\n然后每次可以执行带layout的new命令生成照片文章：\nhexo new photo “photoPostName” #新建照片文章\ndescriptionmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。\ntitle: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述\n\nhexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。\n文章摘要在需要显示摘要的地方添加如下代码即可：\n以上是摘要\n以下是余下全文\nmore以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。\nhexo中所有文件的编码格式均是UTF-8。\n主题安装萝卜白菜各有所爱，玩博客换主题是必不可少的，hexo的主题列表Hexo Themes。我比较喜欢pacman，modernist、ishgo，raytaylorism。Pacman最为优秀，简洁大方小清新，同时移动版本支持的也很好，但作者并没有把很多参数分离出来给出可配置项，我最终选择了modernist。\n安装主题的方法就是一句git命令：\ngit clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n目录是否是modernist无所谓，只要与_config.yml文件一致即可。\n安装完成后，打开hexo_config.yml，修改主题为modernist\ntheme: modernist\n打开hexo\\themes\\modernist目录，编辑主题配置文件_config.yml：\nmenu: #配置页头显示哪些菜单\nHome: /  Archives: /archives  Reading: /reading  About: /about\nGuestbook: /aboutexcerpt_link: Read More #摘要链接文字archive_yearly: false #按年存档\nwidgets: #配置页脚显示哪些小挂件\ncategory- tag\ntagcloud\nrecent_posts- blogroll\nblogrolls: #友情链接\nbruce sha’s duapp wordpress: http://ibruce.duapp.com\nbruce sha’s javaeye: http://buru.iteye.com\nbruce sha’s oschina blog: http://my.oschina.net/buru\nbruce sha’s baidu space: http://hi.baidu.com/iburu\nfancybox: true #是否开启fancybox效果\nduoshuo_shortname: buru #多说账号\ngoogle_analytics:rss:\n更新主题\ncd themes/modernistgit pull\n评论框静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用多说。直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置-&gt;域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以参考这里，我是在HeroicYang的基础上修改的。\n如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\\themes\\modernist\\layout_partial\\comment.ejs里面，如下：\n&lt;% if (config.disqus_shortname &amp;&amp; page.comments){ %&gt;\n\n  #你的通用代码\n自定义页面执行new page命令\nhexo new page “about”\n在hexo\\source\\下会生成about目录，里面有个index.md，直接编辑就可以了，然后在主题的_config.yml中将其配置显示出来。上述步骤，也可以手工生成，在hexo\\source\\下手工新建about和index.md也是完全等价的。\n因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。\n404页面GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。其实，404页面可以做更多有意义的事，来做个404公益项目吧。现在，看下我的404页面一个ibruce.info上不存在的页面，做点有意义的事情，也对得起这个域名。目前有如下几个公益404接入地址，我选择了腾讯的。404页面，每个人可以做的更多。\n腾讯公益404404公益_益云(公益互联网)社会创新中心失蹤兒童少年資料管理中心404图床考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。\n免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，不够的话点这个活动页面，也可通过邀请好友获得奖励，我也求一下七牛邀请。有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于key-value存储系统。\n七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇Linux中国采用七牛云存储支撑图片访问。\n如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。\n如果你对七牛web版的文件管理界面不满意，可以用官方的七牛云存储工具。\n您还可以使用如下图床服务 FarBox，Dropbox，又拍云。\n申请域名（可选）GitHubPages默认为每个用户分配了一个二级域名『your_user_name.github.com』或『your_user_name.github.io』。如果你对上述域名不满意，可以到狗爹上申请一个自己的域名，然后绑定到GitHub Pages。绑定方法很简单，在repo根目录下建立一个CNAME文件，里面写上域名即可。\nGoDaddy买域名首选狗爹，国内的服务商大家都懂的。目前.info域名只要￥18.99，但据说续费比较贵，我是先玩下，一年后再换，至于搜索引擎重新索引之类的，无所谓。.me和.com域名稍微贵点，大约￥60-100，网上有很多优惠码可用，可惜有的优惠码有限制。比如有个.com域名优惠码只要$1.99，但只能用国外信用卡购买。更多优惠码可以自行谷歌或到独特优惠码找。不着急的同学可以将中意的域名加入购物车先不付款，过几天，狗爹就会发优惠信息给你。狗爹不定期也会有活动，可以多关注。付款后，需要稍微等一会你才会拿到域名，特别是支付宝付款的，要等大约半小时左右。此外域名要一年年的买，这样比较划算。\n建议大家申请.com或.me域名。据说.info因垃圾网站太多，被搜索引擎惩罚，而且续费较贵。\nDNSPodGoDaddy的NameServers有时会被墙，因此墙裂推荐国内的DNSPod解析域名，免费服务真心不错。支持微信/邮件提醒，监控与报警，访问统计，健康诊断，搜索引擎推送，速度哇哇的，对于我来说足够。两步设置就可以搞定，怎么操作参考Godaddy注册商域名修改DNS地址。\n命令常用命令：\nhexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub\n常用复合命令：\nhexo deploy -ghexo server -g\n简写：\nhexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy\n##至此，基本操作介绍完毕，以下内容普通用户无需了解。目录介绍默认目录结构：\n.├── .deploy├── public├── scaffolds├── scripts├── source|   ├── _drafts|   └── _posts├── themes├── _config.yml└── package.json.deploy：执行hexo deploy命令部署到GitHub上的内容目录public：执行hexo generate命令，输出的静态网页内容目录scaffolds：layout模板文件目录，其中的md文件可以添加编辑scripts：扩展脚本目录，这里可以自定义一些javascript脚本source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。_drafts：草稿文章_posts：发布文章themes：主题文件目录_config.yml：全局配置文件，大多数的设置都在这里package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮接下来是重头戏_config.yml，做个简单说明：\nHexo ConfigurationDocs: http://zespia.tw/hexo/docs/configure.htmlSource: https://github.com/tommy351/hexo/Site #整站的基本信息title: 不如 #网站标题subtitle: 码农，程序猿，未来的昏析师 #网站副标题description: bruce sha’s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到author: bruce #网站作者，在下方显示email: bu.ru@qq.com #联系邮箱language: zh-CN #语言\nURL #域名和文件结构If your site is put in a subdirectory, set url as ‘http://yoursite.com/child&#39; and root as ‘/child/‘url: http://ibruce.info #你的域名root: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code\nWriting #写文章选项new_post_name: :title.md # File name of new postsdefault_layout: post #默认layout方式auto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabmax_open_file: 100multi_thread: truefilename_case: 0render_drafts: falsehighlight: #代码高亮  enable: true #是否启用  line_number: false #是否显示行号  tab_replace:\nCategory &amp; Tag #分类与标签default_category: uncategorized # defaultcategory_map:tag_map:\nArchives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突2: Enable pagination1: Disable pagination0: Fully Disablearchive: 1category: 1tag: 1\nServer #本地服务参数Hexo uses Connect as a serverYou can customize the logger format as defined inhttp://www.senchalabs.org/connect/logger.htmlport: 4000logger: truelogger_format:\nDate / Time format #日期显示格式Hexo uses Moment.js to parse and display dateYou can customize the date format as defined inhttp://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss\nPagination #分页设置Set per_page to 0 to disable paginationper_page: 10 #每页10篇文章pagination_dir: page\nDisqus #社会化评论disqus，我使用多说，在主题中配置disqus_shortname:\nExtensions #插件，暂时未安装插件Plugins: https://github.com/tommy351/hexo/wiki/PluginsThemes: https://github.com/tommy351/hexo/wiki/Themes主题theme: modernist # raytaylorism # pacman # modernist # lightexclude_generator:\nDeployment #部署Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy:  type: github  repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库修改局部页面页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\你使用的主题\\中，以modernist主题为例：\n.├── languages          #多语言|   ├── default.yml    #默认语言|   └── zh-CN.yml      #中文语言├── layout             #布局，根目录下的.ejs文件是对主页，分页，存档等的控制|   ├── _partial       #局部的布局，此目录下的.ejs是对头尾等局部的控制|   └── _widget        #小挂件的布局，页面下方小挂件的控制├── source             #源码|   ├── css            #css源码|   |   ├── _base      #.styl基础css|   |   ├── _partial   #.styl局部css|   |   ├── fonts      #字体|   |   ├── images     #图片|   |   └── style.styl #*.styl引入需要的css源码|   ├── fancybox       #fancybox效果源码|   └── js             #javascript源代码├── _config.yml        #主题配置文件└── README.md          #用GitHub的都知道\n如果你需要修改头部，直接修改hexo\\themes\\modernist\\layout_partial\\header.ejs，比如头上加个搜索框：\n\n\n \n \n\n将如上代码加入即可，您需要修改css以便这个搜索框比较美观。\n再如，你要修改页脚版权信息，直接编辑hexo\\themes\\modernist\\layout_partial\\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。\n统计页面上显示访问次数可以使用 不蒜子，两行代码即可搞定。\n因Google Analytics偶尔被墙，故用百度统计，以modernist主题为例，介绍如何添加。编辑文件hexo\\themes\\modernist_config.yml，增加配置选项：\nbaidu_tongji: true\n新建文件hexo\\themes\\modernist\\layout_partial\\baidu_tongji.ejs，内容如下：\n&lt;% if (theme.baidu_tongji){ %&gt;\n\n#你的百度统计代码\n&lt;% } %&gt;\n注册并登录百度统计获取你的统计代码。\n编辑文件hexo\\themes\\modernist\\layout_partial\\head.ejs，在『/head』之前增加：\n&lt;%- partial(‘baidu_tongji’) %&gt;\n重新生成并部署你的站点。\n不出意外的话，在你的站点的每个页面的左上角都会看到一个恶心的百度LOGO。你只能在『百度统计首页-&gt;网站列表-&gt;获取代码-&gt;系统管理设置-&gt;统计图标设置-&gt;显示图标』，把那个勾去掉。百度真是恶心，我准备还是用Google Analytics。\n分享我没有添加分享，觉得这个不是很必要，导致页面看起来啰嗦。以加网为例介绍如何添加：\n在hexo\\themes\\modernist\\layout_partial\\post下新建jiathis.ejs文件。注册加网获得你的分享代码，写入jiathis.ejs。在hexo\\themes\\modernist\\layout_partial\\article.ejs中，添加&lt;%-partial(‘post/jiathis’)%&gt;。分享服务还可以使用如下企业提供的技术加网，bShare，百度分享。\n网站图标看一下hexo\\themes\\modernist\\layout_partial\\head.ejs，找到这句：\n你懂的，将你的favicon.ico放到工程根目录下即可，也就是hexo\\source目录。可以在Faviconer制作你的ico图标，国内有比特虫。\n自定义挂件除了默认已提供的挂件外，你还可以自定义自己的小挂件，在hexo\\themes\\modernist\\layout_widget\\下，新建自己的ejs文件，如myWidget.ejs，然后在配置文件hexo\\themes\\modernist_config.yml中配置。\nwidgets:\nmyWidget\n用上述方法可以添加新浪微博小挂件。\n生成自己的微博组件。添加hexo\\themes\\modernist\\layout_widget\\weibo.ejs文件。配置hexo\\themes\\modernist_config.yml。插件安装插件：\nnpm install  –save\n启用插件：在*hexo_config.yml文件添加：\nplugins:\n  #插件名\n升级插件：\nnpm update\n卸载插件：\nnpm uninstall \nRSS插件将上述命令中的『plugin-name』，替换为hexo-generator-feed。一旦安装完成，你可以在配置显示你站点的RSS，文件路径\\atom.xml。\n你可以用rss作为迁移工具，用如下命令读取其他位置的rss：\nhexo migrate rss \n『source』是本地或网络文件路径。\nSitemap插件将上述命令中的『plugin-name』，替换为hexo-generator-sitemap。你可以将你站点地图提交给搜索引擎，文件路径\\sitemap.xml。\n更多插件的安装方法，请参考官方Wiki。\n如果你按照上述步骤做，但插件不起作用，没有生成atom.xml和sitemap.xml，也没有报错，那么你应该cd到你的hexo初始化目录，在该目录下重新安装插件，重试。\n迁移hexo支持从其他类型站点迁移，如通用RSS，Jekyll，Octopress，WordPress等，这一部分我没试过。请参考官方文档Hexo Migration。\n搜索引擎你可以到屈站长提交你的站点给搜索引擎。其他内容如添加站点或页面的description，提交Sitemap，添加百度统计，Google Analytics等等，参考本文其他章节的内容，不再一一阐述。\n更新更新hexo：\nnpm update -g hexo\n更新主题：\ncd themes/你的主题git pull\n更新插件：\nnpm update\n干掉IEKill IE6 提示的javascript代码，请自行搜索。\n换机器你要保留好自己的博客源码。换机器写博客，就只能使用各种网盘的同步功能，或者你把你的站点源文件提交到某代码托管服务器。另外，貌似这篇很牛逼，Hexo 服务器端布署及 Dropbox 同步。\n我的办法是这样的，先在一个目录下做好Node+Git+Hexo的绿色环境，写个hexos.bat可以一键启动hexo工作台，把整个目录用Dropbox同步，这样随便在办公室或家的任何笔记本台式机都可以写博客，也不用处理什么文件拷贝备份的事情，非常爽。\n统计功能为hexo博客添加访问次数统计功能\n其它网站加速Webluker-CDN 网站加速 免费CDN DNS解析Webluker-FAQ索引\n网站监控监控宝-网站监控 网页监控 服务器监控监控宝-常见问题\nDNSPod本身就有D监控可用。\n站长工具谷歌站长工具百度站长工具站长之家工具360搜索站长平台360网站安全检测奇云测360云监控\nSEO谷歌搜索引擎优化初学者指南.PDF\n数据统计不蒜子百度统计Google Analytics\n企业邮箱腾讯企业邮箱在DNSPod域名解析商处如何设置企业邮箱\n图片生成邮箱地址生成图片MakePic.com邮址图片生成\n徽章生成Logo CreatrWeb 2.0 Logo Creator (可能需翻墙)\nfavicon制作Favicon制作\n文章推荐/猜你喜欢无觅关联推荐友荐乐知推荐百度推荐\n广告百度联盟\n不足配置文件缺少空格会报错报错不能得到精确定位，只能靠经验换台机器写文章不好处理如何统计总来访数和单页文章阅读次数，请参考为hexo博客添加访问次数统计功能。结束我的博客『ibruce.info』基本算是免费做出来的，为报答开源社区，特写这篇文章，由于水平有限，错误之处在所难免，请诸位多多包涵，不吝指点。\n在此一并感谢GitHub，Hexo，Modernist，七牛，多说，公益404，GoDaddy，DNSPod，百度统计，Google Analytics，以及Node.js，MSYSGit，Sublime Text 2，最后感谢Markdown。\n关于以上内容的任何问题，您都可以对 bruce 留言或邮件 bu.ru@qq.com。\nps：（2014年12月 更新）当本地调试出现诡异现象时候，请先使用 hexo clean 清理已经生成的静态文件后重试。GitHub官方之前发邮件给用户，已经不建议使用A记录指向静态ip了，建议CNAME指向你的GitHub Pages URL。如果你申请了自己的域名，您可以使用 DNSPod+QQ域名邮箱 打造自己的专属邮箱，比如我的 me@ibruce.info，是不是逼格又提高了一丁点？添加 Fork me on Github 彩带，请戳 http://github.com/blog/273-github-ribbons 。注意看本页最下方的访问次数统计，这不是一个普通的计数器，这个计数器骨骼精奇天赋异禀，他是实时的！你打开两个浏览窗口，只刷新一个窗口另一个窗口的数字会自动实时变化的，有点意思吧？怎么做的呢，先上个图，当然，这张看板的全部内容也都是实时动态变化着的 ^_^countercounter\nps：（2015年4月 更新）折腾了两天，终于搞定GitHub不间断被墙导致网站无法访问的问题。方法就是GitHub作为主站，GitCafe作为备份。因为我的hexo版本很低，不得不先升级到hexo3，各种坑，不建议升级，最后自己修改主题，又是各种坑，快累尿了。号外号外：最新的统计服务已经开放，两行代码轻松搞定，你可以直接使用：不蒜子 微服务，本人墙裂推荐，只需要两行代码哦。各种用法实例和显示效果参考不蒜子文档中的实例链接。不蒜子，极客的算子，极简的算子，任你发挥的算子。参考文献Hexo使用Hexo在Github上搭建个人博客hexo教程hexo系列教程：（四）hexo博客的优化技巧hexo系列教程：（五）hexo博客的优化技巧续折腾了个新主题使用hexo搭建博客从Octopress到Hexo搞定HexoHello World by Hexohexo的代码高亮用Hexo快速打造静态博客使用Sublime Text 2 编辑Markdown给hexo添加一个404页面GotGitHub搭建一个免费的，无限流量的Blog — github Pages和Jekyll入门Godaddy注册商域名修改DNS地址WordPress中使用七牛云存储加速图片等静态文件访问速度怎样搭建一个自有域名的WordPress博客Hexo服务器端布署及Dropbox同步\n","plink":"https://dxsummer.gitee.io/posts/5c0dd025/"},{"title":"hexo搭建+Butterfly主题配置","date":"2020-04-15T07:01:53.000Z","date_formatted":{"ll":"2020年4月15日","L":"2020/04/15","MM-DD":"04-15"},"updated":"2020-06-08T01:59:03.487Z","content":"Hexo基本操作手册此贴 结合简书 俗俗俗俗俗人 与 Butterfly制作人——JerryC 以及 Emil等前辈的经验，方便后人的学习。在此感谢 俗俗俗俗俗人  JerryC  Emil等各位前辈若有问题 请于我留言安装安装Node.js左边的是稳定版本，右边的是最新版双击运行安装包，然后去命令行123node -v# 这时候会出现你的版本号v10.16.3，安装成功&#96;安装Git\n1brew install gitbrew又不知道了？[○･｀Д´･ ○] 别太过分！ 戳这里到brew官网\n安装Hexo1npm install -g hexo-cli官方这里也提到，如果系统未安装Xcode会遇到问题，这时候去Mac的应用商店搜索\n建立博客123hexo init &lt;你所放置的文件地址&gt;cd &lt;你所放置的文件地址&gt;npm install此时你就会看到以下的目录结构\n这就是基础的目录了这里就介绍几个关键的文件和文件夹\n_config.yml网站的配置的信息都存储在这里面，很关键的文件，文章后面会做到详细阐述\nsource这里面是存放用户资源的地方，什么意思呢？也就是博客内容都放在这里面进到目录中，就会发现有一个 _post文件夹 ，这个文件夹就是之后的文档主要文件。\nthemes主题文件夹，放心，之后恶心你的大部分地方都在这里面！\nhexo常用的命令新建文章1hexo new &lt;文章标题&gt; # 可以简写hexo n &lt;文章标题&gt;生成静态文件由于Hexo是用Node.js来进行页面渲染，所以需要生成对应的静态文件\n1hexo generate # 可以简写hexo g启动本地服务器每篇文章总得查看无论是编排、内容，所以我们需要测试，这时候我们就需要本地服务了\n1hexo server # 可以简写hexo s但是运行之前需要确保已经安装 hexo-server 插件\n1npm install hexo-server --save此时服务器就会开启4000端口供你使用，但是可能你的服务器端口被占用了，会提示以下错误\n1FATAL Port 4000 has been used. Try other port instead.此时你需要切换一个端口\n1hexo s -p 5000 # -p 是可以指定端口的操作部署网站辛辛苦苦打理了这么久的博客，不上传到服务器上展（zhuang）示（bi）一下，怎么对得起自己\n1hexo deploy # 可以简写 hexo d这里涉及到几个知识点\n\n需要先渲染博客，也就是hexo g（可以hexo g -d一步操作）还需要配置博客目录下 _config.yml 文件中的deploy模块\n\n12345# 之后会教大家如何操作deploy:    type: git    repo: &lt;git地址&gt;    branch: master其余的命令实际上用到真的不多，万一需要，百度就可以了\n安装主题戳这里到Hexo的插件库\n该博客的主题hexo-theme-butterfly 是基于Molunerfinn的hexo-theme-melody的基础上进行开发的。\n安装hexo-theme-butterfly在博客的根目录\n1git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly或者想用最新的分支的话\n1git clone -b dev https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly替换主题博客根目录\n1打开config.yml然后将\n1theme: Butterfly博客配置文章front-matter12345678910111213title:date:tags:categories:keywords:description:top_img: （除非特定需要，可以不寫）comments: 是否展示评论系统（true.展示 false.不展示）description: 节选，如果不填就默认从文章中选择配置的长度cover:  首页缩略图toc:  是否显示toctoc_number: 是否显示toc数字copyright: 是否显示版权1234# 节选内容auto_excerpt:  enable: true  length: 150系统中英文替换替换主题后你会发现首页的菜单一开始是英文名字，或者不是自己想要的样子，怎么办？配置 _config.yml\n1language: zh-CN12# 进入主题文件夹cd themes&#x2F;Butterfly会发现这里也有一个 _config.yml 文件，这个文件是掌管整套系统主题相关的配置，个人觉得重要程度的比重要比前面博客根目录的同名文件要重要，当然缺一不可。\n编辑这个文件\n123456789101112# 可以像俗人一样把原本的英文名修改成中文，这样就会完全解决切换不彻底问题menu:  首页: &#x2F; || fa fa-home  时间轴: &#x2F;archives&#x2F; || fa fa-archive  留言板: &#x2F;message&#x2F; || fa fa-coffee  标签: &#x2F;tags&#x2F; || fa fa-tags  分类: &#x2F;categories&#x2F; || fa fa-folder-open  链接: &#x2F;link&#x2F; || fa fa-link  关于: &#x2F;about&#x2F; || fa fa-heart  列表||fa fa-list:    - 音乐 || &#x2F;music&#x2F; || fa fa-music    - 视频 || &#x2F;movies&#x2F; || fa fa-film这里如果需要新增菜单栏目的话，记得这样的规律\n名称 || 路径 || icon新增菜单此时发现点击页面都是空白\n这时候就需要新增页面的操作了，但是注意这里的新增和新增文章不同，这里需要加上分类\n12# 新增标签hexo new page tags在博客的根目录访问\n1source&#x2F;tags&#x2F;index.md发现这是一个文档文件\n是的，基本上大同小异，但是要注意，由于主题的底层已经加上了对该页面的效果，所以需要遵循命名规范后修改文档\n123title: 标签date: 2019-10-01 10:00:00type: &quot;tags&quot;此时首页的标签按钮已经展示对应的页面内容了，其余的页面同理。\n友情链接前往你的Hexo根目录\n输入 hexo new page link\n找到 source/link/index.md 这个文件\n编辑这个文件123title: 链接date: 2019-10-01 10:00:00type: &quot;link&quot;注意，主题中配置友情链接的位置不是在该文件本身，而是需要你去 创建 source/_data目录，并且新建文件 link.yml12345678910111213class:  class_name: 友情链接  link_list:    1:      name: 名称      link: 地址      avatar: 头像      descr: 描述    #2:    #  name: xxxxxx    #  link: https:&#x2F;&#x2F;www.xxxxxxcn&#x2F;    #  avatar: https:&#x2F;&#x2F;xxxxx&#x2F;avatar.png    #  descr: xxxxxxx\n同时，可以在themes/Butterfly/_config.yml文件中，写上个人博客的信息，方便他人帮忙转载\n12345678Flink:  headline: 友情链接  info_headline: 我的Blog资料  name: Blog 名字： Dx  address: Blog 地址： https:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;  avatar: Blog 头像： https:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;img&#x2F;avatar.png  info: Blog 简介： 生命不息,折騰不止|  comment: 如果需要交换链接，请给我留言，谢谢~代码高亮Butterfly支持五种高亮样式：\ndefault\ndarker\npale night\nlight\nocean\n配置 _config.yml\n1highlight_theme: light复制配置 _config.yml\n12345678910111213# Highlight theme# ---------------highlight_theme: lighthighlight_copy: true    #代碼複製按鈕highlight_lang: true     #代碼語言顯示highlight_shrink: false #代碼框不展開，需點擊 &#39;&gt;&#39; 打開# copy setting# 是否禁止複製（如果禁止，highlight_copy的功能將無效)# copyright 複製的内容後面加上版權信息copy:  enable: true  # true 開啓 &#x2F; false 禁止  copyright: true换行在默认情况下，配置中是不开启换行功能的，如果不希望在代码中有横向滚动条，可以开启这个功能。配置 _config.yml\n123456code_word_wrap: truehighlight:  enable: true  line_number: false  auto_detect: false  tab_replace:社交图标戳这里到对应的图标中心\n配置 _config.yml\n1234social:  fa fa-weixin: http:&#x2F;&#x2F;iblog.thatwang.com&#x2F;qrcode_for_gh_706ce3f91494_258.jpg  fa fa-weibo: http:&#x2F;&#x2F;weibo.cn&#x2F;wordpole9981  fa fa-qq: https:&#x2F;&#x2F;jq.qq.com&#x2F;?_wv&#x3D;1027&amp;k&#x3D;5E3IUHu文章版权配置 _config.yml\n1234post_copyright:  enable: true  license: CC BY-NC-SA 4.0  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;是否开启版权\n1copyright: false文章打赏配置 _config.yml\n123456789reward:  enable: true  QR_code:    - itemlist:        img: &#x2F;img&#x2F;wechat.jpg        text: 微信    - itemlist:        img: &#x2F;img&#x2F;alipay.jpg        text: 支付宝头像配置 _config.yml\n1avatar: https:&#x2F;&#x2F;xxxx&#x2F;avatar.png文章目录配置 _config.yml\n123toc:  enable: true  number: true  # 显示章节数字相关文章配置 _config.yml\n123related_post:  enable: true  limit: 6         # 显示推荐文章数量博客年份配置 _config.yml\n1since: 2018页脚配置 _config.yml\n1footer_custom_text: &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.thatwang.com&#x2F;&quot;&gt;Everybody&#39;s good at something.&lt;&#x2F;a&gt;夜间模式Apple都有这模式了，我们也不能输呀\n配置 _config.yml\n12darkmode:  enable: true阅读模式阅读模式会去除文章以外的内容\n配置 _config.yml\n12readmode:  enable: true侧边栏设置配置 _config.yml\n123456789aside:  position: right # left or right  card_author: true  card_announcement: true  card_recent_post: true  card_categories: true  card_tags: true  card_archives: true  card_webinfo: true访问人数配置 _config.yml\n1234busuanzi:  site_uv: true  site_pv: true  page_pv: true运行时间配置 _config.yml\n123456runtimeshow:  enable: true  start_date: 6&#x2F;7&#x2F;2018 00:00:00    ##博客开通时间  # 格式: 月&#x2F;日&#x2F;年 时间  # 也可以写成 年&#x2F;月&#x2F;日 时间相册文章页面编辑以下markdown格式内容\n123&#123;% gallery %&#125;markdown 圖片格式&#123;% endgallery %&#125;评论戳这个leancloud服务\n其实Hexo能支持很多评论系统，但是用下来，就leancloud这个最舒服，最方便\n配置 _config.yml\n123456789101112valine:  enable: true # if you want use valine,please set this value is true  appId: 配置中心查看  # leancloud application app id  appKey: key  # leancloud application app key  notify: false # valine mail notify (true&#x2F;false) https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki  verify: false # valine verify code (true&#x2F;false)  pageSize: 10 # comment list page size  avatar: robohash  # gravatar style https:&#x2F;&#x2F;valine.js.org&#x2F;#&#x2F;avatar  lang: zh-cn # i18n: zh-cn&#x2F;en  placeholder: 来吧，造作吧，快活吧，肆无忌惮吧！(～￣▽￣)～ # valine comment input placeholder(like: Please leave your footprints )  guest_info: nick,mail,link #valine comment header info  bg: &#x2F;img&#x2F;comment_bg.png  # valine background注册登录\n创建应用\n获取key\n此时就安装好了评论系统，就这么简单\n音乐同样是使用leancloud服务\n前面的注册逻辑与评论一样，接下来就是存储环节\n加入单条音乐播放器的页面\n1&#123;% aplayer &quot;可以了&quot; &quot;陈奕迅&quot; &quot;https:&#x2F;&#x2F;xxx.xxx.com&#x2F;92b3af330d2274b1fa55.mp3&quot; &quot;https:&#x2F;&#x2F;xxx.xxx.com&#x2F;xx.png&quot; &quot;autoplay&quot; %&#125;加入列表音乐播放器的页面\n1&#123;% aplayerlist %&#125;&#123;&quot;narrow&quot;: false,&quot;autoplay&quot;: true,&quot;showlrc&quot;: 3,&quot;mode&quot;: &quot;random&quot;,&quot;music&quot;: [&#123;&quot;title&quot;: &quot;美好事物&quot;,&quot;author&quot;: &quot;房东的猫&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;945198c4909674765644.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;6e0e9e63cb0733f7ff12.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;,&#123;&quot;title&quot;: &quot;尚好的青春&quot;,&quot;author&quot;: &quot;云の泣&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;5b42b829b8ae08ccabe0.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;889df742eca5261f2fc5.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;,&#123;&quot;title&quot;: &quot;预谋邂逅&quot;,&quot;author&quot;: &quot;阿肆&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;1bd4f91441982710bcad.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;f72d61579f74d4ff9ce0.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;]&#125;&#123;% endaplayerlist %&#125;即可\n分享配置 _config.yml\n123sharejs:  enable: true  sites: wechat,weibo,qq搜索安装 hexo-generator-search，根据文档做对应配置\n配置 _config.yml\n12345local_search:  enable: true  labels:    input_placeholder: 试试看能找到啥宝藏吧!    hits_empty: &quot;客官，本店还未提供该服务: $&#123;query&#125;&quot; # if there are no result自定义主题配置 _config.yml\n1234567891011theme_color:   enable: true   main: &quot;#696969&quot;   paginator: &quot;#00c4b6&quot;   button_hover: &quot;#FF7242&quot;   text_selection: &quot;#00c4b6&quot;   link_color: &quot;#99a9bf&quot;   meta_color: &#39;#858585&#39;   hr_color: &quot;#A4D8FA&quot;   read-mode-bg_color: &#39;#FAF9DE&#39;   inline-code-color: &#39;#F47466&#39;打字效果配置 _config.yml\n12activate_power_mode:  enable: true动态彩带配置 _config.yml\n123canvas_ribbon_piao:  enable: true  mobile: false # false 手机端不显示 true 手机端显示背景线条配置 _config.yml\n1234567canvas_nest:  enable: true  color: &#39;0,0,255&#39; #color of lines, default: &#39;0,0,0&#39;; RGB values: (R,G,B).(note: use &#39;,&#39; to separate.)  opacity: 0.7 # the opacity of line (0~1), default: 0.5.  zIndex: -1 # z-index property of the background, default: -1.  count: 99 # the number of lines, default: 99.  mobile: false #  false 手机端不显示 true 手机端显示鼠标点击效果配置 _config.yml\n123456fireworks:  enable: true  # 點擊出現愛心click_heart:  enable: true首页弹幕座右铭配置 _config.yml\n12345678# 主頁subtitle# 打字效果# (如果有英文逗號&#39; , &#39;，請使用轉義字符 &amp;#44;)subtitle:  enable: true  sub:    - 努力不一定能成功&amp;#44;但是永远不会后悔    - Hard work may not always result in success&amp;#44;but it will never result in regret更新优化更新\n设置foot调整页脚高度，去除驱动和主题描述，，修改 By 字母为红色爱心。\n在路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug 下，将 By 替换为以下内容\n12Styl&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n123456789Code.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n自定义字体、鼠标指针样式引用格式\n123@font-face &#123; font-family:MyFont;src: url(https:xxx)&#125;body&#123;font-family:MyFont!important;&#125;\n引用方法：将引用代码添加到 D:\\blog\\themes\\Butterfly\\source\\css\\_third-partynormalize.min.css 末尾即可，鼠标样式亦是如此。\n\n鼠标样式\n\n引用格式123456789body &#123;cursor: url(https:&#x2F;&#x2F;xxx),    default;&#125;a,img &#123;    cursor: url(https:&#x2F;&#x2F;xxx),        default;&#125;\n","plink":"https://dxsummer.gitee.io/posts/10474aaf/"},{"title":"hexo的目录结构","date":"2020-04-13T06:21:52.000Z","date_formatted":{"ll":"2020年4月13日","L":"2020/04/13","MM-DD":"04-13"},"updated":"2020-06-08T01:51:17.822Z","content":"hexo的目录结构效果预览今天来整理一下hexo的目录结构，了解hexo每个目录的作用，并且设置全局配置文件 _config.yml 的相关参数，初步定义属于你自己的博客。我们开始吧.\n主目录结构12345678|-- _config.yml|-- package.json|-- scaffolds|-- source   |-- _posts|-- themes|-- .gitignore|-- package.json主目录介绍_config.yml全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。\npackage.jsonhexo框架的参数和所依赖插件，如下：\n12345678910111213141516171819&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;3.2.0&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^3.2.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;,    &quot;hexo-server&quot;: &quot;^0.2.0&quot;  &#125;&#125;scaffoldsscaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。\nsource这个目录很重要，新建的文章都是在保存在这个目录下的._posts 。需要新建的博文都放在 _posts 目录下。_posts 目录下是一个个 markdown 文件。你应该可以看到一个hello-world.md 的文件，文章就在这个文件中编辑。_posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。\nthemes网站主题目录，hexo有非常好的主题拓展，支持的主题也很丰富。该目录下，每一个子目录就是一个主题，我的子目录如下：\n12|-- landscape  &#x2F;&#x2F;默认主题|-- hexo-theme-next  &#x2F;&#x2F;第三方主题你也可以自己下载主题放到该文件下,hexo主题传送门\n_config.yml文件_config.yml 采用YAML语法格式，具体语法自行学习 。具体配置可以参考官方文档，_config.yml 文件中的内容，并对主要参数做简单的介绍\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Hexo Configuration## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;# Sitetitle: Hexo #网站标题subtitle:   #网站副标题description:  #网站描述author: John Doe  #作者language:    #语言timezone:    #网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America&#x2F;New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: http:&#x2F;&#x2F;yoursite.com   #你的站点Urlroot: &#x2F;                       #站点的根目录permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;   #文章的 永久链接 格式   permalink_defaults:    #永久链接中各部分的默认值# Directory   source_dir: source   #资源文件夹，这个文件夹用来存放内容public_dir: public     #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags         # 标签文件夹     archive_dir: archives    #归档文件夹category_dir: categories      #分类文件夹code_dir: downloads&#x2F;code     #Include code 文件夹i18n_dir: :lang                #国际化（i18n）文件夹skip_render:                #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    # Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post     #预设布局titlecase: false # 把标题转换为 title caseexternal_link: true # 在新标签中打开链接filename_case: 0     #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false  #是否显示草稿post_asset_folder: false  #是否启动 Asset 文件夹relative_link: false      #把链接改为与根目录的相对位址    future: true                #显示未来的文章highlight:                    #内容中代码块的设置      enable: true  line_number: true  auto_detect: false  tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:          #分类别名tag_map:            #标签别名# Date &#x2F; Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;date_format: YYYY-MM-DD         #日期格式time_format: HH:mm:ss        #时间格式    # Pagination## Set per_page to 0 to disable paginationper_page: 10    #分页数量pagination_dir: page  # Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: landscape   #主题名称# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html#  部署部分的设置deploy:       type:  #类型，常用的git\n网站存放在子目录如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。\n\nhexo的目录结构基本介绍完了，具体人配置需要在用的时候在启用。\n完整hexo教程，请访问hexo搭建个人博客\n","plink":"https://dxsummer.gitee.io/posts/48b5ba15/"},{"title":"Markdown教程","date":"2020-04-12T04:41:40.000Z","date_formatted":{"ll":"2020年4月12日","L":"2020/04/12","MM-DD":"04-12"},"updated":"2020-06-08T01:52:30.503Z","content":"Markdown教程1.Markdown标题二级标题三级标题123# 一级标题## 二级标题###三级标题2.段落格式字体斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本\n*斜体文本*  \n_斜体文本_  \n**粗体文本**  \n__粗体文本__  \n***粗斜体文本***  \n___粗斜体文本___分隔线\n\n12-------*******删除线、下划、脚注BAIDU.COM带下划线文本你们好,大家好\n1234~~BAIDU.COM~~   &lt;u&gt;带下划线文本&lt;&#x2F;u&gt;  你们好,[大家好][大家好]: hello3.Markdown列表无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记:  \n无序列表项\n无序列表项\n无序列表项   \n123* 无序列表项* 无序列表项* 无序列表项有序列表有序列表使用数字并加上 . 号来表示\n有序列表1\n有序列表2\n有序列表3\n1231. 有序列表12. 有序列表23. 有序列表3列表嵌套第一项：第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n第二项：第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n1234561. 第一项：- 第一项嵌套的第一个元素- 第一项嵌套的第二个元素2. 第二项：- 第二项嵌套的第一个元素- 第二项嵌套的第二个元素4.Markdown 区块区块引用\n这是一段引用段落，将会被高亮显示最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n1234&gt;这是一段引用段落，将会被高亮显示  &gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套区块中使用列表\n区块中使用列表\n第一项\n第二项  \n第一项\n第二项\n第三项\n\n123456&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项  &gt; + 第一项&gt; + 第二项&gt; + 第三项列表中使用区块第一项\n菜鸟教程学的不仅是技术更是梦想\n\n\n第二项1234* 第一项    &gt; 菜鸟教程      &gt; 学的不仅是技术更是梦想* 第二项\n5.Markdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`）\nprintf() 函数\n1&#96;printf()&#96; 函数代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。  \njavascript\n$(document).ready(function () {\nalert(&apos;RUNOOB&apos;);\n});6.Markdown 链接超链接百度https://www.baidu.com/\n123[超链接名称](链接地址)或&lt;链接地址&gt;高级链接这个链接用 1 作为网址变量 Google这个链接用 runoob 作为网址变量 Runoob然后在文档的结尾为变量赋值（网址）\n123456这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http:&#x2F;&#x2F;www.google.com&#x2F;  [runoob]: http:&#x2F;&#x2F;www.runoob.com&#x2F;7.Markdown 图片图片\n12![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)使用实例：\n12![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png)![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png &quot;RUNOOB&quot;)当然，你也可以像网址那样对图片网址使用变量:  \n123这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）  [1]: http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.pngMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。\n1&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png&quot; width&#x3D;&quot;50%&quot;&gt;8.Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。| Tables        | Are           | Cool  || ————- |:————-:| —–:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |\n12345| Tables        | Are           | Cool  || ------------- |:-------------:| -----:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |对齐方式我们可以设置表格的对齐方式：\n-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。  \n实例如下：\n\n1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |9.Markdown 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：\n1使用 &lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Alt&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Del&lt;&#x2F;kbd&gt; 重启电脑输出结果为：\n转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n12**文本加粗** \\*\\* 正常显示星号 \\*\\*输出结果为：\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n123456789101112\\   反斜线&#96;   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n12345678$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 &#x3D;  \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$输出结果：\n以下几个实例效果图如下：\n1、横向流程图源码格式：\n123456graph LRA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a&#x3D;1| D[结果1]    C --&gt;|a&#x3D;2| E[结果2]    F[横向流程图]2、竖向流程图源码格式：\n123456graph TDA[方形] --&gt; B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt; |a&#x3D;1| D[结果1]    C --&gt; |a&#x3D;2| E[结果2]    F[竖向流程图]3、标准流程图源码格式：\n123456789st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op4、标准流程图源码格式（横向）：\n123456789st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op5、UML时序图源码样例：\n12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？6、UML时序图源码复杂样例：\n1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩7、UML标准时序图样例：\n123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头  sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!8、甘特图样例：\n12345678910111213141516171819%% 语法示例        gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h\n文字色块\nMarkDown 自带的文字高亮，其他方法就看第 3 点\n\n高亮文字\n1&lt;mark&gt;高亮文字&lt;&#x2F;mark&gt;\n利用 HTML 表格标签的 bgcolor 属性来实现文字背景色（整行填充背景），写法如下，文末附有常用颜色表。\n\n这里的背景色是：ForestGreen1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;PowderBlue&gt;这里的背景色是：PowderBlue&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;\n文字色块利用 span 标签赋予样式，引用边框用 p 标签变色。当然编辑器里无法预览效果\n\n黄色色块 绿色色块 蓝色色块 灰色色块 红色色块 紫色色块\n123456&lt;span id&#x3D;&quot;inline-yellow&quot;&gt;黄色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-green&quot;&gt;绿色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-blue&quot;&gt;蓝色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-grey&quot;&gt;灰色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-red&quot;&gt;红色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-purple&quot;&gt;紫色色块&lt;&#x2F;span&gt;\nCSS 样式里添加自定义颜色块，在文章中引用，主题不同配置有所差异，例如 NexT 主题在blog\\themes\\next\\source\\css\\_custom 下添加以下内容，Butterfly 主题在 blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下添加（不用在意符号，直接添加即可），各举一例，其余色块见其他文章。色块的所有配置传送点\n\n左边框红色块级\n右边框红色块级\n上边框蓝色块级CSS 样式里添加自定义颜色块，Butterfly 在 blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下添加（不用在意符号，直接添加即可）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;&#x2F; 颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#000;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FFD700;&#125;    &#x2F;&#x2F; 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;&#x2F;&#x2F; 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;&#x2F;&#x2F; 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;&#x2F;&#x2F; 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;文章中添加代码\n左边框红色块级\n 右边框红色块级\n 上边框蓝色块级123&lt;p id&#x3D;&quot;div-border-left-red&quot;&gt;左边框红色块级&lt;&#x2F;p&gt;&lt;p id&#x3D;&quot;div-border-right-red&quot;&gt;右边框红色块级&lt;&#x2F;p&gt;&lt;p id&#x3D;&quot;div-border-top-blue&quot;&gt;上边框蓝色块级&lt;&#x2F;p&gt;\n字体样式\nMarkDown嵌入HTML文字样式即可，字体名称及颜色代码可在字体、颜色常用代码找到\n\n这是黑体字\n1&lt;font face&#x3D;&quot;黑体&quot;&gt;这是黑体字&lt;&#x2F;font&gt;这是微软雅黑\n1&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;这是微软雅黑&lt;&#x2F;font&gt;这是华文彩云\n1&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;这是华文彩云&lt;&#x2F;font&gt;三号蓝色黑体\n1&lt;font color&#x3D;#0099ff size&#x3D;3 face&#x3D;&quot;黑体&quot;&gt;三号蓝色黑体&lt;&#x2F;font&gt;四号青色字\n1&lt;font color&#x3D;#00ffff size&#x3D;4&gt;四号青色字&lt;&#x2F;font&gt;五号灰色字\n1&lt;font color&#x3D;gray size&#x3D;5&gt;五号灰色字&lt;&#x2F;font&gt;","plink":"https://dxsummer.gitee.io/posts/c079e252/"},{"title":"About","date":"2020-05-25T09:28:23.000Z","date_formatted":{"ll":"2020年5月25日","L":"2020/05/25","MM-DD":"05-25"},"updated":"2020-06-05T05:39:15.482Z","content":"\n\n  [Dx的博客🐷]\n  \n    \n    \n    \n    \n    与&nbsp;\n    DxSummer&nbsp;\n    （\n    \n    技术的进步总是从痛苦开始\n    \n    ）\n    \n    交流中...\n    \n    \n    \n    \n  \n\n\n\nbot_ui_ini()\n\n\n","plink":"https://dxsummer.gitee.io/about/"}]